---
title: "算法目录"
excerpt: "剑指Offer第二版 + LeetCode目录"
categories:
  - Algorithm
tags:
  - content
header:
  overlay_image: /assets/images/leetcode/algo.png
  overlay_filter: rgba(126, 202, 286, 0.4)
classes: wide
# toc: true
# toc_label: "目录"
last_modified_at: 2019-04-25T20:15:38+08:00
---

<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

剑指Offer简写CI、LeetCode简写LC

<figcaption>剑指Offer 第二版</figcaption>

| Question | Comment | topic |
| -------- | ------- | ----- |
| [(3)数组中重复的数字](/algorithm/code_interviews/#11-3%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97) | [LC-41-First Missing Positive](/algorithm/leetcode41-50/#41-first-missing-positive) | [Array](){: .tag } |
| [(4)二维数组中的查找](/algorithm/code_interviews/#12-4%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE) | 选取左下角或右上角这种中间位置的数字开始，每次判断可以剔除一行或一列 | [Array](){: .tag } |
| [(5)替换空格](/algorithm/code_interviews/#21-5%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC) | 统计空格个数确定新串长度，创建新串，开始复制 | [String](){: .tag } |
| [(6)从尾到头打印链表](/algorithm/code_interviews/#31-6%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8) | 栈或递归 | [Linked List](){: .tag } |
| [(7)重建二叉树](/algorithm/code_interviews/#41-7%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91) | 先在前序序列找到根节点，然后在中序序列中找到该节点，左边就是左子树，右边就是右子树 | [Tree](){: .tag } |
| [(8)二叉树的下一个节点](/algorithm/code_interviews/#42-8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9) |  | [Tree](){: .tag } |
| [(9)用两个栈实现队列](/algorithm/code_interviews/#51-9%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97) | 相关题目：两个队列实现一个栈 | [Stack](){: .tag } [Queue](){: .tag } |
| [(10)斐波那契数列](/algorithm/code_interviews/#611-10%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97) | 相关题目：青蛙跳台阶问题、矩形填充问题 | [Recursion](){: .tag } |
| [(11)旋转数组的最小数字](/algorithm/code_interviews/#621-11%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97) | 先二分查找，当lo=mid=hi时，需要进行顺序查找 | [Binary Search](){: .tag } |
| [(12)矩阵中的路径](/algorithm/code_interviews/#631-12%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84) |  | [Backtracking](){: .tag } |
| [(13)机器人的运动范围](/algorithm/code_interviews/#632-13%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4) |  | [Backtracking](){: .tag } |
| [(14)剪绳子](/algorithm/code_interviews/#641-14%E5%89%AA%E7%BB%B3%E5%AD%90) | Greedy：当n>=5时，我们尽可能多地剪长度为3的绳子；当剩下的绳子长度为4时，把绳子剪成两段长度为2的绳子 | [Dynamic Programming](){: .tag } [Greedy](){: .tag } |
| [(15)二进制中1的个数](/algorithm/code_interviews/#651-15%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0) | **把一个整数减去1，再和原整数做位与运算，会把该整数最右边的1变成0**<br />相关题目：用一条语句判断一个整数是不是2的整数次方<br />相关题目：输入两个整数m和n，计算需要改变m的二进制表示中的多少位才能得到n | [Bit Manipulation](){: .tag } |
| [(16)数值的整数次方](/algorithm/code_interviews_3/#11-16%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9) | [LC-50-Pow(x, n)](/algorithm/leetcode41-50/#50-powx-n) |  |
| [(17)打印1到最大的n位数](/algorithm/code_interviews_3/#12-17%E6%89%93%E5%8D%B01%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0) | 大数问题，可以使用全排列的思路 |  |
| [(18)删除链表的节点](/algorithm/code_interviews_3/#13-18%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9) | $$O(1)$$时间内删除一个节点，可以采取复制节点值的方法 | [Linked List](){: .tag } |
| [(19)正则表达式匹配](/algorithm/code_interviews_3/#14-19%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D) | 字符‘.’表示任意一个字符，而‘*’表示它前面的字符可以出现任意次（含0次）<br />[LC-10-Regular Expression Matching](/algorithm/leetcode1-10/#10-regular-expression-matching) | [Recursion](){: .tag } |
| [(20)表示数值的字符串](/algorithm/code_interviews_3/#15-20%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2) |  |  |
| [(21)调整数组顺序使奇数位于偶数前面](/algorithm/code_interviews_3/#16-21%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2) |  | [Two Pointer](){: .tag } |
| [(22)链表中倒数第k个结点](/algorithm/code_interviews_3/#21-22%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9) | [LC-19-Remove Nth Node From End of List](/algorithm/leetcode11-20/#19-remove-nth-node-from-end-of-list)<br />相关题目：求链表的中间节点。如果链表为奇数，返回中间节点；如果是偶数，则返回中间两个的任意一个。<br />举一反三：两个指针遍历链表 | [Linked List](){: .tag } |
| [(23)链表中环的入口结点](/algorithm/code_interviews_3/#22-23%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9) | 使用两个指针 | [Linked List](){: .tag } |
| [(24)反转链表](/algorithm/code_interviews_3/#23-24%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8) | 本题扩展：使用递归实现 | [Linked List](){: .tag } |
| [(25)合并两个排序的链表](/algorithm/code_interviews_3/#24-25%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8) | [LC-21-Merge Two Sorted Lists](/algorithm/leetcode21-30/#21-merge-two-sorted-lists)<br />注意操作列表最好不要直接操作入参列表，所以合并的时候会创建一些节点 | [Linked List](){: .tag } |
| [(26)树的子结构](/algorithm/code_interviews_3/#25-26%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84) | | [Tree](){: .tag } [Recursion](){: .tag } |
| [(27)二叉树的镜像](/algorithm/code_interviews_4/#11-27%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F) | 交换左右子节点，并对左右子节点进行递归 | [Tree](){: .tag } [Recursion](){: .tag } |
| [(28)对称的二叉树](/algorithm/code_interviews_4/#12-28%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91) | 先比较根节点，然后递归比较左子树的左节点与右子树的右节点、左子树的右节点与右子树的子节点 | [Tree](){: .tag } [Recursion](){: .tag } |
| [(29)顺时针打印矩阵](/algorithm/code_interviews_4/#13-29%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5) | [LC-54-Spiral Matrix](/algorithm/leetcode51-60/#54-spiral-matrix)<br />注意边界条件的判断 | [Array](){: .tag } |
| [(30)包含min函数的栈](/algorithm/code_interviews_4/#21-30%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88) | 额外使用一个辅助栈，栈中同步保存每次进栈操作时栈中最小值 | [Stack](){: .tag } |
| [(31)栈的压入、弹出序列](/algorithm/code_interviews_4/#22-31%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97) | 使用辅助栈 | [Stack](){: .tag } |
| [(32)从上到下打印二叉树](/algorithm/code_interviews_4/#23-32%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91) |  | [Tree](){: .tag } |
| [(33)二叉搜索树的后序遍历序列](/algorithm/code_interviews_4/#24-33%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97) | 二叉搜索树的特征、后序遍历序列特征<br />相关题目：输入一个整数数组，判断该数组是不是某二叉搜索树的前序遍历结果<br /> | [Tree](){: .tag } |
| [(34)二叉树中和为某一值的路径](/algorithm/code_interviews_4/#25-34%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84) |  | [Tree](){: .tag }  [Recursion](){: .tag } |
| [(35)复杂链表的复制](/algorithm/code_interviews_4/#31-35%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6) |  | [Linked List](){: .tag } |
| [(36)二叉搜索树与双向链表](/algorithm/code_interviews_4/#32-36%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8) |  | [Tree](){: .tag } |
| [(37)序列化二叉树](/algorithm/code_interviews_4/#33-37%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91) |  | [Tree](){: .tag } |
| [(38)字符串的排列](/algorithm/code_interviews_4/#34-38%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97) | 全排列问题<br />[LC-46-Permutations](/algorithm/leetcode41-50/#46-permutations)<br />相关题目：[LC-51-N-Queens](/algorithm/leetcode51-60/#51-n-queens)、[LC-52-N-Queens II](/algorithm/leetcode51-60/#52-n-queens-ii) | [Backtracking](){: .tag } |
| [(39)数组中出现次数超过一半的数字](/algorithm/code_interviews_5/#11-39%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97) | 利用快排思想求数组的中位数<br />利用数组的特点 | [Array](){: .tag } |
| [(40)最小的k个数](/algorithm/code_interviews_5/#12-40%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0) | 利用快排思想<br />直接利用最小堆<br />利用容量为k的最大堆，堆满后保存堆顶和值的较小者，这样每次都会挤出最大堆中最大值，而保留较小值 | [Heap](){: .tag } |
| [(41)数据流中的中位数](/algorithm/code_interviews_5/#13-41%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0) | 使用最大堆和最小堆，中位数在最大堆和最小堆的堆顶中取得 | [Heap](){: .tag } |
| [(42)连续子数组的最大和](/algorithm/code_interviews_5/#14-42%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C) | [LC-53-Maximum Subarray](/algorithm/leetcode51-60/#53-maximum-subarray)<br />如果某步累加的结果不是正数，那么这些累加是可以抛弃的；否则可正常进行累加 | [Array](){: .tag } [Dynamic Programming](){: .tag } |
| [(43)从1到n整数中1出现的次数](/algorithm/code_interviews_5/#15-43%E4%BB%8E1%E5%88%B0n%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0) |  | [Dynamic Programming](){: .tag } |
| [(44)数字序列中某一位的数字](/algorithm/code_interviews_5/#16-44%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97) |  |  |
| [(45)把数组排成最小的数](/algorithm/code_interviews_5/#17-45%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0) |  |  |
| [(46)把数字翻译成字符串](/algorithm/code_interviews_5/#18-46%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2) |  | [Recursion](){: .tag } |
| [(47)礼物的最大价值](/algorithm/code_interviews_5/#19-47%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC) |  | [Dynamic Programming](){: .tag } |
| [(48)最长不含重复字符的子字符串](/algorithm/code_interviews_5/#110-48%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2) | [LC-3-Longest Substring Without Repeating Characters](/algorithm/leetcode1-10/#3-longest-substring-without-repeating-characters) | [Set](){: .tag } |
| [(49)丑数](/algorithm/code_interviews_5/#21-49%E4%B8%91%E6%95%B0) | 根据丑数的定义，丑数应该是另一个丑数乘以2、3或者5的结果。 |  |
| [(50)第一个只出现一次的字符](/algorithm/code_interviews_5/#22-50%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6) | 基于字符的ASCII码创建一个简单的哈希表数组 | [Hash Table](){: .tag } |
| [(51)数组中的逆序对](/algorithm/code_interviews_5/#23-51%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9) |  | [Merge Sort](){: .tag } |
| [(52)两个链表的第一个公共节点](/algorithm/code_interviews_5/#24-52%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9) | 两个指针，先在长链表上走上差值的步数，最后两个指针一起走 | [Linked List](){: .tag } |
| [(53)在排序数组中查找数字](/algorithm/code_interviews_6/#1-53%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97) |  | [Binary Search](){: .tag } |
| [(54)二叉搜索树的第k个结点](/algorithm/code_interviews_6/#2-54%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9) | 树的中序遍历算法 | [Tree](){: .tag } |
| [(55)二叉树的深度](/algorithm/code_interviews_6/#3-55%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6) | 判断是不是平衡二叉树可以采用后序遍历算法 | [Tree](){: .tag }<br />[Recursion](){: .tag } |
| [(56)数组中数字出现的次数](/algorithm/code_interviews_6/#4-56%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0) | 任何一个数字异或它自己都等于0 | [Bit Manipulation](){: .tag } |
| [(57)和为s的数字](/algorithm/code_interviews_6/#5-57%E5%92%8C%E4%B8%BAs%E7%9A%84%E6%95%B0%E5%AD%97) |  | [Array](){: .tag } |
| [(58)翻转字符串](/algorithm/code_interviews_6/#6-58%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2) | 多次不同范围的翻转可以解决问题 | [String](){: .tag } |
| [(59)队列的最大值](/algorithm/code_interviews_6/#7-59%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC) |  | [Queue](){: .tag } |
| [(60)n个骰子的点数](/algorithm/code_interviews_6/#8-60n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0) |  |  |
| [(61)扑克牌的顺子](/algorithm/code_interviews_6/#9-61%E6%89%91%E5%85%8B%E7%89%8C%E7%9A%84%E9%A1%BA%E5%AD%90) |  |  |
| [(62)圆圈中最后剩下的数字](/algorithm/code_interviews_6/#10-62%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97) | 数学解法：$$f(n,m)=\begin{cases} 0 & n=1 \\ [f(n-1,m)+m]\%n & n>1 \end{cases}$$ | [Linked List](){: .tag } |
| [(63)股票的最大利润](/algorithm/code_interviews_6/#11-63%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6) | 保存目前数据中最小的数，用当前的数减去最小数得到当前利润，取当前利润和之前最大利润的最大值即可 |  |
| [(64)求1+2+…+n](/algorithm/code_interviews_6/#12-64%E6%B1%8212n) |  |  |
| [(65)不用加减乘除做加法](/algorithm/code_interviews_6/#13-65%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95) | CPU加法器的实现：使用位运算<br />相关问题，交换两个变量的值：<br />1. a = a + b; b = a - b; a = a - b;<br />2. a = a ^ b; b = a ^ b; a = a ^ b; | [Bit Manipulation](){: .tag } |
| [(66)构建乘积数组](/algorithm/code_interviews_6/#14-66%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84) |  |  |
| [(67)把字符串转换成整数](/algorithm/code_interviews_6/#15-67%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0) | [LC-8-String to Integer (atoi)](/algorithm/leetcode1-10/#8-string-to-integer-atoi) | [String](){: .tag } |
| [(68)树中两个结点的最低公共祖先](/algorithm/code_interviews_6/#16-68%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E7%BB%93%E7%82%B9%E7%9A%84%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88) | 先求路径，然后在求最低公共祖先 | [Tree](){: .tag } |

[](){: .tag }

<figcaption>LeetCode</figcaption>

| Question | Comment | topic |
| -------- | ------- | ----- |
| [1. Two Sum](/algorithm/leetcode1-10/#1-two-sum) | 利用HashTable的性质 | [Array](){: .tag }  [Hash Table](){: .tag } |
| [2. Add Two Numbers](/algorithm/leetcode1-10/#2-add-two-numbers) |  | [Linked List](){: .tag } |
| [3. Longest Substring Without Repeating Characters](/algorithm/leetcode1-10/#3-longest-substring-without-repeating-characters) | [CI-(48)最长不含重复字符的子字符串](/algorithm/code_interviews_5/#110-48%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2) | [String](){: .tag } [Set](){: .tag } |
| [4. Median of Two Sorted Arrays](/algorithm/leetcode1-10/#4-median-of-two-sorted-arrays) | 题目要求要$$O(log(m+n))$$的时间复杂度，所以只能二分递归查找 | [Binary Search](){: .tag } [Divide and Conquer](){: .tag } |
| [5. Longest Palindromic Substring](/algorithm/leetcode1-10/#5-longest-palindromic-substring) | 需要以i为end点，以max为标准进行扩展，判断max+1或max+2长度的字符串是不是回数 | [String](){: .tag } |
| [6. ZigZag Conversion](/algorithm/leetcode1-10/#6-zigzag-conversion) | 定义row个StringBuilder，遇到第0行或倒数第1行掉头，按顺序取字符即可 | [String](){: .tag } |
| [7. Reverse Integer](/algorithm/leetcode1-10/#7-reverse-integer) | 先处理无符号int，用long保存临时结果，每次累加后判断是不是溢出，最后加上符号 |  |
| [8. String to Integer (atoi)](/algorithm/leetcode1-10/#8-string-to-integer-atoi) | 先`trim()`清除头尾的空白字符串，然后判断第一位是不是符号位，然后在当前位是数字的情况下进行累加，每次累加完成后判断有没有溢出 | [String](){: .tag } |
| [9. Palindrome Number](/algorithm/leetcode1-10/#9-palindrome-number) |  |  |
| [10. Regular Expression Matching](/algorithm/leetcode1-10/#10-regular-expression-matching) |  |  |
| [11. Container With Most Water](/algorithm/leetcode11-20/#11-container-with-most-water) |  |  |
| [12. Integer to Roman](/algorithm/leetcode11-20/#12-integer-to-roman) |  |  |
| [13. Roman to Integer](/algorithm/leetcode11-20/#13-roman-to-integer) |  |  |
| [14. Longest Common Prefix](/algorithm/leetcode11-20/#14-longest-common-prefix) |  |  |
| [15. 3Sum](/algorithm/leetcode11-20/#15-3sum) |  |  |
| [16. 3Sum Closest](/algorithm/leetcode11-20/#16-3sum-closest) |  |  |
| [17. Letter Combinations of a Phone Number](/algorithm/leetcode11-20/#17-letter-combinations-of-a-phone-number) |  |  |
| [18. 4Sum](/algorithm/leetcode11-20/#18-4sum) |  |  |
| [19. Remove Nth Node From End of List](/algorithm/leetcode11-20/#19-remove-nth-node-from-end-of-list) |  |  |
| [20. Valid Parentheses](/algorithm/leetcode11-20/#20-valid-parentheses) |  |  |
| [21. Merge Two Sorted Lists](/algorithm/leetcode21-30/#21-merge-two-sorted-lists) |  |  |
| [22. Generate Parentheses](/algorithm/leetcode21-30/#22-generate-parentheses) |  |  |
| [23. Merge k Sorted Lists](/algorithm/leetcode21-30/#23-merge-k-sorted-lists) |  |  |
| [24. Swap Nodes in Pairs](/algorithm/leetcode21-30/#24-swap-nodes-in-pairs) |  |  |
| [25. Reverse Nodes in k-Group](/algorithm/leetcode21-30/#25-reverse-nodes-in-k-group) |  |  |
| [26. Remove Duplicates from Sorted Array](/algorithm/leetcode21-30/#26-remove-duplicates-from-sorted-array) |  |  |
| [27. Remove Element](/algorithm/leetcode21-30/#27-remove-element) |  |  |
| [28. Implement strStr()](/algorithm/leetcode21-30/#28-implement-strstr) |  |  |
| [29. Divide Two Integers](/algorithm/leetcode21-30/#29-divide-two-integers) |  |  |
| [30. Substring with Concatenation of All Words](/algorithm/leetcode21-30/#30-substring-with-concatenation-of-all-words) |  |  |
| [31. Next Permutation](/algorithm/leetcode31-40/#31-next-permutation) |  |  |
| [32. Longest Valid Parentheses](/algorithm/leetcode31-40/#32-longest-valid-parentheses) |  |  |
| [33. Search in Rotated Sorted Array](/algorithm/leetcode31-40/#33-search-in-rotated-sorted-array) |  |  |
| [34. Find First and Last Position of Element in Sorted Array](/algorithm/leetcode31-40/#34-find-first-and-last-position-of-element-in-sorted-array) |  |  |
| [35. Search Insert Position](/algorithm/leetcode31-40/#35-search-insert-position) |  |  |
| [36. Valid Sudoku](/algorithm/leetcode31-40/#36-valid-sudoku) |  |  |
| [37. Sudoku Solver](/algorithm/leetcode31-40/#37-sudoku-solver) |  |  |
| [38. Count and Say](/algorithm/leetcode31-40/#38-count-and-say) |  |  |
| [39. Combination Sum](/algorithm/leetcode31-40/#39-combination-sum) |  |  |
| [40. Combination Sum II](/algorithm/leetcode31-40/#40-combination-sum-ii) |  |  |
| [41. First Missing Positive](/algorithm/leetcode41-50/#41-first-missing-positive) |  |  |
| [42. Trapping Rain Water](/algorithm/leetcode41-50/#42-trapping-rain-water) |  |  |
| [43. Multiply Strings](/algorithm/leetcode41-50/#43-multiply-strings) |  |  |
| [44. Wildcard Matching](/algorithm/leetcode41-50/#44-wildcard-matching) |  |  |
| [45. Jump Game II](/algorithm/leetcode41-50/#45-jump-game-ii) |  |  |
| [46. Permutations](/algorithm/leetcode41-50/#46-permutations) |  |  |
| [47. Permutations II](/algorithm/leetcode41-50/#47-permutations-ii) |  |  |
| [48. Rotate Image](/algorithm/leetcode41-50/#48-rotate-image) |  |  |
| [49. Group Anagrams](/algorithm/leetcode41-50/#49-group-anagrams) |  |  |
| [50. Pow(x, n)](/algorithm/leetcode41-50/#50-powx-n) |  |  |