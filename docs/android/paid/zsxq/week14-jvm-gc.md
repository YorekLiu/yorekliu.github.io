---
title: "JVM中垃圾回收策略"
---

???+ question "简单描述下JVM的垃圾回收策略，比如引用计数、标记清除等策略。"

详情可以参考[深入理解Java虚拟机](/jvm/jvm-content/)中[Java内存区域与内存溢出异常](/jvm/java-memory-area-oom/)以及[垃圾收集器与内存分配策略](/jvm/java-gc/)两章，此处简单小结一下。

## 1. JVM内存划分

Java虚拟机所管理的内存将会包括以下几个运行时数据区域，其中方法区和堆是线程共享的，虚拟机栈、本地方法栈、程序计数器则是线程私有的，如图1所示。

![JVM运行时数据区](/assets/images/jvm/JVM运行时数据区.png)

- 程序计数器  
  程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。  
  为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。  
- Java虚拟机栈  
  Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。  
  局部变量表所需的内存空间在编译期间完成分配，在方法运行期间不会改变局部变量表的大小。
- 本地方法栈  
  本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。
- Java堆  
  Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。  
  Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；由于新生代基本采用复制算法，所以还可以细致一点划分为Eden空间、From Survivor空间、To Survivor空间等。
- 方法区  
  方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。  
  在HotSpot虚拟机，方法区被称为“永久代”（Permanent Generation），因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作。  
  这区域的内存回收目标主要是针对常量池的回收和对类型的卸载。
- 运行时常量池  
  运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

## 2. 哪些内存需要回收

程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存。

**确定堆中那些对象还存活**

- 引用计数法  
  给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。  
  很难解决对象之间相互循环引用的问题。
- 可达性分析算法  
  通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。  
  在Java语言中，可作为GC Roots的对象包括下面几种：  
    - 虚拟机栈（栈帧中的本地变量表）中引用的对象。
    - 本地方法栈中JNI（即一般说的Native方法）引用的对象。  
    - 方法区中类静态属性引用的对象。
    - 方法区中常量引用的对象。

    ![可达性分析算法判定对象是否可回收](/assets/images/jvm/jvm-reachability-analysis.png)

**对方法区的回收**  

永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。  
判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是“无用的类”：

- 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。
- 加载该类的ClassLoader已经被回收。
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

## 3. 如何回收

- 标记-清除算法  
  算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象  
  缺点：  
    - 效率问题：标记和清除两个过程的效率都不高
    - 空间问题：标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作
      ![“标记-清除”算法示意图](/assets/images/jvm/jvm-mark-sweep.png)

- 复制算法  
  将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。  
  现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。
  ![复制算法示意图](/assets/images/jvm/jvm-copying.png)

- 标记-整理算法  
  标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存  
  ![“标记-整理”算法示意图](/assets/images/jvm/jvm-mark-compact.png)

- 分代收集算法  
  根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收