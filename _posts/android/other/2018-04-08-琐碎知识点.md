---
excerpt: "记录一下博主遇到的琐碎的知识点，方便查找"
categories:
  - Android
tags:
  - CopyOnWriteArrayList
  - RemoteCallbackList
  - windowSoftInputMode
  - SoftInput
  - Sort
  - Comparator
  - Dial
  - Call
  - SMS
  - drawable
  - Response
  - Font
  - CountDownLatch
  - CountDownTimer
  - Notification
  - ViewPager
  - FullScreen
  - SplashActivity
  - HapticFeedback
  - Vibrator
  - javascript
  - NavigationView
  - CardView
  - TypedValue
  - OkHttp
  - Retrofit
last_modified_at: 2018-04-17T15:25:19+08:00
---

{% include base_path %}

CopyOnWriteArrayList支持并发读写。

---

RemoteCallbackList支持跨进程删除listener，原理是`ArrayMap<IBinder, Callback>`。IPC时Parcelable对象会序列化、反序列化，因此不会是同一个对象，但底层IBinder不会变。
它同时具有以下特点：
1. 客户端进程终止后，能够自动移除客户端注册的listener
2. RemoteCallbackList内部自动实现了线程同步功能，所以使用它来进行注册、解注册时不需要做额外的线程同步工作。

---

EditText禁止进入时弹出键盘：
```xml
android:windowSoftInputMode="stateHidden"
```
键盘弹出时禁止顶动View：
```xml
android:windowSoftInputMode="adjustPan"
```

---

跳转拨号盘
```java
new Intent(Intent.ACTION_DIAL, Uri.parse("tel:12306"));
```
直接拨打电话
```java
new Intent(Intent.ACTION_CALL, Uri.parse("tel:12306"));
```
发送短信
```java
new Intent(Intent.ACTION_SENDTO, Uri.parse("smsto:12306"));
```

---

Java Bean实体进行排序
```java
Collections.sort(mRowsBeanList, new Number2zComparator());

private class Number2zComparator implements Comparator<T> {
    @Override
    public int compare(T o1, T o2) {
        boolean o1IsHot = o1.getHotFlag() == 1;
        boolean o2IsHot = o2.getHotFlag() == 1;
        String o1Letter = PinyinUtils.ccs2Pinyin(o1.getPlatformName());
        String o2Letter = PinyinUtils.ccs2Pinyin(o2.getPlatformName());

        if (o1IsHot && o2IsHot) {
            return o1Letter.compareToIgnoreCase(o2Letter);
        } else if (o1IsHot) {
            return -1;
        } else if (o2IsHot) {
            return 1;
        }

        return o1Letter.compareToIgnoreCase(o2Letter);
    }
}
```
o1与o2进行比较，如果o1要排在o2前面，返回-1;  
如果两者相等，返回0;  
如果o1排在o2后面，返回1。

---

Gif加载  
在尝试Glide加载(不卡，但是图片错乱了)、帧动画实现(超级耗内存，30帧，每帧8k原图，耗内存大约20M)、android-gif-drawable库(Android O异常卡顿，耗内存大约10M)加载失败之后，找到了一种新奇的思路：每隔一段时间调用`setBackgroundResource`，内存消耗基本不计。

---

代码设置drawable：  
setCompoundDrawablesWithIntrinsicBounds

---

OkHttp访问网络成功的回调中，`Response response`的response.body().string()只能调用一次，否则
```java
E/AndroidRuntime: FATAL EXCEPTION: OkHttp Dispatcher
                  Process: yorek.demoandtest, PID: 24671
                  java.lang.IllegalStateException: closed
```

---

Glide加载圆形图片

```java
Glide.with(mContext)
    .load(item.platformLogo)
    .bitmapTransform(CropCircleTransformation(mContext))
    .into(iv_logo)
```

其中，`.bitmapTransform(CropCircleTransformation(mContext))`是其中的重点，
`CropCircleTransformation`使用了`jp.wasabeef:glide-transformations:2.0.2`这个lib

```
compile 'jp.wasabeef:glide-transformations:2.0.2'
```
---

`SwipeRefreshLayout`与`CollapsingToolbarLayout`和充满`RecyclerView`的`ViewPager`联用出现的滑动冲突问题

解决办法是自定义`SwipeRefreshLayout`，在`AppBarLayout`元素没有到顶时允许child向上滑，到顶后不允许滑动，这样就触发了下拉刷新。

```java
public class CreditFragmentSwipeRefreshLayout extends SwipeRefreshLayout {
    private AppBarLayout targetView;

    public CreditFragmentSwipeRefreshLayout(Context context) {
        super(context);
    }

    public CreditFragmentSwipeRefreshLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();
        targetView = (AppBarLayout) findViewById(R.id.abl);
    }

    @Override
    public boolean canChildScrollUp() {
        if (targetView != null) {
            return targetView.getTop() != 0;
        } else {
            return super.canChildScrollUp();
        }
    }
}
```

---
Android中字体的加载

在`app/src/main/assets`下面放置字体文件，然后使用下面的代码加载    
```kotlin
class KTypeface {
    companion object {
        val DIN_PRO_MIDIUM =
            Typeface.createFromAsset(MyApp.getInstance().assets, "DINPro-Medium.otf")
        val ROBOTO_MIDIUM =
            Typeface.createFromAsset(MyApp.getInstance().assets, "Roboto-Medium.ttf")
    }
}
```

这么使用：  
```kotlin
tvMyScore.typeface = KTypeface.DIN_PRO_MIDIUM
```

Android中字体最好加载一次之后缓存起来，因为每次加载需要消耗时间。

---
`CountDownLatch`与`CountDownTimer`  

`CountDownLatch`是用来实现线程同步的一个工具。其主要有一下三个方法  
1. `public CountDownLatch(int count)`  
  初始化计数器
2.  `public void await() throws InterruptedException`  
  堵塞线程，直到计数器为0
3.  `public void countDown()`  
  计数，表示执行完成。没调用一次，计数器会减1



`CountDownTimer`是一种用来实现倒计时的手段，其用法如下:  

```java
timer = new CountDownTimer(count * 1000, 1000) {
    @Override
    public void onTick(long millisUntilFinished) {
        tvGetcode.setText(((millisUntilFinished / 1000) + "秒后重发"));
    }

    @Override
    public void onFinish() {
        tvGetcode.setEnabled(true);
        tvGetcode.setText("获取验证码");
    }
};
timer.start();
```

如上，创建之后调用`start`方法开始计数，每隔一段(第二个参数)就会调用`onTick`方法，在这里更新倒计时，最后会调用`onFinish`方法，这里进行倒计时完成的操作。  
当然`CountDownTimer`也是有`cancel`来取消倒计时的。

不过，在实践中发现这种倒计时方式`onTick`报时不太准，因为这依赖于底层的`Handler`来执行操作。

---
判断应用通知权限是否打开

```java
/**
 * 只能检查KITKAT及以上的系统，以下会返回true
 */
public static boolean isNotificationEnabled(Context context) {
    NotificationManagerCompat notificationManagerCompat = NotificationManagerCompat.from(context);
    return notificationManagerCompat.areNotificationsEnabled();
}
```

---
ViewPager实现画廊效果

<iframe width="320" height="568" src="{{ base_path }}/assets/videos/viewpager_clipparent.mp4" frameborder="0" allowfullscreen></iframe>

实现原理很简单
1. `ViewPager`的父布局需要设置`clipChildren = false`，同时最好设置背景色(pageMargin的部分需要背景色填充)
2. `ViewPager`也需要设置`clipChildren = false`
3. `ViewPager`宽度为`MATCH_PARENT`，但需要为其设置`leftMargin`和`rightMargin`，这样才有画廊的效果
4. 两张卡片之间的间距由`ViewPager`的`pageMargin`控制

`ViewPager`里面的子元素距离边框最好不要有`padding`以及`margin`，这样不利于控制效果
{: .notice--info }

---
全面屏Splash以及广告页适配指北

**`SplashActivity`适配**
1. 新建`drawable-xxhdpi-2016x1080`文件夹，里面放入为全面屏准备的开屏页(一般是1080x2160)
2. 在`SplashActivity`的主题中加入`<item name="android:windowBackground">@drawable/img_splash</item>`(所谓程序秒开主要指这个)

**广告页适配(我家广告页就是与`SplashActivity` style一样的第二屏)**  
这个位置麻烦的地方就是需要显示从网络下载的图片，而且有多种尺寸，所以为了在全面屏上显示更好，我们需要加载一张1080x2160大小的图片然后显示。  
所以，我们会先判断是不是全面屏，如果是就下载1080x2160大小的图片，否则一律下载1080x1920大小的图片。

```java
// 下载图片的判断逻辑
String screenType = "1080x1920";
Point point = HRScreenUtils.Companion.getScreenSize(this);
if (HRScreenUtils.Companion.isFullScreen(point.x, point.y)) {
    screenType = "1080x2160";
}
Call<FestivalImgRes> call = HttpHelper.getApiService().getFestivalHead("android", screenType);

// ------------------------------
// HRScreenUtils.kt
class HRScreenUtils {
    companion object {
        fun isFullScreen(width: Int, height: Int) : Boolean = (1.0f * height / width) >= 1.86f

        fun getScreenSize(context: Context): Point {
            val point = Point()
            val windowManager = context.getSystemService(Context.WINDOW_SERVICE) as WindowManager
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
                windowManager.defaultDisplay.getRealSize(point)
            } else {
                windowManager.defaultDisplay.getSize(point)
            }

            return point
        }
    }
}
```

---
震动反馈

不调用`Vibrator`实现震动反馈的两种方式
- 在`View`的`OnLongClickListener`中返回`true`
- 调用`View#performHapticFeedback(HapticFeedbackConstants.KEYBOARD_TAP);`方法

> 震动反馈能否发生还取决与系统的震动反馈设置，通过`performHapticFeedback`重载方法实现震动反馈可以忽略系统设置。

---
L平台共享元素动画

1. 为两个`Activity`中需要进行动画的`View`取上相同的`transitionName`，若需要同时进行多个元素的动画，每个元素的`transitionName`都要不同
2. 跳转`Activity`时，
  - 若只有一个元素，可以调用`startActivity(intent, ActivityOptions.makeSceneTransitionAnimation(this, tv_right, getString(R.string.transition_name)).toBundle())`
  - 若多个元素，如下

```java
ActivityOptions activityOptions = ActivityOptions.makeSceneTransitionAnimation(getActivity(),
        new Pair<>(view.findViewById(R.id.iv_folder_icon), getContext().getString(R.string.transition_task_icon)),
        new Pair<>(view.findViewById(R.id.tv_folder_progress_value), getContext().getString(R.string.transition_task_progress_value)),
        new Pair<>(view.findViewById(R.id.pb_folder_progress), getContext().getString(R.string.transition_task_progress)),
        new Pair<>(view.findViewById(R.id.tv_folder_count), getContext().getString(R.string.transition_task_count)));
Intent intent = new Intent(getContext(), TodoFolderActivity.class);
getContext().startActivity(intent, activityOptions.toBundle());
```

> 由B返回A时，一般情况都也会默认进行共享元素动画返回，特殊情况下可以调用`finishAfterTransition()`进行共享元素动画返回

共享元素动画执行的过程也有监听方法，`SharedElementCallback`里面方法比较多，具体可以看源码注释
- Activity#setEnterSharedElementCallback(SharedElementCallback)
- Activity#setExitSharedElementCallback(SharedElementCallback)
- Fragment#setEnterSharedElementCallback(SharedElementCallback)
- Fragment#setExitSharedElementCallback(SharedElementCallback)
- SharedElementCallback
  - onSharedElementStart
  - onSharedElementEnd
  - onRejectSharedElements
  - onMapSharedElements
  - onSharedElementsArrived

---
向webview注入本地JS并调用  

1.定义本地JS文件(test.js)，放到assets目录下

```javascript
'use strict';

function test() {
  $(".fake-box input").val('1');
  angular.element(document.getElementById('pwd-input')).scope().$apply('verify_code = "123458"');
}
```

2.定义webview注入本地js文件的方法

```java
private void injectScriptFile(WebView view, String scriptFile) {
    InputStream input;
    try {
        input = getAssets().open(scriptFile);
        byte[] buffer = new byte[input.available()];
        input.read(buffer);
        input.close();

        // String-ify the script byte-array using BASE64 encoding !!!
        String encoded = Base64.encodeToString(buffer, Base64.NO_WRAP);
        view.loadUrl("javascript:(function() {" +
                "var parent = document.getElementsByTagName('head').item(0);" +
                "var script = document.createElement('script');" +
                "script.type = 'text/javascript';" +
                // Tell the browser to BASE64-decode the string into your script !!!
                "script.innerHTML = window.atob('" + encoded + "');" +
                "parent.appendChild(script)" +
                "})()");
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
}
```

3.注入并调用

```java
injectScriptFile(webView, "test.js");                   // 注入
webView.loadUrl("javascript:setTimeout(test(), 500)");  // 调用
```

---
给`NavigationView`中的菜单添加分割线，只要给每个group添加id即可。

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    tools:showIn="navigation_view">

    <group
        android:id="@+id/group_all"
        android:checkableBehavior="single">
        <item
            android:id="@+id/nav_all"
            android:icon="@drawable/ic_menu_lightbulb"
            android:title="@string/nav_menu_all"
            android:checked="true"/>
    </group>

    <item android:title="@string/nav_menu_labels">
        <menu>
            <group android:checkableBehavior="single">
                <item
                    android:id="@+id/nav_new_label11"
                    android:icon="@drawable/ic_menu_lightbulb"
                    android:title="测试1"/>
                <item
                    android:id="@+id/nav_new_label"
                    android:icon="@drawable/ic_menu_lightbulb"
                    android:title="@string/nav_menu_create_new_label" />
            </group>
        </menu>
    </item>

    <group
        android:id="@+id/group_collection"
        android:checkableBehavior="single">
        <item
            android:id="@+id/nav_archive"
            android:icon="@drawable/ic_menu_lightbulb"
            android:title="@string/nav_menu_archive" />
        <item
            android:id="@+id/nav_trash"
            android:icon="@drawable/ic_menu_lightbulb"
            android:title="@string/nav_menu_trash" />
    </group>

    <group
        android:id="@+id/group_settings"
        android:checkableBehavior="single">
        <item
            android:id="@+id/nav_settings"
            android:icon="@drawable/ic_menu_lightbulb"
            android:title="@string/nav_menu_settings" />
        <item
            android:id="@+id/nav_help"
            android:icon="@drawable/ic_menu_lightbulb"
            android:title="@string/nav_menu_help_and_feedback" />
    </group>
</menu>
```
---
给`CardView`添加背景色要使用`app:cardBackgroundColor`，不然会导致`app:cardCornerRadius`不生效

---
从attr中提取资源id，可以使用`TypedValue`

```kotlin
val typedValue = TypedValue()
theme.resolveAttribute(android.R.attr.colorControlNormal, typedValue, true)
val resourceId = typedValue.resourceId
```

---
git本地local分支提交到远程新remote分支：

```
git push origin local:remote
```

---
跳微信扫一扫  

```kotlin
try {
    val intent = mActivity.packageManager.getLaunchIntentForPackage("com.tencent.mm")
    intent.putExtra("LauncherUI.From.Scaner.Shortcut", true)
    startActivity(intent)
} catch (e: Exception) {
    ToastUtils.showLongToast("无法跳转到微信，请检查您是否安装了微信！")
}
```

---
RadioGroup

RadioGroup里面RadioButton最好都设置id,不然给其中一个设置为默认选中后，其他的RadioButton不会互斥。

---
使用aar包不用flatDir，一句代码就好

```gradle
implementation fileTree(dir: 'libs', include: ['*.jar', '*.aar'])
```

---
自定义资源目录

```gradle
android {
    sourceSets {
        main {
            java.srcDirs += 'src/main/kotlin'
            res.srcDirs = [
                    'src/main/res',
                    'src/main/res_overlay'
            ]
        }
    }
}
```

---
修改gradle输出包的名字

```gradle
// -----------------------------------------------------------------------------------------
// build script
android {
    applicationVariants.all { variant ->
        variant.outputs.all { output ->
            def newName
            def timeNow
            if ("true" == IS_JENKINS) {
                // Jenkins编译
                newName = APP_NAME + '-' + variant.buildType.name + '-' + BUILD_TIME + '.apk'
                outputFileName = new File("../../../../..", newName)
            } else {
                // Android Studio编译
                timeNow = new Date().format("yyyyMMddHHmm")
                newName = APP_NAME + "-v" + variant.versionName + '-' + variant.buildType.name + '-' + timeNow + '.apk'
                outputFileName = newName
            }
        }
    }
}
// -----------------------------------------------------------------------------------------
```

---
scrollview始终显示scrollbar

```xml
android:scrollbars="vertical"
android:fadeScrollbars="false"
```

实践效果：当可以滑动的时候会显示scollbar，不能滑动的时候不会显示。

---

AlertDialog中`\n`不换行，调用`create().show()`就可以了。

---
基础库中UI的style最好不要加上accentColor属性，不然上层可能TextView等各种崩溃

---
zip/unzip

zip -q -r <zip_file_name> *

unzip <zip_file_name> -d <path>

---
集成数据魔盒SDK时遇到编译报错：
```
AGPBI: {"kind":"error","text":"Program type already present: com.tencent.smtt.export.external.DexLoader$TbsCorePrivateClassLoader","sources":[{}],"tool":"D8"}
```

因为数据魔盒SDK内置了腾讯X5，而项目中也集成了X5，产生了冲突，删掉一个就好了。

---

Mac调整Launcher一屏显示多少行、多少列，比如7行10列。  

```
defaults write com.apple.dock springboard-rows -int 7
defaults write com.apple.dock springboard-columns -int 10
defaults write com.apple.dock ResetLaunchPad -bool TRUE;killall Dock
```

---

`android.support.design.widget.BottomNavigationView`控件如果想禁止点击时的ripple效果，只需要设置`app:itemBackground`的值和`android:background`一样即可。

---

OkHttp下载文件：

```kotlin
@Suppress("DEPRECATION")
private var progressDialog: ProgressDialog? = null
private var apkFile: File? = null
private fun doDownloadApk(versionRes: VersionRes) {
    apkFile = File(getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS), "${BuildConfig.APPLICATION_ID}_${versionRes.version}.apk")
    // check file is exists or not
    if (apkFile?.exists() == true) {
        val deleted = apkFile?.delete()
        Logger.dTag(TAG_APP, "[SplashActivity] [doDownloadApk] apkFile exists, delete=$deleted")
    }

    // check download url is illegal
    val apkUrl = versionRes.channelUrl
    if (apkUrl.isNullOrEmpty()) {
        Logger.eTag(TAG_APP, "[SplashActivity] [doDownloadApk] apkUrl isNullOrEmpty >>>>>> ")
        viewModel.checkSwitchEnable()
        return
    }

    // show progress dialog
    @Suppress("DEPRECATION")
    progressDialog = ProgressDialog(this, R.style.HddAlertDialog).apply {
        setMessage(getString(R.string.download_apk_title))
        setProgressStyle(ProgressDialog.STYLE_HORIZONTAL)
        setCancelable(false)
        setCanceledOnTouchOutside(false)
        show()
    }

    // begin download
    Schedulers.newThread().createWorker().schedule {
        try {
            Logger.dTag(TAG_APP, "[SplashActivity] [doDownloadApk] download begin")
            val request = Request.Builder()
                .url(apkUrl)
                .build()
            val response = OkHttpClient.Builder().build().newCall(request).execute()

            // check response body
            val responseBody = response.body()
            if (responseBody == null) {
                viewModel.checkSwitchEnable()
                return@schedule
            }
            val inputStream = responseBody.byteStream()
            // get file size
            val contentLength = responseBody.contentLength()
            // set progress dialog max progress (shown in the bottom-right corner)
            // percent will be calculated by system
            progressDialog?.max = contentLength.toInt()
            Logger.dTag(TAG_APP, "[SplashActivity] [doDownloadApk] contentLength=$contentLength")

            // ready write files
            val fileOutputStream = FileOutputStream(apkFile)
            val bis = BufferedInputStream(inputStream)
            val buffer = ByteArray(1024)
            var length: Int
            var downloaded = 0

            // write files
            do {
                length = bis.read(buffer)
                if (length != -1) {
                    fileOutputStream.write(buffer, 0, length)
                    // update progress
                    downloaded += length
                    val percent = (downloaded * 100F / contentLength).toInt()
                    progressDialog?.progress = downloaded
                    Logger.dTag(TAG_APP, "[SplashActivity] [onProgress] progress = $percent")
                }
            } while (length != -1)
            fileOutputStream.flush()
            fileOutputStream.close()
            bis.close()
            inputStream.close()
            Logger.dTag(TAG_APP, "[SplashActivity] [doDownloadApk] download end")

            // write files done
            progressDialog?.dismiss()
            // install apk
            if (FileUtils.isFileExists(apkFile)) {
                @Suppress("DEPRECATION")
                AppUtils.installApp(this@SplashActivity, apkFile, Constants.FILE_PROVIDER, REQUEST_INSTALL_APP)
            }
        } catch (e: Exception) {
            e.printStackTrace()
            runOnUiThread {
                YLToastUtils.showToast(
                    getString(R.string.download_apk_error_try_again, e.message),
                    duration = Toast.LENGTH_LONG
                )
                viewModel.checkSwitchEnable()
            }
        }
    }
}
```