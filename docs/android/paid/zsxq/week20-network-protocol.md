---
title: "网络协议"
---

网络协议分层一图简介：

![OSI七层模型、TCP/IP四层模型、五层模型](/assets/images/android/网络协议分层.jpg)

5层模型只是OSI和TCP/IP的综合模型，是业界产生出来的非官方协议模型，但是很多具体的应用。OSI是理论模型，实际应用还是TCP/IP的四层结构。

OSI的七层模型首字母可以组成一个句子：All People Seem To Need Data Processing，与之对应的七层拼写为：Application、Presentation、Session、Transport、Network、Data Link、Physical。

## 1. 五层参考模型

网络分层从上到下分别是应用层、传输层、网络层、数据链路层和物理层。

1. 应用层  
**应用层为用户提供所需要的各种服务**，它的主要协议有HTTP、FTP、Telnet、SMTP、POP3等。

2. 传输层  
该层 **为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性** 。该层定义了两个主要的协议：传输控制协议（TCP）和用户数据报协议（UDP)。  
TCP协议提供的是一种可靠的、通过“三次握手”来连接的数据传输服务；而UDP协议提供的则是不保证可靠的（并不是不可靠）、无连接的数据传输服务。

3. 网络层  
该层 **主要解决主机到主机的通信问题** 。它所包含的协议涉及数据包在整个网络上的逻辑传输，注重重新赋予主机一个IP地址来完成对主机的寻址，它还负责数据包在多种网络中的路由。该层有三个主要协议：网际协议（IP）、互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）。  
IP协议是网际互联层最重要的协议，它提供的是一个可靠、无连接的数据报传递服务。

4. 数据链路层  
该层控制网络层与物理层之间的通信，其主要功能是 **如何在不可靠的物理线路上进行数据的可靠传递** 。为了保证传输，从网络层接收到的数据被分割成特定的可被物理层传输的帧。帧是用来移动数据的结构包，它不仅包括原始数据，还包括发送方和接收方的物理地址以及纠错和控制信息。其中的地址确定了帧将发送到何处，而纠错和控制信息则确保帧无差错到达。如果在传送数据时，接收点检测到所传数据中有差错，就要通知发送方重发这一帧。

5. 物理层  
该层负责比特流在节点间的传输，即 **负责物理传输** 。该层的协议既与链路有关，也与传输介质有关。 其通俗来讲就是把计算机连接起来的物理手段。

## 2. TCP与UDP

TCP/UDP都属于传输层的协议，其区别在于：

- TCP是 **面向连接** 的传输层协议，**提供可靠服务**（传送的数据无差错，不丢失，不重复，且按序到达），但在建立、断开连接需要经历三次握手、四次挥手；主要用在对可靠性要求较高的地方。

- UDP是 **无连接** 的传输层协议，尽最大努力交付，即 **不保证可靠交付** ；主要用于实时性要求较高的场合如事实视频会议等。

## 3. TCP的三次握手

![TCP流程](/assets/images/android/tcp-handshake.png)

几个名词

1. seq为Sequence Number
2. SYN为SYNchronize
3. ACK为ACKnowledge
4. FIN为FINish
5. MSL为the maximum segment lifetime

SYN、ACK大写时为标志位，值为0或1；小写时表示序号。

TCP三次握手（SYN，SYN-ACK，ACK）：

1. 客户端向服务器端发送报文，报文中设置标志位`SYN=1`，生成随机序列号`seq=x`，此时客户端进入 **SYN_SENT** 状态
2. 服务端收到客户端的报文，由`SYN=1`可以知道客户端请求建立连接。服务端给客户端发送报文，设置标志位`SYN=1`，`ACK=1`，生成随机序列号`seq=y`，设置确认号`ack=x+1`，此时服务器端进入 **SYN_RCVD** 状态
3. 客户端接收到服务器的报文，检查`ACK`是否为1，`ack`是否为`x+1`。如果正确置`ACK=1`，`seq=x+1`，`ack=y+1`，并将该数据包发送给服务器端，服务器端检查`ACK`是否为1，`ack`是否为`y+1`。如果正确则连接建立成功，服务器端和客户端进入 **ESTABLISHED** 状态，完成三次握手

???+ question "为什么需要三次握手，两次确认？"
    为什么客户端还要发送一次确认呢，主要是为了防止已失效的连接请求报文突然又传送到了服务器端，造成错误。比如：客户端发送连接请求，因为网络或者一些其他因素造成没有在一定时间到达服务器端，所以客户端没有收到确认。于是客户端会重发一次连接请求，通过三次握手与服务器建立连接，但是这时上次的请求到达服务器端了，服务器会误以为客户端又发来了一次新的连接请求，会向客户端发送报文同意建立连接，但是客户端已经建立了，就会放弃掉该报文，服务器端没有收到响应，也就不会建立连接了。

## 4. TCP的四次挥手

四次挥手（FIN，ACK，FIN，ACK）：

1. 客户端发送报文，标志位`FIN=1`，`seq=n`，此时客户端进入到 **FIN_WAIT_1**状态，表示客户端没有数据要发送给服务器
2. 服务端收到客户端发送的`FIN`报文，然后向客户端发送一个报文，设置标志位为`ACK=1`，确认序列号为`ack=n+1`，此时服务端进入 **CLOSE_WAIT** 状态.表示客户端到服务端的发送连接已经断开
3. 服务器发送报文到客户端，报文标志位`FIN=1`，`seq=m`，用来关闭服务器到客户端的数据传输，服务端进行 **LAST_ACK** 状态
4. 客户端收到服务器发送的标志位为`FIN`的报文，然后向服务器发送一个标志位为`ACK=1`的报文，确认序列号为`ack=m+1`，客户端进入到 **TIME_WAIT** 状态。等待`2MSL`（最大报文段生存时间）后依然没有收到回复，则说明服务端已正常关闭，这样客户端也可以关闭连接了

???+ question "为什么要等待2MSL"
    客户端发送的第4次握手报文，服务器没有收到。这时候服务器端会再次发送一个`FIN=1`的报文，而这个时候客户端还处于**CLIENT_WAIT**状态，所以可以再次发送确认消息。

## 5. HTTP各版本的区别

HTTP1.0和1.1的区别

- 长连接：HTTP1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接
- 节约带宽：HTTP1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器，客户端如果接受到401，客户端就可以不用发送body信息，节约了带宽
- HOST域：HTTP1.0是没有host域的，HTTP1.1才支持这个参数

Http1.1和2.0的区别

- 多路复用：HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级
- 数据压缩：HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快
- 服务器推送：当我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取，服务器端推送的这些资源其实存在客户端的某处地方，客户端直接从本地加载这些资源就可以了，不用走网络，速度自然是快很多的

## 6. HTTPS

HTTPS协议是由HTTP+SSL协议构建的可进行加密传输、身份认证的网络协议，主要用到对称加密、非对称加密、证书等技术进行加密，其默认端口为443。它是一个安全通信通道，它基于HTTP开发，用于在客户计算机和服务器之间交换信息，它使用安全套接字层(SSL，SSL使用40位关键字作为RC4流加密算法)进行信息交换，简单来说它是HTTP的安全版

> TLS (**T**ransport **L**ayer **S**ecurity)，传输层安全性协议  
> SSL (**S**ecure **S**ockets **L**ayer)，安全套接层

HTTP与HTTPS的区别如下：

| 区别 | HTTP | HTTPS |
| --- | ---- | ----- |
| URL地址 | URL以http://开头 | URL以https://开头 |
| 安全性 | 不安全的 | 安全的 |
| 默认端口 | 默认端口是80 | 默认端口是443 |
| 工作环境 | 工作于OSI模型中的应用层 | 工作于OSI模型中的传输层 |
| 数据加密 | 传输的数据无需加密 | 传输的数据进行加密 |
| 传输速度 | 传输速度快 | 传输速度慢 |
| 证书 | 访问无需证书 | 访问需要认证证书 |

## 7. SSL工作原理

![SSL握手原理](/assets/images/android/ssl_handshake_rsa.png)

详细介绍一下图中过程：

1. 客户端给出协议版本号、一个客户端随机数A（Client random）以及客户端支持的加密方式
2. 服务端确认双方使用的加密方式，并给出数字证书、一个服务器生成的随机数B（Server random）
3. 客户端确认数字证书有效，生成一个新的随机数C（Pre-master-secret），使用证书中的公钥对C加密，发送给服务端
4. 服务端使用自己的私钥解密出C
5. 客户端和服务器根据约定的加密方法，使用三个随机数ABC，生成对话秘钥，之后的通信都用这个对话秘钥进行加密

关于HTTPS更多理论基础，可以参考[HTTPS理论基础及其在Android中的最佳实践](https://blog.csdn.net/iispring/article/details/51615631)