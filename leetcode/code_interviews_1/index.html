<!doctype html><html lang=zh class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="An Android Developer."><meta name=author content="Yorek Liu"><link href=https://blog.yorek.xyz/leetcode/code_interviews_1/ rel=canonical><link rel=icon href=../../assets/images/favicon.webp><meta name=generator content="mkdocs-1.1.2, mkdocs-material-7.1.0"><title>数据结构、算法和数据操作 - Yorek's</title><link rel=stylesheet href=../../assets/stylesheets/main.33e2939f.min.css><link rel=stylesheet href=../../assets/stylesheets/palette.ef6f36e2.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Noto+Sans+SC:300,400,400i,700%7CJetBrains+Mono&display=fallback"><style>:root{--md-text-font-family:"Noto Sans SC";--md-code-font-family:"JetBrains Mono"}</style><link rel=manifest href=../../manifest.webmanifest crossorigin=use-credentials><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-155096376-1","auto"),ga("set","anonymizeIp",!0),ga("send","pageview"),document.addEventListener("DOMContentLoaded",function(){document.forms.search&&document.forms.search.query.addEventListener("blur",function(){var e;this.value&&(e=document.location.pathname,ga("send","pageview",e+"?q="+this.value))}),"undefined"!=typeof location$&&location$.subscribe(function(e){ga("send","pageview",e.pathname)})})</script><script async src=https://www.google-analytics.com/analytics.js></script></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=white data-md-color-accent=blue> <script>function __prefix(e){return new URL("../..",location).pathname+"."+e}function __get(e,t=localStorage){return JSON.parse(t.getItem(__prefix(e)))}</script> <script>var palette=__get("__palette");if(null!==palette&&"object"==typeof palette.color)for(var key in palette.color)document.body.setAttribute("data-md-color-"+key,palette.color[key])</script> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#1 class=md-skip> 跳转至 </a> </div> <div data-md-component=announce> </div> <header class=md-header data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=../.. title="Yorek's" class="md-header__button md-logo" aria-label="Yorek's" data-md-component=logo> <img src=../../assets/images/favicon.webp alt=logo> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> Yorek's </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> 数据结构、算法和数据操作 </span> </div> </div> </div> <form class=md-header__option data-md-component=palette> <input class=md-option data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme=default data-md-color-primary=white data-md-color-accent=blue type=radio name=__palette id=__palette_1> <label class="md-header__button md-icon" title="Switch to dark mode" for=__palette_2 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M7 10a2 2 0 0 1 2 2 2 2 0 0 1-2 2 2 2 0 0 1-2-2 2 2 0 0 1 2-2m10-3a5 5 0 0 1 5 5 5 5 0 0 1-5 5H7a5 5 0 0 1-5-5 5 5 0 0 1 5-5h10M7 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3h10a3 3 0 0 0 3-3 3 3 0 0 0-3-3H7z"/></svg> </label> <input class=md-option data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme=slate data-md-color-primary=red data-md-color-accent=deep-orange type=radio name=__palette id=__palette_2> <label class="md-header__button md-icon" title="Switch to light mode" for=__palette_1 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3z"/></svg> </label> </form> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=搜索 placeholder=搜索 autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query data-md-state=active required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg> </label> <button type=reset class="md-search__icon md-icon" aria-label=Clear tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg> </button> </form> <div class=md-search__output> <div class=md-search__scrollwrap data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> 正在初始化搜索引擎 </div> <ol class=md-search-result__list></ol> </div> </div> </div> </div> </div> </nav> </header> <div class=md-container data-md-component=container> <nav class=md-tabs aria-label=Tabs data-md-component=tabs> <div class="md-tabs__inner md-grid"> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../../android/3rd-library/3rd-library-source-code/ class=md-tabs__link> Android </a> </li> <li class=md-tabs__item> <a href=../../flutter/flutter_first_project_1/ class=md-tabs__link> Flutter </a> </li> <li class=md-tabs__item> <a href=../ class="md-tabs__link md-tabs__link--active"> LeetCode </a> </li> <li class=md-tabs__item> <a href=../../design-pattern/design-pattern/ class=md-tabs__link> Books </a> </li> </ul> </div> </nav> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../.. title="Yorek's" class="md-nav__button md-logo" aria-label="Yorek's" data-md-component=logo> <img src=../../assets/images/favicon.webp alt=logo> </a> Yorek's </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_1 type=checkbox id=__nav_1> <label class=md-nav__link for=__nav_1> Android <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Android data-md-level=1> <label class=md-nav__title for=__nav_1> <span class="md-nav__icon md-icon"></span> Android </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_1_1 type=checkbox id=__nav_1_1> <label class=md-nav__link for=__nav_1_1> 三方库系列 <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=三方库系列 data-md-level=2> <label class=md-nav__title for=__nav_1_1> <span class="md-nav__icon md-icon"></span> 三方库系列 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../android/3rd-library/3rd-library-source-code/ class=md-nav__link> Android三方库源码分析 </a> </li> <li class=md-nav__item> <a href=../../android/3rd-library/matrix/ class=md-nav__link> 微信APM Matrix解析 </a> </li> <li class=md-nav__item> <a href=../../android/3rd-library/matrix-trace/ class=md-nav__link> Matrix-TraceCanary解析 </a> </li> <li class=md-nav__item> <a href=../../android/3rd-library/matrix-io/ class=md-nav__link> Matrix-IOCanary解析 </a> </li> <li class=md-nav__item> <a href=../../android/3rd-library/matrix-resource/ class=md-nav__link> Matrix-ResourceCanary解析 </a> </li> <li class=md-nav__item> <a href=../../android/3rd-library/matrix-sqlitelint/ class=md-nav__link> Matrix-SQLiteLint解析 </a> </li> <li class=md-nav__item> <a href=../../android/3rd-library/okhttp/ class=md-nav__link> OkHttp3源码解析 </a> </li> <li class=md-nav__item> <a href=../../android/3rd-library/retrofit/ class=md-nav__link> Retrofit2源码解析 </a> </li> <li class=md-nav__item> <a href=../../android/3rd-library/rxjava%26rxandroid/ class=md-nav__link> RxJava源码解析及使用实例 </a> </li> <li class=md-nav__item> <a href=../../android/other/RxJava/ class=md-nav__link> RxJava操作符大全 </a> </li> <li class=md-nav__item> <a href=../../android/3rd-library/glide1/ class=md-nav__link> Glide v4 源码解析（一） </a> </li> <li class=md-nav__item> <a href=../../android/3rd-library/glide2/ class=md-nav__link> Glide v4 源码解析（二） </a> </li> <li class=md-nav__item> <a href=../../android/3rd-library/glide3/ class=md-nav__link> Glide v4 源码解析（三） </a> </li> <li class=md-nav__item> <a href=../../android/3rd-library/glide4/ class=md-nav__link> Glide v4 源码解析（四） </a> </li> <li class=md-nav__item> <a href=../../android/3rd-library/glide5/ class=md-nav__link> Glide v4 源码解析（五） </a> </li> <li class=md-nav__item> <a href=../../android/3rd-library/glide6/ class=md-nav__link> Glide v4 源码解析（六） </a> </li> <li class=md-nav__item> <a href=../../android/3rd-library/glide7/ class=md-nav__link> Glide v4 源码解析（七） </a> </li> <li class=md-nav__item> <a href=../../android/3rd-library/migrate-to-glide/ class=md-nav__link> 杂记：从Picasso迁移至Glide </a> </li> <li class=md-nav__item> <a href=../../android/3rd-library/eventbus/ class=md-nav__link> EventBus源码解析 </a> </li> <li class=md-nav__item> <a href=../../android/3rd-library/leakcanary/ class=md-nav__link> LeakCanary2源码解析 </a> </li> <li class=md-nav__item> <a href=../../android/3rd-library/permissiondispatcher/ class=md-nav__link> PermissionDispatcher源码解析 </a> </li> <li class=md-nav__item> <a href=../../android/other/constraintlayout/ class=md-nav__link> ConstraintLayout使用大全 </a> </li> <li class=md-nav__item> <a href=../../android/other/dagger2/ class=md-nav__link> 初学者的Dagger2教程 </a> </li> <li class=md-nav__item> <a href=../../android/3rd-library/hotfix/ class=md-nav__link> Hotfix方案初探 </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_1_2 type=checkbox id=__nav_1_2> <label class=md-nav__link for=__nav_1_2> framework系列 <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=framework系列 data-md-level=2> <label class=md-nav__title for=__nav_1_2> <span class="md-nav__icon md-icon"></span> framework系列 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../android/framework/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%281%29/ class=md-nav__link> Activity </a> </li> <li class=md-nav__item> <a href=../../android/framework/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%282%29/ class=md-nav__link> Service </a> </li> <li class=md-nav__item> <a href=../../android/framework/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%283%29/ class=md-nav__link> Broadcasts </a> </li> <li class=md-nav__item> <a href=../../android/framework/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%284%29/ class=md-nav__link> Content Providers与Fragment </a> </li> <li class=md-nav__item> <a href=../../android/framework/IPC%E6%9C%BA%E5%88%B6/ class=md-nav__link> IPC机制 </a> </li> <li class=md-nav__item> <a href=../../android/framework/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/ class=md-nav__link> View的事件体系 </a> </li> <li class=md-nav__item> <a href=../../android/framework/View%E7%9A%84%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86/ class=md-nav__link> View的绘制原理 </a> </li> <li class=md-nav__item> <a href=../../android/framework/RemoteViews/ class=md-nav__link> RemoteViews </a> </li> <li class=md-nav__item> <a href=../../android/framework/Drawable/ class=md-nav__link> Android中的Drawable资源 </a> </li> <li class=md-nav__item> <a href=../../android/framework/Android%E5%8A%A8%E7%94%BB/ class=md-nav__link> Android动画 </a> </li> <li class=md-nav__item> <a href=../../android/framework/Window%E4%B8%8EWindowManager/ class=md-nav__link> Window与WindowManager </a> </li> <li class=md-nav__item> <a href=../../android/framework/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/ class=md-nav__link> 四大组件启动过程 </a> </li> <li class=md-nav__item> <a href=../../android/framework/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/ class=md-nav__link> Android消息机制 </a> </li> <li class=md-nav__item> <a href=../../android/framework/Android%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0/ class=md-nav__link> Android线程与线程池 </a> </li> <li class=md-nav__item> <a href=../../android/framework/Bitmap%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%8A%A0%E8%BD%BD/ class=md-nav__link> Bitmap的缓存与加载 </a> </li> <li class=md-nav__item> <a href=../../android/framework/JNI%E4%B8%8ENDK/ class=md-nav__link> JNI与NDK编程简介 </a> </li> <li class=md-nav__item> <a href=../../android/framework/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/ class=md-nav__link> Android性能优化 </a> </li> <li class=md-nav__item> <a href=../../android/framework/binder1-mediaservice/ class=md-nav__link> Binder深入理解——以MediaService为例 </a> </li> <li class=md-nav__item> <a href=../../android/framework/binder2/ class=md-nav__link> Binder深入理解——罗老师系列 </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_1_3 type=checkbox id=__nav_1_3> <label class=md-nav__link for=__nav_1_3> 杂记 <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=杂记 data-md-level=2> <label class=md-nav__title for=__nav_1_3> <span class="md-nav__icon md-icon"></span> 杂记 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../android/other/commands/ class=md-nav__link> Android开发常见命令 </a> </li> <li class=md-nav__item> <a href=../../android/other/android-tv/ class=md-nav__link> Android TV 专项 </a> </li> <li class=md-nav__item> <a href=../../android/other/annotation/ class=md-nav__link> 注解的定义及解析 </a> </li> <li class=md-nav__item> <a href=../../android/other/best_throttle_in_mvvm/ class=md-nav__link> 这可能是MVVM中最优雅的按键防抖方案 </a> </li> <li class=md-nav__item> <a href=../../android/other/android-jenkins/ class=md-nav__link> Jenkins for android </a> </li> <li class=md-nav__item> <a href=../../android/other/SystemProrities/ class=md-nav__link> 普通Android程序使用SystemProrities </a> </li> <li class=md-nav__item> <a href=../../android/other/recyclerview-cache/ class=md-nav__link> ListView、RecyclerView缓存策略解析 </a> </li> <li class=md-nav__item> <a href=../../android/other/recyclerview-item-docoration/ class=md-nav__link> RecyclerView高级特性——ItemDecoration </a> </li> <li class=md-nav__item> <a href=../../android/other/recyclerview-others/ class=md-nav__link> RecyclerView的一些使用细节 </a> </li> <li class=md-nav__item> <a href=../../android/other/RecyclerView-Sort%26Delete/ class=md-nav__link> RecyclerView高级特性——拖拽排序以及滑动删除 </a> </li> <li class=md-nav__item> <a href=../../android/other/FAB-Behavior/ class=md-nav__link> FloatingActionButton上滑隐藏下滑显示 </a> </li> <li class=md-nav__item> <a href=../../android/other/nestedscrolling/ class=md-nav__link> NestedScrolling机制 </a> </li> <li class=md-nav__item> <a href=../../android/other/porterduff/ class=md-nav__link> 使用Porter-Duff合成数字图像 </a> </li> <li class=md-nav__item> <a href=../../android/other/runtime/ class=md-nav__link> Android Runtime </a> </li> <li class=md-nav__item> <a href=../../android/other/android_alias/ class=md-nav__link> Android马甲包的那些事儿 </a> </li> <li class=md-nav__item> <a href=../../android/other/Android-Development-Tool/ class=md-nav__link> Android神兵利器 </a> </li> <li class=md-nav__item> <a href=../../android/other/FileProvider/ class=md-nav__link> FileProvider </a> </li> <li class=md-nav__item> <a href=../../android/other/Android%E5%88%A4%E6%96%AD%E5%AF%BC%E8%88%AA%E6%A0%8F%E9%AB%98%E5%BA%A6/ class=md-nav__link> Android判断虚拟按键(导航栏)显示与否、高度以及获取屏幕实际高度 </a> </li> <li class=md-nav__item> <a href=../../android/other/Android%E5%9B%BE%E7%89%87%E9%80%89%E6%8B%A9%E5%99%A8/ class=md-nav__link> Android图片选择器 </a> </li> <li class=md-nav__item> <a href=../../android/other/Android%E5%BA%95%E9%83%A8%E5%AF%BC%E8%88%AA%E6%A0%8F%E6%A1%86%E6%9E%B6/ class=md-nav__link> Android原生底部导航栏 </a> </li> <li class=md-nav__item> <a href=../../android/other/Android%E6%90%9C%E7%B4%A2%E6%A0%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/ class=md-nav__link> Android搜索栏的实现 </a> </li> <li class=md-nav__item> <a href=../../android/other/Android%E6%9A%82%E5%81%9C%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%E7%9A%84%E6%92%AD%E6%94%BE/ class=md-nav__link> Android暂停酷狗、网易云音乐等音乐播放器的播放 </a> </li> <li class=md-nav__item> <a href=../../android/other/Android%E6%BB%91%E5%8A%A8%E8%BF%94%E5%9B%9E%E5%AE%9E%E8%B7%B5/ class=md-nav__link> Android滑动返回实践 </a> </li> <li class=md-nav__item> <a href=../../android/other/Android%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91/ class=md-nav__link> MacOS下Android程序反编译 </a> </li> <li class=md-nav__item> <a href=../../android/other/Android%E9%80%9A%E8%AE%AF%E5%BD%95%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%8F%96/ class=md-nav__link> Android通讯录快速读取 </a> </li> <li class=md-nav__item> <a href=../../android/other/soft-keyboard-in-app/ class=md-nav__link> App内自定义软键盘 </a> </li> <li class=md-nav__item> <a href=../../android/other/%E8%85%BE%E8%AE%AFX5%E5%86%85%E6%A0%B8%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97/ class=md-nav__link> 腾讯TBS X5浏览器内核入坑指南 </a> </li> <li class=md-nav__item> <a href=../../android/other/%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/ class=md-nav__link> 琐碎知识点 </a> </li> <li class=md-nav__item> <a href=../../android/paid/zsxq/week1-synchronized/ class=md-nav__link> 理解Java中synchronized关键词 </a> </li> <li class=md-nav__item> <a href=../../android/paid/zsxq/week2-service/ class=md-nav__link> 理解Service </a> </li> <li class=md-nav__item> <a href=../../android/paid/zsxq/week3-activity/ class=md-nav__link> 理解Activity的启动模式 </a> </li> <li class=md-nav__item> <a href=../../android/paid/zsxq/week4-startActivityForResult/ class=md-nav__link> 关于startActivityForResult </a> </li> <li class=md-nav__item> <a href=../../android/paid/zsxq/week5-view/ class=md-nav__link> 关于View的知识 </a> </li> <li class=md-nav__item> <a href=../../android/paid/zsxq/week6-gradle/ class=md-nav__link> 关于Gradle的知识 </a> </li> <li class=md-nav__item> <a href=../../android/paid/zsxq/week7-serialization/ class=md-nav__link> 关于序列化的知识 </a> </li> <li class=md-nav__item> <a href=../../android/paid/zsxq/week10-classloader/ class=md-nav__link> Android中的ClassLoader </a> </li> <li class=md-nav__item> <a href=../../android/paid/zsxq/week11-binder/ class=md-nav__link> Binder简介 </a> </li> <li class=md-nav__item> <a href=../../android/paid/zsxq/week12-retrofit-okhttp/ class=md-nav__link> OkHttp和Retrofit的作用以及两者之间的联系 </a> </li> <li class=md-nav__item> <a href=../../android/paid/zsxq/week14-jvm-gc/ class=md-nav__link> JVM中垃圾回收策略 </a> </li> <li class=md-nav__item> <a href=../../android/paid/zsxq/week16-keep-app-alive/ class=md-nav__link> 进程保活 </a> </li> <li class=md-nav__item> <a href=../../android/paid/zsxq/week17-android-components/ class=md-nav__link> 四大组件的作用以及多进程 </a> </li> <li class=md-nav__item> <a href=../../android/paid/zsxq/week20-network-protocol/ class=md-nav__link> 网络协议 </a> </li> <li class=md-nav__item> <a href=../../android/paid/zsxq/week21-mvc%26mvp%26mvvm/ class=md-nav__link> MVC、MVP和MVVM </a> </li> <li class=md-nav__item> <a href=../../android/paid/zsxq/week22-android-studio-build/ class=md-nav__link> Android Studio build过程 </a> </li> <li class=md-nav__item> <a href=../../android/paid/zsxq/week23-load-large-bitmap/ class=md-nav__link> 大尺寸图片加载问题 </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_1_4 type=checkbox id=__nav_1_4> <label class=md-nav__link for=__nav_1_4> Android开发高手课 <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Android开发高手课 data-md-level=2> <label class=md-nav__title for=__nav_1_4> <span class="md-nav__icon md-icon"></span> Android开发高手课 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../android/paid/master/ class=md-nav__link> Android开发高手课 </a> </li> <li class=md-nav__item> <a href=../../android/paid/master/crash_1/ class=md-nav__link> 01 | 崩溃优化（上）：关于“崩溃”那些事儿 </a> </li> <li class=md-nav__item> <a href=../../android/paid/master/crash_2/ class=md-nav__link> 02 | 崩溃优化（下）：应用崩溃了，你应该如何去分析？ </a> </li> <li class=md-nav__item> <a href=../../android/paid/master/memory_1/ class=md-nav__link> 03 | 内存优化（上）：4GB内存时代，再谈内存优化 </a> </li> <li class=md-nav__item> <a href=../../android/paid/master/memory_2/ class=md-nav__link> 04 | 内存优化（下）：内存优化这件事，应该从哪里着手？ </a> </li> <li class=md-nav__item> <a href=../../android/paid/master/stuck_1/ class=md-nav__link> 05 | 卡顿优化（上）：你要掌握的卡顿分析方法 </a> </li> <li class=md-nav__item> <a href=../../android/paid/master/stuck_2/ class=md-nav__link> 06 | 卡顿优化（下）：如何监控应用卡顿？ </a> </li> <li class=md-nav__item> <a href=../../android/paid/master/stuck_3/ class=md-nav__link> 06补充篇 | 卡顿优化：卡顿现场与卡顿分析 </a> </li> <li class=md-nav__item> <a href=../../android/paid/master/start_1/ class=md-nav__link> 07 | 启动优化（上）：从启动过程看启动速度优化 </a> </li> <li class=md-nav__item> <a href=../../android/paid/master/start_2/ class=md-nav__link> 08 | 启动优化（下）：优化启动速度的进阶方法 </a> </li> <li class=md-nav__item> <a href=../../android/paid/master/io_1/ class=md-nav__link> 09 | I/O优化（上）：开发工程师必备的I/O优化知识 </a> </li> <li class=md-nav__item> <a href=../../android/paid/master/io_2/ class=md-nav__link> 10 | I/O优化（中）：不同I/O方式的使用场景是什么？ </a> </li> <li class=md-nav__item> <a href=../../android/paid/master/io_3/ class=md-nav__link> 11 | I/O优化（下）：如何监控线上I/O操作？ </a> </li> <li class=md-nav__item> <a href=../../android/paid/master/storage_1/ class=md-nav__link> 12 | 存储优化（上）：常见的数据存储方法有哪些？ </a> </li> <li class=md-nav__item> <a href=../../android/paid/master/storage_2/ class=md-nav__link> 13 | 存储优化（中）：如何优化数据存储？ </a> </li> <li class=md-nav__item> <a href=../../android/paid/master/storage_3/ class=md-nav__link> 14 | 存储优化（下）：数据库SQLite的使用和优化 </a> </li> <li class=md-nav__item> <a href=../../android/paid/master/network_1/ class=md-nav__link> 15 | 网络优化（上）：移动开发工程师必备的网络优化知识 </a> </li> <li class=md-nav__item> <a href=../../android/paid/master/network_2/ class=md-nav__link> 16 | 网络优化（中）：复杂多变的移动网络该如何优化？ </a> </li> <li class=md-nav__item> <a href=../../android/paid/master/network_3/ class=md-nav__link> 17 | 网络优化（下）：大数据下网络该如何监控？ </a> </li> <li class=md-nav__item> <a href=../../android/paid/master/battery_1/ class=md-nav__link> 18 | 耗电优化（上）：从电量优化的演进看耗电分析 </a> </li> <li class=md-nav__item> <a href=../../android/paid/master/battery_2/ class=md-nav__link> 19 | 耗电优化（下）：耗电的优化方法与线上监控 </a> </li> <li class=md-nav__item> <a href=../../android/paid/master/ui_1/ class=md-nav__link> 20 | UI 优化（上）：UI 渲染的几个关键概念 </a> </li> <li class=md-nav__item> <a href=../../android/paid/master/ui_2/ class=md-nav__link> 21 | UI 优化（下）：如何优化 UI 渲染？ </a> </li> <li class=md-nav__item> <a href=../../android/paid/master/package_1/ class=md-nav__link> 22 | 包体积优化（上）：如何减少安装包大小？ </a> </li> <li class=md-nav__item> <a href=../../android/paid/master/package_2/ class=md-nav__link> 23 | 包体积优化（下）：资源优化的进阶实践 </a> </li> <li class=md-nav__item> <a href=../../android/paid/master/compile/ class=md-nav__link> 26 | 关于编译，你需要了解什么？ </a> </li> <li class=md-nav__item> <a href=../../android/paid/master/bytecode/ class=md-nav__link> 27 | 编译插桩的三种方法：AspectJ、ASM、ReDex </a> </li> <li class=md-nav__item> <a href=../../android/paid/master/native_hook/ class=md-nav__link> 35 | Native Hook 技术，天使还是魔鬼？ </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_2 type=checkbox id=__nav_2> <label class=md-nav__link for=__nav_2> Flutter <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Flutter data-md-level=1> <label class=md-nav__title for=__nav_2> <span class="md-nav__icon md-icon"></span> Flutter </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../flutter/flutter_first_project_1/ class=md-nav__link> 年轻人的第一个Flutter程序(1) </a> </li> <li class=md-nav__item> <a href=../../flutter/flutter_first_project_2/ class=md-nav__link> 年轻人的第一个Flutter程序(2) </a> </li> <li class=md-nav__item> <a href=../../flutter/flutter_first_project_3/ class=md-nav__link> 年轻人的第一个Flutter程序(3) </a> </li> <li class=md-nav__item> <a href=../../flutter/flutter_first_project_4/ class=md-nav__link> 年轻人的第一个Flutter程序(4) </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_3 type=checkbox id=__nav_3 checked> <label class=md-nav__link for=__nav_3> LeetCode <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=LeetCode data-md-level=1> <label class=md-nav__title for=__nav_3> <span class="md-nav__icon md-icon"></span> LeetCode </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../ class=md-nav__link> 算法目录 </a> </li> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" data-md-toggle=toc type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> 数据结构、算法和数据操作 <span class="md-nav__icon md-icon"></span> </label> <a href=./ class="md-nav__link md-nav__link--active"> 数据结构、算法和数据操作 </a> <nav class="md-nav md-nav--secondary" aria-label=目录> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> 目录 </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#1 class=md-nav__link> 1. 数组 </a> <nav class=md-nav aria-label="1. 数组"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#11-3 class=md-nav__link> 1.1 (3)数组中重复的数字 </a> <nav class=md-nav aria-label="1.1 (3)数组中重复的数字"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#111 class=md-nav__link> 1.1.1 找出数组中重复的数字 </a> </li> <li class=md-nav__item> <a href=#112 class=md-nav__link> 1.1.2 不修改数组找出重复的数字 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#12-4 class=md-nav__link> 1.2 (4)二维数组中的查找 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#2 class=md-nav__link> 2. 字符串 </a> <nav class=md-nav aria-label="2. 字符串"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#21-5 class=md-nav__link> 2.1 (5)替换空格 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#3 class=md-nav__link> 3. 链表 </a> <nav class=md-nav aria-label="3. 链表"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#31-6 class=md-nav__link> 3.1 (6)从尾到头打印链表 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#4 class=md-nav__link> 4. 树 </a> <nav class=md-nav aria-label="4. 树"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_1 class=md-nav__link> 树的遍历算法 </a> </li> <li class=md-nav__item> <a href=#_2 class=md-nav__link> 树的其他概念 </a> </li> <li class=md-nav__item> <a href=#41-7 class=md-nav__link> 4.1 (7)重建二叉树 </a> </li> <li class=md-nav__item> <a href=#42-8 class=md-nav__link> 4.2 (8)二叉树的下一个节点 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#5 class=md-nav__link> 5. 栈和队列 </a> <nav class=md-nav aria-label="5. 栈和队列"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#51-9 class=md-nav__link> 5.1 (9)用两个栈实现队列 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#6 class=md-nav__link> 6. 算法和数据操作 </a> <nav class=md-nav aria-label="6. 算法和数据操作"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#61 class=md-nav__link> 6.1 递归和循环 </a> <nav class=md-nav aria-label="6.1 递归和循环"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#611-10 class=md-nav__link> 6.1.1 (10)斐波那契数列 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#62 class=md-nav__link> 6.2 查找和排序 </a> <nav class=md-nav aria-label="6.2 查找和排序"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#621-11 class=md-nav__link> 6.2.1 (11)旋转数组的最小数字 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#63 class=md-nav__link> 6.3 回溯法 </a> <nav class=md-nav aria-label="6.3 回溯法"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#631-12 class=md-nav__link> 6.3.1 (12)矩阵中的路径 </a> </li> <li class=md-nav__item> <a href=#632-13 class=md-nav__link> 6.3.2 (13)机器人的运动范围 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#64 class=md-nav__link> 6.4 动态规划与贪婪算法 </a> <nav class=md-nav aria-label="6.4 动态规划与贪婪算法"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#641-14 class=md-nav__link> 6.4.1 (14)剪绳子 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#65 class=md-nav__link> 6.5 位运算 </a> </li> <li class=md-nav__item> <a href=#651-151 class=md-nav__link> 6.5.1 (15)二进制中1的个数 </a> </li> <li class=md-nav__item> <a href=#7 class=md-nav__link> 7. 总结 </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../code_interviews_3/ class=md-nav__link> 高质量的代码 </a> </li> <li class=md-nav__item> <a href=../code_interviews_4/ class=md-nav__link> 解决问题的思路 </a> </li> <li class=md-nav__item> <a href=../code_interviews_5/ class=md-nav__link> 优化时间和空间效率 </a> </li> <li class=md-nav__item> <a href=../code_interviews_6/ class=md-nav__link> 面试中的各项能力 </a> </li> <li class=md-nav__item> <a href=../array/ class=md-nav__link> Array </a> </li> <li class=md-nav__item> <a href=../leetcode1-10/ class=md-nav__link> LeetCode(1-10) </a> </li> <li class=md-nav__item> <a href=../leetcode11-20/ class=md-nav__link> LeetCode(11-20) </a> </li> <li class=md-nav__item> <a href=../leetcode21-30/ class=md-nav__link> LeetCode(21-30) </a> </li> <li class=md-nav__item> <a href=../leetcode31-40/ class=md-nav__link> LeetCode(31-40) </a> </li> <li class=md-nav__item> <a href=../leetcode41-50/ class=md-nav__link> LeetCode(41-50) </a> </li> <li class=md-nav__item> <a href=../leetcode51-60/ class=md-nav__link> LeetCode(51-60) </a> </li> <li class=md-nav__item> <a href=../leetcode61-70/ class=md-nav__link> LeetCode(61-70) </a> </li> <li class=md-nav__item> <a href=../leetcode71-80/ class=md-nav__link> LeetCode(71-80) </a> </li> <li class=md-nav__item> <a href=../leetcode81-90/ class=md-nav__link> LeetCode(81-90) </a> </li> <li class=md-nav__item> <a href=../leetcode91-100/ class=md-nav__link> LeetCode(91-100) </a> </li> <li class=md-nav__item> <a href=../leetcode101-110/ class=md-nav__link> LeetCode(101-110) </a> </li> <li class=md-nav__item> <a href=../leetcode111-120/ class=md-nav__link> LeetCode(111-120) </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_4 type=checkbox id=__nav_4> <label class=md-nav__link for=__nav_4> Books <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Books data-md-level=1> <label class=md-nav__title for=__nav_4> <span class="md-nav__icon md-icon"></span> Books </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_4_1 type=checkbox id=__nav_4_1> <label class=md-nav__link for=__nav_4_1> Design Pattern <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label="Design Pattern" data-md-level=2> <label class=md-nav__title for=__nav_4_1> <span class="md-nav__icon md-icon"></span> Design Pattern </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../design-pattern/design-pattern/ class=md-nav__link> 设计模式概述 </a> </li> <li class=md-nav__item> <a href=../../design-pattern/design-principle/ class=md-nav__link> 面向对象的六大原则 </a> </li> <li class=md-nav__item> <a href=../../design-pattern/singleton/ class=md-nav__link> 单例模式(Singleton) </a> </li> <li class=md-nav__item> <a href=../../design-pattern/builder/ class=md-nav__link> 建造者模式(Builder) </a> </li> <li class=md-nav__item> <a href=../../design-pattern/prototype/ class=md-nav__link> 原型模式(Prototype) </a> </li> <li class=md-nav__item> <a href=../../design-pattern/factory-method/ class=md-nav__link> 工厂方法模式(Factory method) </a> </li> <li class=md-nav__item> <a href=../../design-pattern/abstract-factory/ class=md-nav__link> 抽象工厂模式(Abstract factory) </a> </li> <li class=md-nav__item> <a href=../../design-pattern/proxy/ class=md-nav__link> 代理模式(Proxy) </a> </li> <li class=md-nav__item> <a href=../../design-pattern/composite/ class=md-nav__link> 组合模式(Composite) </a> </li> <li class=md-nav__item> <a href=../../design-pattern/adapter/ class=md-nav__link> 适配器模式(Adapter) </a> </li> <li class=md-nav__item> <a href=../../design-pattern/decorator/ class=md-nav__link> 装饰模式(Decorator) </a> </li> <li class=md-nav__item> <a href=../../design-pattern/flyweight/ class=md-nav__link> 享元模式(Flyweight) </a> </li> <li class=md-nav__item> <a href=../../design-pattern/facade/ class=md-nav__link> 外观模式(Facade) </a> </li> <li class=md-nav__item> <a href=../../design-pattern/bridge/ class=md-nav__link> 桥接模式(Bridge) </a> </li> <li class=md-nav__item> <a href=../../design-pattern/strategy/ class=md-nav__link> 策略模式(Strategy) </a> </li> <li class=md-nav__item> <a href=../../design-pattern/state/ class=md-nav__link> 状态模式(State) </a> </li> <li class=md-nav__item> <a href=../../design-pattern/chain-of-responsibility/ class=md-nav__link> 责任链模式(Chain of responsibility) </a> </li> <li class=md-nav__item> <a href=../../design-pattern/interpreter/ class=md-nav__link> 解释器模式(Interpreter) </a> </li> <li class=md-nav__item> <a href=../../design-pattern/command/ class=md-nav__link> 命令模式(Command) </a> </li> <li class=md-nav__item> <a href=../../design-pattern/observer/ class=md-nav__link> 观察者模式(Observer) </a> </li> <li class=md-nav__item> <a href=../../design-pattern/memento/ class=md-nav__link> 备忘录模式(Memento) </a> </li> <li class=md-nav__item> <a href=../../design-pattern/iterator/ class=md-nav__link> 迭代器模式(Iterator) </a> </li> <li class=md-nav__item> <a href=../../design-pattern/template-method/ class=md-nav__link> 模版方法模式(Template method) </a> </li> <li class=md-nav__item> <a href=../../design-pattern/visitor/ class=md-nav__link> 访问者模式(Visitor) </a> </li> <li class=md-nav__item> <a href=../../design-pattern/mediator/ class=md-nav__link> 中介者模式(Mediator) </a> </li> <li class=md-nav__item> <a href=../../design-pattern/confusing-design-pattern/ class=md-nav__link> 易混淆的设计模式 </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_4_2 type=checkbox id=__nav_4_2> <label class=md-nav__link for=__nav_4_2> Effective Java <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label="Effective Java" data-md-level=2> <label class=md-nav__title for=__nav_4_2> <span class="md-nav__icon md-icon"></span> Effective Java </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../effective-java/effective-java/ class=md-nav__link> Effective Java概述 </a> </li> <li class=md-nav__item> <a href=../../effective-java/chapter1/ class=md-nav__link> 创建和销毁对象 </a> </li> <li class=md-nav__item> <a href=../../effective-java/chapter2/ class=md-nav__link> 对于所有对象都通用的方法 </a> </li> <li class=md-nav__item> <a href=../../effective-java/chapter3/ class=md-nav__link> 类和接口 </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_4_3 type=checkbox id=__nav_4_3> <label class=md-nav__link for=__nav_4_3> JVM <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=JVM data-md-level=2> <label class=md-nav__title for=__nav_4_3> <span class="md-nav__icon md-icon"></span> JVM </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../jvm/jvm-content/ class=md-nav__link> 深入理解Java虚拟机 </a> </li> <li class=md-nav__item> <a href=../../jvm/java-memory-area-oom/ class=md-nav__link> Java内存区域与内存溢出异常 </a> </li> <li class=md-nav__item> <a href=../../jvm/java-gc/ class=md-nav__link> 垃圾收集器与内存分配策略 </a> </li> <li class=md-nav__item> <a href=../../jvm/class-struct/ class=md-nav__link> 类文件结构 </a> </li> <li class=md-nav__item> <a href=../../jvm/load-class/ class=md-nav__link> 虚拟机类加载机制 </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_4_4 type=checkbox id=__nav_4_4> <label class=md-nav__link for=__nav_4_4> Java <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Java data-md-level=2> <label class=md-nav__title for=__nav_4_4> <span class="md-nav__icon md-icon"></span> Java </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../java/generics-java-kotlin/ class=md-nav__link> Java&Kotlin在泛型方面的区别 </a> </li> <li class=md-nav__item> <a href=../../java/java-collections/ class=md-nav__link> Java集合总结 </a> </li> <li class=md-nav__item> <a href=../../java/java-foundation/ class=md-nav__link> Java常见概念 </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_4_5 type=checkbox id=__nav_4_5> <label class=md-nav__link for=__nav_4_5> Refactoring <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Refactoring data-md-level=2> <label class=md-nav__title for=__nav_4_5> <span class="md-nav__icon md-icon"></span> Refactoring </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../refactoring/refactoring/ class=md-nav__link> 重构：改善既有代码的设计 </a> </li> </ul> </nav> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label=目录> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> 目录 </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#1 class=md-nav__link> 1. 数组 </a> <nav class=md-nav aria-label="1. 数组"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#11-3 class=md-nav__link> 1.1 (3)数组中重复的数字 </a> <nav class=md-nav aria-label="1.1 (3)数组中重复的数字"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#111 class=md-nav__link> 1.1.1 找出数组中重复的数字 </a> </li> <li class=md-nav__item> <a href=#112 class=md-nav__link> 1.1.2 不修改数组找出重复的数字 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#12-4 class=md-nav__link> 1.2 (4)二维数组中的查找 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#2 class=md-nav__link> 2. 字符串 </a> <nav class=md-nav aria-label="2. 字符串"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#21-5 class=md-nav__link> 2.1 (5)替换空格 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#3 class=md-nav__link> 3. 链表 </a> <nav class=md-nav aria-label="3. 链表"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#31-6 class=md-nav__link> 3.1 (6)从尾到头打印链表 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#4 class=md-nav__link> 4. 树 </a> <nav class=md-nav aria-label="4. 树"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_1 class=md-nav__link> 树的遍历算法 </a> </li> <li class=md-nav__item> <a href=#_2 class=md-nav__link> 树的其他概念 </a> </li> <li class=md-nav__item> <a href=#41-7 class=md-nav__link> 4.1 (7)重建二叉树 </a> </li> <li class=md-nav__item> <a href=#42-8 class=md-nav__link> 4.2 (8)二叉树的下一个节点 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#5 class=md-nav__link> 5. 栈和队列 </a> <nav class=md-nav aria-label="5. 栈和队列"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#51-9 class=md-nav__link> 5.1 (9)用两个栈实现队列 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#6 class=md-nav__link> 6. 算法和数据操作 </a> <nav class=md-nav aria-label="6. 算法和数据操作"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#61 class=md-nav__link> 6.1 递归和循环 </a> <nav class=md-nav aria-label="6.1 递归和循环"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#611-10 class=md-nav__link> 6.1.1 (10)斐波那契数列 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#62 class=md-nav__link> 6.2 查找和排序 </a> <nav class=md-nav aria-label="6.2 查找和排序"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#621-11 class=md-nav__link> 6.2.1 (11)旋转数组的最小数字 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#63 class=md-nav__link> 6.3 回溯法 </a> <nav class=md-nav aria-label="6.3 回溯法"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#631-12 class=md-nav__link> 6.3.1 (12)矩阵中的路径 </a> </li> <li class=md-nav__item> <a href=#632-13 class=md-nav__link> 6.3.2 (13)机器人的运动范围 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#64 class=md-nav__link> 6.4 动态规划与贪婪算法 </a> <nav class=md-nav aria-label="6.4 动态规划与贪婪算法"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#641-14 class=md-nav__link> 6.4.1 (14)剪绳子 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#65 class=md-nav__link> 6.5 位运算 </a> </li> <li class=md-nav__item> <a href=#651-151 class=md-nav__link> 6.5.1 (15)二进制中1的个数 </a> </li> <li class=md-nav__item> <a href=#7 class=md-nav__link> 7. 总结 </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <h1>数据结构、算法和数据操作</h1> <h2 id=1>1. 数组<a class=headerlink href=#1 title="Permanent link">&para;</a></h2> <h3 id=11-3>1.1 (3)数组中重复的数字<a class=headerlink href=#11-3 title="Permanent link">&para;</a></h3> <h4 id=111>1.1.1 找出数组中重复的数字<a class=headerlink href=#111 title="Permanent link">&para;</a></h4> <blockquote> <p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2, 3, 1, 0, 2, 5, 3}，那么对应的输出是重复的数字2或者3。</p> </blockquote> <p><strong>解法一：先排序，后遍历</strong></p> <p>排序后找到重复的数字是非常容易的事情，只需要从头到尾扫描排序后的数组就可以了。<br> 排序一个长度为n的数组需要O(nlogn)的时间</p> <p><strong>解法二：哈希表</strong></p> <p>从头到尾扫描，每扫到一个数字，可以用O(1)的时间判断哈希表中是否已经包含了该数字。如果没有包含，就把它加入哈希表。否则，就找到了重复数字。<br> 其时间复杂度为O(n)，空间复杂度也为O(n)</p> <p><strong>解法三：利用数组的特点</strong></p> <p>我们注意到数组中的数字都在0~n-1的范围内。如果数组中没有重复元素，那么数组排序后数字i将会出现在下标为i的位置。如果有重复的元素，那么有些位置可能存在多个数字，同时有些位置可能没有数字。</p> <p>我们从头到尾遍历数组。当扫描到下标为i的数字时，首先比较这个数字(m)是不是i。如果是，则接着扫描下一个数字；如果不是，拿它和第m个数字进行比较。如果它和第m个数字相等，就找到了一个重复的数字(该数字在下标i和m的位置都出现了)。如果它和第m个数字不相等，就把第i个数字和第m个数字交换，把m放到属于它的位置。接下来再重复这个比较、交换的过程。 </p> <div class=highlight><pre><span></span><code><span class=kd>private</span> <span class=kt>int</span> <span class=nf>duplicate</span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>numbers</span><span class=p>,</span> <span class=kt>int</span> <span class=n>length</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>numbers</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>length</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>length</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>numbers</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>numbers</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>&gt;=</span> <span class=n>length</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>length</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>while</span> <span class=p>(</span><span class=n>numbers</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>!=</span> <span class=n>i</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>numbers</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>==</span> <span class=n>numbers</span><span class=o>[</span><span class=n>numbers</span><span class=o>[</span><span class=n>i</span><span class=o>]]</span><span class=p>)</span> <span class=p>{</span>
                <span class=k>return</span> <span class=n>numbers</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>;</span>
            <span class=p>}</span>

            <span class=c1>// swap</span>
            <span class=kt>int</span> <span class=n>t</span> <span class=o>=</span> <span class=n>numbers</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>;</span>
            <span class=n>numbers</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=n>numbers</span><span class=o>[</span><span class=n>t</span><span class=o>]</span><span class=p>;</span>
            <span class=n>numbers</span><span class=o>[</span><span class=n>t</span><span class=o>]</span> <span class=o>=</span> <span class=n>t</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>此题思想和<a href=/leetcode/leetcode41-50/#41-first-missing-positive>LC—41—First Missing Positive</a>思想类似。</p> <h4 id=112>1.1.2 不修改数组找出重复的数字<a class=headerlink href=#112 title="Permanent link">&para;</a></h4> <blockquote> <p>在一个长度为n+1的数组里的所有数字都在1到n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为8的数组{2, 3, 5, 4, 3, 2, 6, 7}，那么对应的输出是重复的数字2或者3。</p> </blockquote> <p><strong>解法一：复制数组时排序</strong><br> 我们可以创建一个长度为n+1的辅助数组，然后逐一辅助原数组中的每个数字。在复制时，如果原数组中被复制的数字是m，则把它复制到辅助数组中下标为m的位置。这样就容易发现哪个数字是重复的。<br> 该方法时间复杂度为O(1)，空间复杂度为O(n)。</p> <p><strong>解法二：利用题设</strong> </p> <blockquote> <p>在一个长度为n+1的数组里的所有数字都在1到n的范围内，所以数组中至少有一个数字是重复的。 </p> </blockquote> <p>由于所有的数字都在1~n的范围内，所以我们可以利用二分查找，在查找时统计一下某个区间里数字的数目。<br> 我们把1~n的数字从中间的数字m分为两部分，前面一半为1~m，后面一半为m+1~n。如果1~m的数字出现的次数超过m，那么这一半的区间里一定包含重复的数字；否则另一半区间里一定包含重复的数字。我们可以继续把包含重复数字的区间一分为二，直到找到一个重复的数字。 </p> <p>该方法由于二分查找的特点，<code>countRange</code>方法会被调用O(logn)次，每次需要O(n)的时间，因此总时间复杂度是O(nlogn)，空间复杂度为O(1)。</p> <div class=highlight><pre><span></span><code><span class=c1>// 题设：n+1的数组里的所有数字都在1到n的范围内</span>
<span class=c1>// 可以换成好理解的：n的数组里的所有数字都在1到n-1的范围内</span>
<span class=kd>private</span> <span class=kt>int</span> <span class=nf>duplicate</span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>numbers</span><span class=p>,</span> <span class=kt>int</span> <span class=n>length</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>numbers</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>length</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>length</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>numbers</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>numbers</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>&gt;=</span> <span class=n>length</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=c1>// start、end是需要统计的数字的上下限</span>
    <span class=kt>int</span> <span class=n>start</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>end</span> <span class=o>=</span> <span class=n>length</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>mid</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>

    <span class=k>while</span> <span class=p>(</span><span class=n>end</span> <span class=o>&gt;=</span> <span class=n>start</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>mid</span> <span class=o>=</span> <span class=p>((</span><span class=n>end</span> <span class=o>-</span> <span class=n>start</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>start</span><span class=p>;</span>

        <span class=kt>int</span> <span class=n>count</span> <span class=o>=</span> <span class=n>countRange</span><span class=p>(</span><span class=n>numbers</span><span class=p>,</span> <span class=n>start</span><span class=p>,</span> <span class=n>mid</span><span class=p>);</span>

        <span class=k>if</span> <span class=p>(</span><span class=n>start</span> <span class=o>==</span> <span class=n>end</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>count</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
                <span class=c1>// 找到了，当前指向的值就是重复数字</span>
                <span class=k>return</span> <span class=n>start</span><span class=p>;</span>
            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
                <span class=c1>// 否则，没有重复数字</span>
                <span class=k>break</span><span class=p>;</span>
            <span class=p>}</span>
        <span class=p>}</span>

        <span class=c1>// 如果区间内的出现的数字个数大于区间的长度，说明这个区间出现了重复数字</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>count</span> <span class=o>&gt;</span> <span class=p>(</span><span class=n>mid</span> <span class=o>-</span> <span class=n>start</span> <span class=o>+</span> <span class=mi>1</span><span class=p>))</span> <span class=p>{</span>
            <span class=c1>// 此时重复的值可能就是mid，所以end=mid</span>
            <span class=n>end</span> <span class=o>=</span> <span class=n>mid</span><span class=p>;</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=c1>// 如果该区间没有重复数字，那么mid肯定也不是，所以跳过mid</span>
            <span class=n>start</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
<span class=p>}</span>

<span class=kd>private</span> <span class=kt>int</span> <span class=nf>countRange</span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>numbers</span><span class=p>,</span> <span class=kt>int</span> <span class=n>start</span><span class=p>,</span> <span class=kt>int</span> <span class=n>end</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>

    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>numbers</span><span class=p>.</span><span class=na>length</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>numbers</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>&gt;=</span> <span class=n>start</span> <span class=o>&amp;&amp;</span> <span class=n>numbers</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>&lt;=</span> <span class=n>end</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>count</span><span class=o>++</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>count</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <h3 id=12-4>1.2 (4)二维数组中的查找<a class=headerlink href=#12-4 title="Permanent link">&para;</a></h3> <blockquote> <p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p> </blockquote> <p>下面就是一个示例数组。在其中查找7返回true，查找5返回false。</p> <div class=highlight><pre><span></span><code>1  2  8  9  
2  4  9  12  
4  7  10 13  
6  8  11 15  
</code></pre></div> <p>此题同<a href=/leetcode/leetcode71-80/#74-search-a-2d-matrix>LC-74-Search a 2D Matrix</a></p> <p>我们利用每行每列都是递增的规律，可以整行、整列地缩减查找范围。<br> 首选选取数组右上角的数字。如果数字等于要查找的数字，则查找过程结束；如果该数字大于要查找的数字，说明要查找的数字位于该列左边，所以剔除这个数字所在的列；如果该数字小于要查找的数字，说明要查找的数字位于改行下方，所以剔除这个数字所在的行。这样每一步都可以缩小查找的方位，直到找到数字或查找结束。 </p> <div class=highlight><pre><span></span><code><span class=kt>boolean</span> <span class=nf>find</span><span class=p>(</span><span class=kt>int</span><span class=o>[][]</span> <span class=n>matrix</span><span class=p>,</span> <span class=kt>int</span> <span class=n>rows</span><span class=p>,</span> <span class=kt>int</span> <span class=n>columns</span><span class=p>,</span> <span class=kt>int</span> <span class=n>number</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>matrix</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>rows</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>columns</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=kc>false</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=kt>int</span> <span class=n>row</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>col</span> <span class=o>=</span> <span class=n>columns</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
    <span class=k>while</span> <span class=p>(</span><span class=n>row</span> <span class=o>&lt;</span> <span class=n>rows</span> <span class=o>&amp;&amp;</span> <span class=n>col</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>matrix</span><span class=o>[</span><span class=n>row</span><span class=o>][</span><span class=n>col</span><span class=o>]</span> <span class=o>==</span> <span class=n>number</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>return</span> <span class=kc>true</span><span class=p>;</span>
        <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>matrix</span><span class=o>[</span><span class=n>row</span><span class=o>][</span><span class=n>col</span><span class=o>]</span> <span class=o>&gt;</span> <span class=n>number</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>col</span><span class=o>--</span><span class=p>;</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=n>row</span><span class=o>++</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=kc>false</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>在上面的代码中，我们选取的右上角的数字。同样，我们也可以选择左下角的数字，也可以逐步减小查找范围。其他两个角因为是最小值、最大值，无法逐步减小查找范围。 <div class=highlight><pre><span></span><code><span class=kt>int</span> <span class=n>row</span> <span class=o>=</span> <span class=n>rows</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
<span class=kt>int</span> <span class=n>col</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
<span class=k>while</span> <span class=p>(</span><span class=n>col</span> <span class=o>&lt;</span> <span class=n>columns</span> <span class=o>&amp;&amp;</span> <span class=n>row</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>matrix</span><span class=o>[</span><span class=n>row</span><span class=o>][</span><span class=n>col</span><span class=o>]</span> <span class=o>==</span> <span class=n>number</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=kc>true</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>matrix</span><span class=o>[</span><span class=n>row</span><span class=o>][</span><span class=n>col</span><span class=o>]</span> <span class=o>&gt;</span> <span class=n>number</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>row</span><span class=o>--</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=n>col</span><span class=o>++</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div></p> <h2 id=2>2. 字符串<a class=headerlink href=#2 title="Permanent link">&para;</a></h2> <h3 id=21-5>2.1 (5)替换空格<a class=headerlink href=#21-5 title="Permanent link">&para;</a></h3> <blockquote> <p>请实现一个函数，把字符串中的每个空格替换成"%20"。例如输入“We are happy.”，则输出“We%20are%20happy.”。</p> </blockquote> <p><strong>解法一：顺序查找空格，找到后插入%20</strong><br> 假设字符串的长度为n。对于每个空格字符，需要移动和面O(n)个字符，对于含有O(n)个空格字符的字符串而言，总的时间效率是O(n^2)。</p> <p><strong>解法二：计算空格个数，从后往前替换空格</strong><br> 我们可以先遍历一次字符串，统计出空格的总数，由此可以计算出新串的总长度。然后从字符串的后面（或前面）开始复制和替换，方向没有多少区别。 </p> <div class=highlight><pre><span></span><code><span class=n>String</span> <span class=nf>replaceBlank</span><span class=p>(</span><span class=n>String</span> <span class=n>str</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>str</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=s>&quot;&quot;</span><span class=p>.</span><span class=na>equals</span><span class=p>(</span><span class=n>str</span><span class=p>))</span> <span class=p>{</span>
        <span class=k>return</span> <span class=n>str</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=c1>// 统计空格的个数</span>
    <span class=kt>int</span> <span class=n>spaceCount</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>str</span><span class=p>.</span><span class=na>length</span><span class=p>();</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>str</span><span class=p>.</span><span class=na>charAt</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=o>==</span> <span class=sc>&#39; &#39;</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>spaceCount</span><span class=o>++</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=c1>// 如果不包含空格，就可以直接返回原来的字符串</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>spaceCount</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=n>str</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=c1>// 申请新串，准备复制</span>
    <span class=kd>final</span> <span class=kt>int</span> <span class=n>newStrLength</span> <span class=o>=</span> <span class=n>str</span><span class=p>.</span><span class=na>length</span><span class=p>()</span> <span class=o>+</span> <span class=n>spaceCount</span> <span class=o>*</span> <span class=mi>2</span><span class=p>;</span>
    <span class=kt>char</span><span class=o>[]</span> <span class=n>result</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>char</span><span class=o>[</span><span class=n>newStrLength</span><span class=o>]</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>index</span> <span class=o>=</span> <span class=n>newStrLength</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>

    <span class=c1>// 在原来的串上从后往前遍历</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>str</span><span class=p>.</span><span class=na>length</span><span class=p>()</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span><span class=o>--</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>str</span><span class=p>.</span><span class=na>charAt</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=o>==</span> <span class=sc>&#39; &#39;</span><span class=p>)</span> <span class=p>{</span>
            <span class=c1>// 遇到一个空格，则在新串上填上%20</span>
            <span class=n>result</span><span class=o>[</span><span class=n>index</span><span class=o>--]</span> <span class=o>=</span> <span class=sc>&#39;0&#39;</span><span class=p>;</span>
            <span class=n>result</span><span class=o>[</span><span class=n>index</span><span class=o>--]</span> <span class=o>=</span> <span class=sc>&#39;2&#39;</span><span class=p>;</span>
            <span class=n>result</span><span class=o>[</span><span class=n>index</span><span class=o>--]</span> <span class=o>=</span> <span class=sc>&#39;%&#39;</span><span class=p>;</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=c1>// 复制原来的字符</span>
            <span class=n>result</span><span class=o>[</span><span class=n>index</span><span class=o>--]</span> <span class=o>=</span> <span class=n>str</span><span class=p>.</span><span class=na>charAt</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=k>new</span> <span class=n>String</span><span class=p>(</span><span class=n>result</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div> <p>也可以在Java中直接使用<code>StringBuilder</code>的特点解决此问题： <div class=highlight><pre><span></span><code><span class=n>String</span> <span class=nf>replaceBlank</span><span class=p>(</span><span class=n>String</span> <span class=n>str</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>str</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=s>&quot;&quot;</span><span class=p>.</span><span class=na>equals</span><span class=p>(</span><span class=n>str</span><span class=p>))</span> <span class=p>{</span>
        <span class=k>return</span> <span class=n>str</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=n>StringBuilder</span> <span class=n>result</span> <span class=o>=</span> <span class=k>new</span> <span class=n>StringBuilder</span><span class=p>();</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>str</span><span class=p>.</span><span class=na>length</span><span class=p>();</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=kt>char</span> <span class=n>ch</span> <span class=o>=</span> <span class=n>str</span><span class=p>.</span><span class=na>charAt</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>ch</span> <span class=o>==</span> <span class=sc>&#39; &#39;</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>result</span><span class=p>.</span><span class=na>append</span><span class=p>(</span><span class=s>&quot;%20&quot;</span><span class=p>);</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=n>result</span><span class=p>.</span><span class=na>append</span><span class=p>(</span><span class=n>ch</span><span class=p>);</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>result</span><span class=p>.</span><span class=na>toString</span><span class=p>();</span>
<span class=p>}</span>
</code></pre></div></p> <div class="admonition info"> <p class=admonition-title>相关题目</p> <p>有两个排序的数组A1和A2，内存在A1的末尾有足够多的剩余空间容纳A2。请实现一个函数，把A2中的所有数字插入A1中，并且所有的数字是排序的。<br> 和前面的例题一样，很多人首先想到的办法是在A1中从头到尾复制数字，但这样就会出现多次复制一个数字的情况。更好的的方法是 <strong>从尾到头</strong> 比较A1和A2中的数字，并把较大的数字复制到A1中的合适位置。</p> </div> <div class="admonition info"> <p class=admonition-title>举一反三</p> <p>在合并两个数组时，如果从前往后复制每个数字需要重复移动数字多次，那么我们可以考虑从后往前复制，这样就能减少移动的次数，从而提高效率。</p> </div> <h2 id=3>3. 链表<a class=headerlink href=#3 title="Permanent link">&para;</a></h2> <h3 id=31-6>3.1 (6)从尾到头打印链表<a class=headerlink href=#31-6 title="Permanent link">&para;</a></h3> <blockquote> <p>输入一个链表的头结点，从尾到头反过来打印出每个结点的值。</p> </blockquote> <p>通常打印只是一个只读操作，我们不希望打印时修改内容。<br> 此题如果想把链表中链接节点的指针反转过来，改变链表的方向，这样就太蠢了，而且也会改变原来链表的结构。<br> 我们可以想到遍历时使用<code>Stack</code>保存节点的值，然后全部出栈就可以了。</p> <p><strong>解法一：利用栈</strong></p> <div class=highlight><pre><span></span><code><span class=kd>private</span> <span class=kt>void</span> <span class=nf>printListReversingly1</span><span class=p>(</span><span class=n>ListNode</span> <span class=n>pHead</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>ListNode</span> <span class=n>p</span> <span class=o>=</span> <span class=n>pHead</span><span class=p>;</span>

    <span class=n>Stack</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>stack</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Stack</span><span class=o>&lt;&gt;</span><span class=p>();</span>

    <span class=k>while</span> <span class=p>(</span><span class=n>p</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>stack</span><span class=p>.</span><span class=na>push</span><span class=p>(</span><span class=n>p</span><span class=p>.</span><span class=na>value</span><span class=p>);</span>
        <span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=p>.</span><span class=na>next</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>stack</span><span class=p>.</span><span class=na>isEmpty</span><span class=p>())</span> <span class=p>{</span>
        <span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>print</span><span class=p>(</span><span class=n>stack</span><span class=p>.</span><span class=na>pop</span><span class=p>()</span> <span class=o>+</span> <span class=s>&quot;\t&quot;</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div> <p>既然想到了用栈实现，而递归本质上就是一个栈结构，所以我们也可以利用递归实现。<br> 要反过来输出链表，我们每访问一个节点时，先递归输出它后面的节点，再输出该节点自身，这样就实现了目的。</p> <p><strong>解法二：递归</strong> <div class=highlight><pre><span></span><code><span class=kd>private</span> <span class=kt>void</span> <span class=nf>printListReversingly2</span><span class=p>(</span><span class=n>ListNode</span> <span class=n>pHead</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>pHead</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>printListReversingly1</span><span class=p>(</span><span class=n>pHead</span><span class=p>.</span><span class=na>next</span><span class=p>);</span>
        <span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>print</span><span class=p>(</span><span class=n>pHead</span><span class=p>.</span><span class=na>value</span> <span class=o>+</span> <span class=s>&quot;\t&quot;</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div></p> <p>上面的代码看起来很简洁，但 <strong>当链表非常长的时候，就会导致函数调用的层级很深，从而导致函数调用栈溢出</strong> 。显然用栈基于循环实现的代码鲁棒性要好一点。 </p> <h2 id=4>4. 树<a class=headerlink href=#4 title="Permanent link">&para;</a></h2> <p>树的逻辑结构很简单：除根节点之外的每个节点只有一个父节点，根节点没有父节点；除叶节点之外所有节点都有一个或多个子节点，叶节点没有子节点。父节点与子节点之间用指针链接。 </p> <p>我们常提到的树是二叉树，通常二叉树有如下几种遍历方式。</p> <ul> <li><strong>前序遍历</strong>：根左右，即先访问根节点，再访问左子节点，最后访问右子节点。<br> 图中二叉树的前序遍历的顺序是，10、6、4、8、14、12、16</li> <li><strong>中序遍历</strong>：左根右，即先访问左子节点，再访问根节点，最后访问右子节点。<br> 图中二叉树的中序遍历的顺序是，4、6、8、10、12、14、16</li> <li> <p><strong>后序遍历</strong>：左右根，即先访问左子节点，再访问右子节点，最后访问根节点。<br> 图中二叉树的中序遍历的顺序是，4、8、6、12、16、14、10</p> <p><img alt=一个二叉树例子 src=/assets/images/leetcode/ci_binary_tree_sample.png><br> 这三种遍历方式都有递归和循环2种实现方式，每种遍历的递归实现都比循环实现要简洁很多。我们应该对这3中遍历的6种实现方法都了如指掌。 </p> </li> <li> <p><strong>宽度优先遍历</strong>：先访问树的第一层节点，再访问树的第二层节点……一直到访问到最下面一层节点。在同一层节点中，以从左到右的顺序依次访问。我们可以对包括二叉树在内的所有树进行宽度优先遍历。<br> 图中二叉树的宽度优先遍历的顺序是：10、6、14、4、8、12、16</p> </li> </ul> <h3 id=_1>树的遍历算法<a class=headerlink href=#_1 title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=cm>/**</span>
<span class=cm> * 前序遍历递归算法</span>
<span class=cm> */</span>
<span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>preorderRecursive</span><span class=p>(</span><span class=n>BinaryTreeNode</span> <span class=n>node</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>node</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>print</span><span class=p>(</span><span class=s>&quot; &quot;</span> <span class=o>+</span> <span class=n>node</span><span class=p>.</span><span class=na>value</span><span class=p>);</span>
        <span class=n>preorderRecursive</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=na>left</span><span class=p>);</span>
        <span class=n>preorderRecursive</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=na>right</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=cm>/**</span>
<span class=cm> * 前序遍历循环算法</span>
<span class=cm> * 从根节点开始，每访问一节点时，先访问左子树，同时若右子树存在，则将右子树进栈</span>
<span class=cm> */</span>
<span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>preorderIterative</span><span class=p>(</span><span class=n>BinaryTreeNode</span> <span class=n>node</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>node</span> <span class=o>==</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=n>Stack</span><span class=o>&lt;</span><span class=n>BinaryTreeNode</span><span class=o>&gt;</span> <span class=n>stack</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Stack</span><span class=o>&lt;&gt;</span><span class=p>();</span>
    <span class=n>BinaryTreeNode</span> <span class=n>p</span><span class=p>;</span>

    <span class=c1>// 根节点进栈</span>
    <span class=n>stack</span><span class=p>.</span><span class=na>push</span><span class=p>(</span><span class=n>node</span><span class=p>);</span>
    <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>stack</span><span class=p>.</span><span class=na>isEmpty</span><span class=p>())</span> <span class=p>{</span>
        <span class=c1>// 开始访问当前栈顶的元素</span>
        <span class=n>p</span> <span class=o>=</span> <span class=n>stack</span><span class=p>.</span><span class=na>pop</span><span class=p>();</span>
        <span class=k>while</span> <span class=p>(</span><span class=n>p</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
            <span class=c1>// 访问当前栈顶的元素</span>
            <span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>print</span><span class=p>(</span><span class=s>&quot; &quot;</span> <span class=o>+</span> <span class=n>p</span><span class=p>.</span><span class=na>value</span><span class=p>);</span>
            <span class=c1>// 若右节点存在，则将右子树进栈</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=p>.</span><span class=na>right</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
                <span class=n>stack</span><span class=p>.</span><span class=na>push</span><span class=p>(</span><span class=n>p</span><span class=p>.</span><span class=na>right</span><span class=p>);</span>
            <span class=p>}</span>
            <span class=c1>// 继续沿着左子树访问</span>
            <span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=p>.</span><span class=na>left</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=cm>/**</span>
<span class=cm> * 中序遍历递归算法</span>
<span class=cm> */</span>
<span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>inorderRecursive</span><span class=p>(</span><span class=n>BinaryTreeNode</span> <span class=n>node</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>node</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>inorderRecursive</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=na>left</span><span class=p>);</span>
        <span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>print</span><span class=p>(</span><span class=s>&quot; &quot;</span> <span class=o>+</span> <span class=n>node</span><span class=p>.</span><span class=na>value</span><span class=p>);</span>
        <span class=n>inorderRecursive</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=na>right</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=cm>/**</span>
<span class=cm> * 中序遍历循环算法</span>
<span class=cm> * 从根节点开始，沿着左子树找到该子树在中序下的第一节点(同时保存每个节点到栈内)，访问该节点</span>
<span class=cm> * 然后访问该节点的右子树</span>
<span class=cm> */</span>
<span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>inorderIterative</span><span class=p>(</span><span class=n>BinaryTreeNode</span> <span class=n>node</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>node</span> <span class=o>==</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=n>Stack</span><span class=o>&lt;</span><span class=n>BinaryTreeNode</span><span class=o>&gt;</span> <span class=n>stack</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Stack</span><span class=o>&lt;&gt;</span><span class=p>();</span>
    <span class=n>BinaryTreeNode</span> <span class=n>p</span><span class=p>;</span>

    <span class=c1>// 根节点进栈</span>
    <span class=n>stack</span><span class=p>.</span><span class=na>push</span><span class=p>(</span><span class=n>node</span><span class=p>);</span>
    <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>stack</span><span class=p>.</span><span class=na>isEmpty</span><span class=p>())</span> <span class=p>{</span>
        <span class=c1>// 开始访问栈顶的元素</span>
        <span class=n>p</span> <span class=o>=</span> <span class=n>stack</span><span class=p>.</span><span class=na>peek</span><span class=p>();</span>
        <span class=c1>// 若左子树存在，一直将左子树压进栈</span>
        <span class=k>while</span> <span class=p>(</span><span class=n>p</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>stack</span><span class=p>.</span><span class=na>push</span><span class=p>(</span><span class=n>p</span><span class=p>.</span><span class=na>left</span><span class=p>);</span>
            <span class=n>p</span> <span class=o>=</span> <span class=n>stack</span><span class=p>.</span><span class=na>peek</span><span class=p>();</span>
        <span class=p>}</span>
        <span class=c1>// 弹出栈顶的空元素</span>
        <span class=n>stack</span><span class=p>.</span><span class=na>pop</span><span class=p>();</span>

        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>stack</span><span class=p>.</span><span class=na>isEmpty</span><span class=p>())</span> <span class=p>{</span>
            <span class=c1>// 叶节点或没有左子树的节点</span>
            <span class=n>p</span> <span class=o>=</span> <span class=n>stack</span><span class=p>.</span><span class=na>pop</span><span class=p>();</span>
            <span class=c1>// 访问当前栈顶的元素</span>
            <span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>print</span><span class=p>(</span><span class=s>&quot; &quot;</span> <span class=o>+</span> <span class=n>p</span><span class=p>.</span><span class=na>value</span><span class=p>);</span>
            <span class=c1>// 将右子树进栈，在循环的开始就能处理右子树了</span>
            <span class=n>stack</span><span class=p>.</span><span class=na>push</span><span class=p>(</span><span class=n>p</span><span class=p>.</span><span class=na>right</span><span class=p>);</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=cm>/**</span>
<span class=cm> * 后序遍历递归算法</span>
<span class=cm> */</span>
<span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>postorderRecursive</span><span class=p>(</span><span class=n>BinaryTreeNode</span> <span class=n>node</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>node</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>postorderRecursive</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=na>left</span><span class=p>);</span>
        <span class=n>postorderRecursive</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=na>right</span><span class=p>);</span>
        <span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>print</span><span class=p>(</span><span class=s>&quot; &quot;</span> <span class=o>+</span> <span class=n>node</span><span class=p>.</span><span class=na>value</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=kd>private</span> <span class=kd>static</span> <span class=kd>class</span> <span class=nc>NodeWrapper</span> <span class=p>{</span>
    <span class=kd>public</span> <span class=n>BinaryTreeNode</span> <span class=n>node</span><span class=p>;</span>
    <span class=cm>/**</span>
<span class=cm>     * false表示左子树压入的</span>
<span class=cm>     * true表示右子树压入的</span>
<span class=cm>     */</span>
    <span class=kd>public</span> <span class=kt>boolean</span> <span class=n>tag</span><span class=p>;</span>
<span class=p>}</span>

<span class=cm>/**</span>
<span class=cm> * 后序遍历循环算法</span>
<span class=cm> * 对于一个节点是否能够访问，要看它的左右子树是否遍历完</span>
<span class=cm> * 首先从根节点开始，沿着左子树开始遍历，将途中所有节点全部标记并压入栈中</span>
<span class=cm> * 然后取栈顶元素，如果能够访问右子树，则沿着右子树开始遍历，将途中所有节点全部标记并压入栈中</span>
<span class=cm> * 若左右都访问完毕，则访问自身这个节点</span>
<span class=cm> */</span>
<span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>postorderIterative</span><span class=p>(</span><span class=n>BinaryTreeNode</span> <span class=n>node</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>node</span> <span class=o>==</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=n>Stack</span><span class=o>&lt;</span><span class=n>NodeWrapper</span><span class=o>&gt;</span> <span class=n>stack</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Stack</span><span class=o>&lt;&gt;</span><span class=p>();</span>
    <span class=n>BinaryTreeNode</span> <span class=n>p</span> <span class=o>=</span> <span class=n>node</span><span class=p>;</span>
    <span class=n>NodeWrapper</span> <span class=n>wrapper</span><span class=p>;</span>

    <span class=k>while</span> <span class=p>(</span><span class=n>p</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>||</span> <span class=o>!</span><span class=n>stack</span><span class=p>.</span><span class=na>isEmpty</span><span class=p>())</span> <span class=p>{</span>
        <span class=c1>// 沿着左子树开始遍历，将途中所有节点全部标记并压入栈中</span>
        <span class=k>while</span> <span class=p>(</span><span class=n>p</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>wrapper</span> <span class=o>=</span> <span class=k>new</span> <span class=n>NodeWrapper</span><span class=p>();</span>
            <span class=n>wrapper</span><span class=p>.</span><span class=na>node</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
            <span class=n>wrapper</span><span class=p>.</span><span class=na>tag</span> <span class=o>=</span> <span class=kc>false</span><span class=p>;</span>
            <span class=n>stack</span><span class=p>.</span><span class=na>push</span><span class=p>(</span><span class=n>wrapper</span><span class=p>);</span>
            <span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=p>.</span><span class=na>left</span><span class=p>;</span>
        <span class=p>}</span>

        <span class=c1>// 取栈顶元素</span>
        <span class=n>wrapper</span> <span class=o>=</span> <span class=n>stack</span><span class=p>.</span><span class=na>pop</span><span class=p>();</span>
        <span class=n>p</span> <span class=o>=</span> <span class=n>wrapper</span><span class=p>.</span><span class=na>node</span><span class=p>;</span>
        <span class=kt>boolean</span> <span class=n>find</span> <span class=o>=</span> <span class=n>wrapper</span><span class=p>.</span><span class=na>tag</span><span class=p>;</span>

        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>find</span><span class=p>)</span> <span class=p>{</span>
            <span class=c1>// 能够访问右子树，则沿着右子树开始遍历，将途中所有节点全部标记并压入栈中</span>
            <span class=n>wrapper</span> <span class=o>=</span> <span class=k>new</span> <span class=n>NodeWrapper</span><span class=p>();</span>
            <span class=n>wrapper</span><span class=p>.</span><span class=na>node</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
            <span class=n>wrapper</span><span class=p>.</span><span class=na>tag</span> <span class=o>=</span> <span class=kc>true</span><span class=p>;</span>
            <span class=n>stack</span><span class=p>.</span><span class=na>push</span><span class=p>(</span><span class=n>wrapper</span><span class=p>);</span>
            <span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=p>.</span><span class=na>right</span><span class=p>;</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=c1>// 左右都访问完毕，则访问自身这个节点</span>
            <span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>print</span><span class=p>(</span><span class=s>&quot; &quot;</span> <span class=o>+</span> <span class=n>p</span><span class=p>.</span><span class=na>value</span><span class=p>);</span>
            <span class=n>p</span> <span class=o>=</span> <span class=kc>null</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=cm>/**</span>
<span class=cm> * 层序遍历算法</span>
<span class=cm> */</span>
<span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>levelIterative</span><span class=p>(</span><span class=n>BinaryTreeNode</span> <span class=n>node</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>Queue</span><span class=o>&lt;</span><span class=n>BinaryTreeNode</span><span class=o>&gt;</span> <span class=n>queue</span> <span class=o>=</span> <span class=k>new</span> <span class=n>LinkedList</span><span class=o>&lt;&gt;</span><span class=p>();</span>
    <span class=n>queue</span><span class=p>.</span><span class=na>offer</span><span class=p>(</span><span class=n>node</span><span class=p>);</span>

    <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>queue</span><span class=p>.</span><span class=na>isEmpty</span><span class=p>())</span> <span class=p>{</span>
        <span class=n>node</span> <span class=o>=</span> <span class=n>queue</span><span class=p>.</span><span class=na>poll</span><span class=p>();</span>
        <span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>print</span><span class=p>(</span><span class=s>&quot; &quot;</span> <span class=o>+</span> <span class=n>node</span><span class=p>.</span><span class=na>value</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=na>left</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>queue</span><span class=p>.</span><span class=na>offer</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=na>left</span><span class=p>);</span>
        <span class=p>}</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=na>right</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>queue</span><span class=p>.</span><span class=na>offer</span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=na>right</span><span class=p>);</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div> <h3 id=_2>树的其他概念<a class=headerlink href=#_2 title="Permanent link">&para;</a></h3> <p>若设二叉树的深度为h，除第h层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层所有的结点都连续集中在最左边，这就是 <strong>完全二叉树</strong>。 </p> <p><strong>二叉搜索树、二叉查找树、二叉排序树</strong> 是一个概念：左子节点总是小于或者等于根节点，而右子节点总是大于或者等于根节点。 </p> <p><strong>平衡二叉树AVL</strong> 是一颗二叉搜索树，每个节点的左右子树的高度差的绝对值（平衡因子）最多为1。</p> <p>二叉树有很多特例，<strong>二叉搜索树</strong> 就是其中之一。<br> 在二叉搜索树中，左子节点总是小于或者等于根节点，而右子节点总是大于或者等于根节点。上面练习树的遍历算法的二叉树就是一颗二叉搜索树。我们平均在O(logn)的时间内根据数值在二叉搜索树中找到一个节点。</p> <p>二叉树的另外两个特例是 <strong>堆</strong> 和 <strong>红黑树</strong>。 </p> <ul> <li> <p>堆分为 <strong>最大堆</strong> 和 <strong>最小堆</strong>。在最大堆中根节点的值最大，在最小堆中根节点的值最小。有很多需要快速找到最大值或者最小值的问题都可以用堆解决。<br> 最小堆、最大堆在Java中可以这样实现： <div class=highlight><pre><span></span><code><span class=c1>// 最小堆</span>
<span class=n>PriorityQueue</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>minHeap</span> <span class=o>=</span> <span class=k>new</span> <span class=n>PriorityQueue</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=p>();</span>

<span class=c1>// 最大堆</span>
<span class=n>PriorityQueue</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>maxHeap</span> <span class=o>=</span> <span class=k>new</span> <span class=n>PriorityQueue</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=k>new</span> <span class=n>Comparator</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=p>(){</span>
    <span class=nd>@Override</span>
    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>compare</span><span class=p>(</span><span class=n>Integer</span> <span class=n>o1</span><span class=p>,</span> <span class=n>Integer</span> <span class=n>o2</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=n>o2</span> <span class=o>-</span> <span class=n>o1</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>});</span>
</code></pre></div></p> </li> <li> <p>关于红黑树，维基百科说的非常好：<a href=https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91>红黑树</a><br> <strong>红黑树</strong> 是一种近似平衡的二叉查找树，它把树中的节点定义为红、黑两种颜色，并通过规则确保从根节点到叶节点的最长路径的长度不超过最短路径的两倍。<br> 具体来说，红黑树是满足如下条件的二叉查找树：</p> <ol> <li>每个节点要么是红色，要么是黑色。</li> <li>根节点必须是黑色</li> <li>每个叶节点（在红黑树中指树尾端的null节点）都是黑色</li> <li>红色节点不能连续（也即是，红色节点的孩子和父亲都不能是红色）。</li> <li>对于每个节点，从该点至null（树尾端）的任何路径，都含有相同个数的黑色节点。 </li> </ol> <p>一个红黑树例子如下：</p> <p><img alt=红黑树示例 src=/assets/images/leetcode/red-black_tree_example.png></p> <p>这些约束确保了红黑树的关键特性：<strong>从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的</strong>。 因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。<br> 要知道为什么这些性质确保了这个结果，注意到性质4导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。<br> 在树的结构发生改变时（插入或者删除操作），往往会破坏上述条件4或条件5，需要通过调整使得查找树重新满足红黑树的条件。<br> 调整可以分为两类：一类是颜色调整，即改变某个节点的颜色；另一类是结构调整，集改变检索树的结构关系。结构调整过程包含两个基本操作：左旋（Rotate Left），右旋（Rotate Right）。<br> Java中<code>TreeMap</code>底层通过红黑树来实现，这样插入删除都只有<span><span class=MathJax_Preview>O(logn)</span><script type=math/tex>O(logn)</script></span>的时间复杂度。</p> </li> </ul> <h3 id=41-7>4.1 (7)重建二叉树<a class=headerlink href=#41-7 title="Permanent link">&para;</a></h3> <blockquote> <p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。<br> 例如输入前序遍历序列{1,2, 4, 7, 3, 5, 6, 8}和中序遍历序列{4, 7, 2, 1, 5, 3, 8, 6}，则重建下图所示的二叉树并输出它的头结点。</p> </blockquote> <p>此题同<a href=/leetcode/leetcode101-110/#105-construct-binary-tree-from-preorder-and-inorder-traversal>LC-105-Construct Binary Tree from Preorder and Inorder Traversal</a></p> <div class="admonition tip"> <p class=admonition-title>Tip</p> <p>前序+中序、后序+中序、层序+中序都可以重建二叉树，但是前序+后序不行。</p> </div> <p><img alt=一个二叉树例子 src=/assets/images/leetcode/ci_binary_tree_7.png><br> <center>一个二叉树例子</center></p> <p>算法思路是先根据前序序列找到根节点，然后在中序序列中找到该节点，其左边的就是树的左子树，右边就是右子树。</p> <div class=highlight><pre><span></span><code><span class=kd>private</span> <span class=n>BinaryTreeNode</span> <span class=nf>construct</span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>preorder</span><span class=p>,</span> <span class=kt>int</span><span class=o>[]</span> <span class=n>inorder</span><span class=p>,</span> <span class=kt>int</span> <span class=n>length</span><span class=p>)</span> <span class=kd>throws</span> <span class=n>Exception</span><span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>preorder</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>inorder</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>length</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=kc>null</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>constructCore</span><span class=p>(</span><span class=n>preorder</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>preorder</span><span class=p>.</span><span class=na>length</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=n>inorder</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>inorder</span><span class=p>.</span><span class=na>length</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
<span class=p>}</span>

<span class=kd>private</span> <span class=n>BinaryTreeNode</span> <span class=nf>constructCore</span><span class=p>(</span>
        <span class=kt>int</span><span class=o>[]</span> <span class=n>preorder</span><span class=p>,</span> <span class=kt>int</span> <span class=n>startPreorder</span><span class=p>,</span> <span class=kt>int</span> <span class=n>endPreorder</span><span class=p>,</span>
        <span class=kt>int</span><span class=o>[]</span> <span class=n>inorder</span><span class=p>,</span> <span class=kt>int</span> <span class=n>startInorder</span><span class=p>,</span> <span class=kt>int</span> <span class=n>endInorder</span>
<span class=p>)</span> <span class=kd>throws</span> <span class=n>Exception</span> <span class=p>{</span>
    <span class=c1>// 如果发生了这种情况，说明前中序子序列为空，那么肯定就是空节点了</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>startInorder</span> <span class=o>&gt;</span> <span class=n>endInorder</span> <span class=o>||</span> <span class=n>startPreorder</span> <span class=o>&gt;</span> <span class=n>endPreorder</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=kc>null</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=c1>// startPreorder即为根节点</span>
    <span class=n>BinaryTreeNode</span> <span class=n>root</span> <span class=o>=</span> <span class=k>new</span> <span class=n>BinaryTreeNode</span><span class=p>(</span><span class=n>preorder</span><span class=o>[</span><span class=n>startPreorder</span><span class=o>]</span><span class=p>);</span>

    <span class=kt>boolean</span> <span class=n>find</span> <span class=o>=</span> <span class=kc>false</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>startInorder</span><span class=p>;</span>
    <span class=k>for</span> <span class=p>(;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>endInorder</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>inorder</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>==</span> <span class=n>root</span><span class=p>.</span><span class=na>value</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>find</span> <span class=o>=</span> <span class=kc>true</span><span class=p>;</span>
            <span class=c1>// 由于在中序序列中i是根节点，所以i-startInorder的长度就是左子树的长度</span>
            <span class=c1>// 因此重建左子树时，左子树的前序序列范围就是startPreorder+1至startPreorder+1 + i-startInorder - 1 = startPreorder + i - startInorder</span>
            <span class=c1>// 左子树的中序序列范围就是startInorder至i - 1，没有什么好说的</span>
            <span class=c1>// 重建右子树时类似</span>
            <span class=n>root</span><span class=p>.</span><span class=na>left</span> <span class=o>=</span> <span class=n>constructCore</span><span class=p>(</span>
                <span class=n>preorder</span><span class=p>,</span> <span class=n>startPreorder</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>startPreorder</span> <span class=o>+</span> <span class=n>i</span> <span class=o>-</span> <span class=n>startInorder</span><span class=p>,</span>
                <span class=n>inorder</span><span class=p>,</span> <span class=n>startInorder</span><span class=p>,</span> <span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
            <span class=n>root</span><span class=p>.</span><span class=na>right</span> <span class=o>=</span> <span class=n>constructCore</span><span class=p>(</span>
                <span class=n>preorder</span><span class=p>,</span> <span class=n>startPreorder</span> <span class=o>+</span> <span class=n>i</span> <span class=o>-</span> <span class=n>startInorder</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>endPreorder</span><span class=p>,</span>
                <span class=n>inorder</span><span class=p>,</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>endInorder</span><span class=p>);</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=c1>// 最后，如果根节点在中序序列中没有找到，那么肯定是无效的输入了</span>
    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>find</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>throw</span> <span class=k>new</span> <span class=n>Exception</span><span class=p>(</span><span class=s>&quot;invalid input&quot;</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>root</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <h3 id=42-8>4.2 (8)二叉树的下一个节点<a class=headerlink href=#42-8 title="Permanent link">&para;</a></h3> <blockquote> <p>给定一棵二叉树和其中的一个结点，如何找出中序遍历顺序的下一个结点？树中的结点除了有两个分别指向左右子结点的指针以外，还有一个指向父结点的指针。</p> </blockquote> <p>下图中二叉树的中序遍历序列是{d, b, h, e, i, a, f, c, g}。</p> <p><img alt=一颗有9个节点的二叉树 src=/assets/images/leetcode/ci_binary_tree_8.png><br> <center>一颗有9个节点的二叉树</center></p> <p>我们以上面这颗树为例分析如何找出二叉树的下一个节点。 </p> <ul> <li><em>根</em>，如果一个节点有右子树：那么它的下一个节点就是它的右子树中的最左子节点。也就是说，从右子节点出发一直沿着指向左子节点的指针，我们就能找到它的下一个节点。</li> <li><em>左</em>，如果一个节点没有右子树，同时节点是它父节点的左子节点，那么它的父节点就是要找的下一个节点。</li> <li><em>右</em>，如果一个节点没有右子树，同时节点是它父节点的右子节点：我们需要沿着父节点一直向上，直到找到一个是它父节点的左子节点的节点。这个父节点就是我们要找的下一个节点。</li> </ul> <div class=highlight><pre><span></span><code><span class=kd>private</span> <span class=n>ParentBinaryTreeNode</span> <span class=nf>getNext</span><span class=p>(</span><span class=n>ParentBinaryTreeNode</span> <span class=n>node</span><span class=p>){</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>node</span> <span class=o>==</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=kc>null</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=n>ParentBinaryTreeNode</span> <span class=n>next</span> <span class=o>=</span> <span class=kc>null</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=na>right</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>// 情况1 从右子节点出发一直沿着指向左子节点的指针</span>
        <span class=n>next</span> <span class=o>=</span> <span class=n>node</span><span class=p>.</span><span class=na>right</span><span class=p>;</span>

        <span class=k>while</span> <span class=p>(</span><span class=n>next</span><span class=p>.</span><span class=na>left</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>next</span> <span class=o>=</span> <span class=n>next</span><span class=p>.</span><span class=na>left</span><span class=p>;</span>
        <span class=p>}</span>

        <span class=k>return</span> <span class=n>next</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=na>parent</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>// 情况2、3可以理解为同一种 2是3的一般情况</span>
        <span class=n>next</span> <span class=o>=</span> <span class=n>node</span><span class=p>;</span>

        <span class=c1>// 沿着父节点一直向上，直到找到一个节点，它是父节点的左子节点</span>
        <span class=c1>// 即如果这个节点是父节点的右节点，那么继续寻找</span>
        <span class=k>while</span> <span class=p>(</span><span class=n>next</span><span class=p>.</span><span class=na>parent</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>next</span> <span class=o>==</span> <span class=n>next</span><span class=p>.</span><span class=na>parent</span><span class=p>.</span><span class=na>right</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>next</span> <span class=o>=</span> <span class=n>next</span><span class=p>.</span><span class=na>parent</span><span class=p>;</span>
        <span class=p>}</span>

        <span class=c1>// 最后这个父节点就是我们要找的下一个节点</span>
        <span class=k>return</span> <span class=n>next</span><span class=p>.</span><span class=na>parent</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>next</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <h2 id=5>5. 栈和队列<a class=headerlink href=#5 title="Permanent link">&para;</a></h2> <p>栈的特点是后进先出，通常栈是一个不考虑排序的数据结构，我们需要O(n)时间才能找到栈中最大或者最小的元素。如果想要在O(1)时间内得到栈的最大值或最小值，则需要对栈做特殊的设计，详见(30)题“包含min函数的栈”。</p> <p>队列的特点是先进先出。</p> <p>栈和队列虽然是特点针锋相对的两个数据结构，但有意思的是他们却相互联系。</p> <p>栈的常用操作为：</p> <ul> <li><code>isEmpty</code></li> <li><code>peek</code></li> <li><code>pop</code></li> <li><code>push</code></li> </ul> <p>队列的常用操作为：</p> <ul> <li><code>isEmpty</code></li> <li><code>peek</code></li> <li><code>poll</code></li> <li><code>offer</code></li> </ul> <h3 id=51-9>5.1 (9)用两个栈实现队列<a class=headerlink href=#51-9 title="Permanent link">&para;</a></h3> <blockquote> <p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数appendTail和deleteHead，分别完成在队列尾部插入结点和在队列头部删除结点的功能。</p> </blockquote> <div class=highlight><pre><span></span><code><span class=kd>class</span> <span class=nc>JQueue</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=p>{</span>
    <span class=kd>private</span> <span class=n>Stack</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>stack1</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Stack</span><span class=o>&lt;&gt;</span><span class=p>();</span>
    <span class=kd>private</span> <span class=n>Stack</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>stack2</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Stack</span><span class=o>&lt;&gt;</span><span class=p>();</span>

    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>appendTail</span><span class=p>(</span><span class=n>T</span> <span class=n>element</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>stack1</span><span class=p>.</span><span class=na>push</span><span class=p>(</span><span class=n>element</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=kd>public</span> <span class=n>T</span> <span class=nf>deleteHead</span><span class=p>()</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>stack2</span><span class=p>.</span><span class=na>isEmpty</span><span class=p>())</span> <span class=p>{</span>
            <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>stack1</span><span class=p>.</span><span class=na>isEmpty</span><span class=p>())</span> <span class=p>{</span>
                <span class=n>stack2</span><span class=p>.</span><span class=na>push</span><span class=p>(</span><span class=n>stack1</span><span class=p>.</span><span class=na>pop</span><span class=p>());</span>
            <span class=p>}</span>
        <span class=p>}</span>

        <span class=k>if</span> <span class=p>(</span><span class=n>stack2</span><span class=p>.</span><span class=na>isEmpty</span><span class=p>())</span> <span class=p>{</span>
            <span class=k>return</span> <span class=kc>null</span><span class=p>;</span>
        <span class=p>}</span>

        <span class=k>return</span> <span class=n>stack2</span><span class=p>.</span><span class=na>pop</span><span class=p>();</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div> <p>插入元素的时候直接插入stack1即可。<br> 在删除队列的头部的时候，如果stack2为空，那么把stack1的<code>pop</code>依次<code>push</code>进stack2。这样操作后stack2中最上面就是最先进队列的，也就是我们要求的。</p> <div class="admonition info"> <p class=admonition-title>相关题目</p> <p>用两个队列实现一个栈。</p> </div> <div class=highlight><pre><span></span><code><span class=cm>/**</span>
<span class=cm> * 相关题目</span>
<span class=cm> * 用两个队列实现一个栈。</span>
<span class=cm> */</span>
<span class=kd>class</span> <span class=nc>JStack</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=kd>extends</span> <span class=n>Stack</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>{</span>
    <span class=kd>private</span> <span class=n>Queue</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>queue1</span> <span class=o>=</span> <span class=k>new</span> <span class=n>LinkedList</span><span class=o>&lt;&gt;</span><span class=p>();</span>
    <span class=kd>private</span> <span class=n>Queue</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>queue2</span> <span class=o>=</span> <span class=k>new</span> <span class=n>LinkedList</span><span class=o>&lt;&gt;</span><span class=p>();</span>

    <span class=nd>@Override</span>
    <span class=kd>public</span> <span class=n>T</span> <span class=nf>push</span><span class=p>(</span><span class=n>T</span> <span class=n>item</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>queue1</span><span class=p>.</span><span class=na>offer</span><span class=p>(</span><span class=n>item</span><span class=p>);</span>
        <span class=k>return</span> <span class=n>item</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=nd>@Override</span>
    <span class=kd>public</span> <span class=kd>synchronized</span> <span class=n>T</span> <span class=nf>pop</span><span class=p>()</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>queue1</span><span class=p>.</span><span class=na>isEmpty</span><span class=p>())</span> <span class=p>{</span>
            <span class=k>throw</span> <span class=k>new</span> <span class=n>EmptyStackException</span><span class=p>();</span>
        <span class=p>}</span>

        <span class=k>while</span> <span class=p>(</span><span class=n>queue1</span><span class=p>.</span><span class=na>size</span><span class=p>()</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>queue2</span><span class=p>.</span><span class=na>offer</span><span class=p>(</span><span class=n>queue1</span><span class=p>.</span><span class=na>poll</span><span class=p>());</span>
        <span class=p>}</span>

        <span class=n>T</span> <span class=n>item</span> <span class=o>=</span> <span class=n>queue1</span><span class=p>.</span><span class=na>poll</span><span class=p>();</span>

        <span class=n>Queue</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>tmp</span> <span class=o>=</span> <span class=n>queue1</span><span class=p>;</span>
        <span class=n>queue1</span> <span class=o>=</span> <span class=n>queue2</span><span class=p>;</span>
        <span class=n>queue2</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>;</span>

        <span class=k>return</span> <span class=n>item</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>Stack</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>stack</span> <span class=o>=</span> <span class=k>new</span> <span class=n>JStack</span><span class=o>&lt;&gt;</span><span class=p>();</span>

        <span class=n>stack</span><span class=p>.</span><span class=na>push</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
        <span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>stack</span><span class=p>.</span><span class=na>pop</span><span class=p>());</span>
        <span class=n>stack</span><span class=p>.</span><span class=na>push</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
        <span class=n>stack</span><span class=p>.</span><span class=na>push</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
        <span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>stack</span><span class=p>.</span><span class=na>pop</span><span class=p>());</span>
        <span class=n>stack</span><span class=p>.</span><span class=na>push</span><span class=p>(</span><span class=mi>4</span><span class=p>);</span>
        <span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>stack</span><span class=p>.</span><span class=na>pop</span><span class=p>());</span>
        <span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>stack</span><span class=p>.</span><span class=na>pop</span><span class=p>());</span>

        <span class=c1>// 输出 1 3 4 2</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div> <h2 id=6>6. 算法和数据操作<a class=headerlink href=#6 title="Permanent link">&para;</a></h2> <p>很多算法都可以用递归和循环两种不同的方式实现。通常基于递归的实现方式代码会比较简洁，但性能不如基于循环的实现方式。 </p> <p>通常排序和查找时算法的重点。我们应该重点掌握二分查找、归并排序和快速排序，能做到随时正确、完整地写出这些代码。 </p> <p>如果要求在二维数组上搜索路径，那么我们可以尝试用回溯法。通常回溯法很适合用递归的代码实现。只有限定不能用递归实现的时候，我们再考虑用栈来模拟递归的过程。<br> 如果要求的是某个问题的最优解，而且该问题可以分为多个子问题，那么我们可以尝试用动态规划。在用自上而下的递归思路去分析动态规划问题的时候，我们就会发现子问题之间存在重叠的更小的子问题。为了避免不必要的重复计算，我们用自下而上的循环代码来实现，也就是把子问题的最优解先计算出来并用数组保存下来，接下来基于子问题的解计算大问题的解。 如果在分解子问题的时候存在某个特殊的选择，如果采用这个特殊的选择将一定得到最优解，那么这意味着可能适用于贪婪算法。 </p> <p>位运算可以看成一类特殊的算法，它是把数字表示成二进制之后对0和1的操作。它只有与、或、异或、左移、右移5种位运算。 </p> <h3 id=61>6.1 递归和循环<a class=headerlink href=#61 title="Permanent link">&para;</a></h3> <p>如果我们需要重复地多次计算相同的问题，则通常可以选择用递归或者循环两种不同的方法。通常递归的代码会比较简洁。 </p> <p>虽然递归很简洁，但它同时也有显著的缺点。递归是函数调用自身，而函数调用时有时间和空间的消耗的，所以递归实现的效率不如循环。<br> 另外，递归中有可能很多计算都是重复的，从而对性能带来很大的负面影响。例如第10题“斐波那契数列”和第60题“n个骰子的点数”中，我们会分析递归和循环的性能区别。 </p> <p>通常应用动态规划解决问题时我们都是用递归的思路分析问题，但由于递归分解的子问题中存在大量的重复，因此我们总是采用自下而上的循环来实现代码。例如第14题“剪绳子”、第47题”礼物的最大价值”和第48题”最长不含重复数字的子字符串”中我们会详细讨论如何用递归分析问题并基于循环写代码。 </p> <p>除效率之外，递归还有可能引起更严重的问题：调用栈溢出。</p> <h4 id=611-10>6.1.1 (10)斐波那契数列<a class=headerlink href=#611-10 title="Permanent link">&para;</a></h4> <blockquote> <p>写一个函数，输入n，求斐波那契（Fibonacci）数列的第n项。</p> </blockquote> <p><strong>解法一：递归</strong></p> <div class=highlight><pre><span></span><code><span class=kd>private</span> <span class=kt>long</span> <span class=nf>Fibonacci_Solution1</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span>
        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
    <span class=k>else</span>
        <span class=k>return</span> <span class=n>Fibonacci_Solution1</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>Fibonacci_Solution1</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>2</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div> <p>这种解法有很严重的效率问题。我们以求解f(10)为例，可以得到下面的调用图。 </p> <p><img alt=基于递归求斐波那契数列第10项的调用过程 src=/assets/images/leetcode/fibonacci_recursive.png></p> <p><center>基于递归求斐波那契数列第10项的调用过程</center></p> <p>我们不难发现，在这棵树中有很多节点都是重复的，而且重复的节点数会随着n的增大而急剧增加。<br> 该算法时间复杂度是O(2^n) </p> <p><strong>解法二：循环</strong></p> <div class=highlight><pre><span></span><code><span class=kd>private</span> <span class=kt>long</span> <span class=nf>Fibonacci_Solution2</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span><span class=o>[]</span> <span class=n>results</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>};</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>&lt;</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=n>results</span><span class=o>[</span><span class=n>n</span><span class=o>]</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=n>results</span><span class=o>[</span><span class=mi>0</span><span class=o>]</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>b</span> <span class=o>=</span> <span class=n>results</span><span class=o>[</span><span class=mi>1</span><span class=o>]</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>

    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>result</span> <span class=o>=</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>;</span>
        <span class=n>a</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>
        <span class=n>b</span> <span class=o>=</span> <span class=n>result</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>result</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>该算法时间复杂度是O(n) </p> <p><strong>解法三：利用数学公式</strong></p> <div> <div class=MathJax_Preview> \begin{bmatrix}f(n) &amp; f(n-1) \\ f(n-1) &amp; f(n-2)\end{bmatrix}=\begin{bmatrix}1 &amp; 1 \\ 1 &amp; 0\end{bmatrix}^{n-1} </div> <script type="math/tex; mode=display">
\begin{bmatrix}f(n) & f(n-1) \\ f(n-1) & f(n-2)\end{bmatrix}=\begin{bmatrix}1 & 1 \\ 1 & 0\end{bmatrix}^{n-1}
</script> </div> <p>利用上面的公式，我们只需要求得矩阵<span><span class=MathJax_Preview>\begin{bmatrix}1 &amp; 1 \\ 1 &amp; 0\end{bmatrix}^{n-1}</span><script type=math/tex>\begin{bmatrix}1 & 1 \\ 1 & 0\end{bmatrix}^{n-1}</script></span>即可得到<span><span class=MathJax_Preview>f(n)</span><script type=math/tex>f(n)</script></span>。如果只是简单地从0开始循环，n次方仍然需要n次运算，其时间复杂度还是<span><span class=MathJax_Preview>O(n)</span><script type=math/tex>O(n)</script></span>，并不比前面的快。所以我们需要利用乘方的如下性质：</p> <div> <div class=MathJax_Preview> a^n=\begin{cases} a^{n/2} \cdot a^{n/2}, &amp; n为偶数 \\ a^{(n-1)/2} \cdot a^{(n-1)/2} \cdot a, &amp; n为奇数 \end{cases} </div> <script type="math/tex; mode=display">
a^n=\begin{cases} a^{n/2} \cdot a^{n/2}, & n为偶数 \\ a^{(n-1)/2} \cdot a^{(n-1)/2} \cdot a, & n为奇数 \end{cases}
</script> </div> <p>用上面的公式可以看出，我们想求<span><span class=MathJax_Preview>n</span><script type=math/tex>n</script></span>次方，就要先求<span><span class=MathJax_Preview>n/2</span><script type=math/tex>n/2</script></span>次方，在把<span><span class=MathJax_Preview>n/2</span><script type=math/tex>n/2</script></span>次方平方一下即可。这可以用递归的思路实现。 </p> <div class=highlight><pre><span></span><code><span class=kd>private</span> <span class=kd>static</span> <span class=kd>class</span> <span class=nc>Matrix2By2</span> <span class=p>{</span>
    <span class=kt>long</span> <span class=n>m_00</span><span class=p>;</span>
    <span class=kt>long</span> <span class=n>m_01</span><span class=p>;</span>
    <span class=kt>long</span> <span class=n>m_10</span><span class=p>;</span>
    <span class=kt>long</span> <span class=n>m_11</span><span class=p>;</span>

    <span class=n>Matrix2By2</span><span class=p>(</span><span class=kt>long</span> <span class=n>m_00</span><span class=p>,</span> <span class=kt>long</span> <span class=n>m_01</span><span class=p>,</span> <span class=kt>long</span> <span class=n>m_10</span><span class=p>,</span> <span class=kt>long</span> <span class=n>m_11</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>this</span><span class=p>.</span><span class=na>m_00</span> <span class=o>=</span> <span class=n>m_00</span><span class=p>;</span>
        <span class=k>this</span><span class=p>.</span><span class=na>m_01</span> <span class=o>=</span> <span class=n>m_01</span><span class=p>;</span>
        <span class=k>this</span><span class=p>.</span><span class=na>m_10</span> <span class=o>=</span> <span class=n>m_10</span><span class=p>;</span>
        <span class=k>this</span><span class=p>.</span><span class=na>m_11</span> <span class=o>=</span> <span class=n>m_11</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=kd>static</span> <span class=n>Matrix2By2</span> <span class=nf>matrixMultiply</span><span class=p>(</span><span class=n>Matrix2By2</span> <span class=n>matrix1</span><span class=p>,</span> <span class=n>Matrix2By2</span> <span class=n>matrix2</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=k>new</span> <span class=n>Matrix2By2</span><span class=p>(</span>
                <span class=n>matrix1</span><span class=p>.</span><span class=na>m_00</span> <span class=o>*</span> <span class=n>matrix2</span><span class=p>.</span><span class=na>m_00</span> <span class=o>+</span> <span class=n>matrix1</span><span class=p>.</span><span class=na>m_01</span> <span class=o>*</span> <span class=n>matrix2</span><span class=p>.</span><span class=na>m_10</span><span class=p>,</span>
                <span class=n>matrix1</span><span class=p>.</span><span class=na>m_00</span> <span class=o>*</span> <span class=n>matrix2</span><span class=p>.</span><span class=na>m_01</span> <span class=o>+</span> <span class=n>matrix1</span><span class=p>.</span><span class=na>m_01</span> <span class=o>*</span> <span class=n>matrix2</span><span class=p>.</span><span class=na>m_11</span><span class=p>,</span>
                <span class=n>matrix1</span><span class=p>.</span><span class=na>m_10</span> <span class=o>*</span> <span class=n>matrix2</span><span class=p>.</span><span class=na>m_00</span> <span class=o>+</span> <span class=n>matrix1</span><span class=p>.</span><span class=na>m_11</span> <span class=o>*</span> <span class=n>matrix2</span><span class=p>.</span><span class=na>m_10</span><span class=p>,</span>
                <span class=n>matrix1</span><span class=p>.</span><span class=na>m_10</span> <span class=o>*</span> <span class=n>matrix2</span><span class=p>.</span><span class=na>m_01</span> <span class=o>+</span> <span class=n>matrix1</span><span class=p>.</span><span class=na>m_11</span> <span class=o>*</span> <span class=n>matrix2</span><span class=p>.</span><span class=na>m_11</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=kd>static</span> <span class=n>Matrix2By2</span> <span class=nf>MatrixPower</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>Matrix2By2</span> <span class=n>matrix</span><span class=p>;</span>

        <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>matrix</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Matrix2By2</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
        <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>matrix</span> <span class=o>=</span> <span class=n>MatrixPower</span><span class=p>(</span><span class=n>n</span> <span class=o>/</span> <span class=mi>2</span><span class=p>);</span>
            <span class=n>matrix</span> <span class=o>=</span> <span class=n>matrixMultiply</span><span class=p>(</span><span class=n>matrix</span><span class=p>,</span> <span class=n>matrix</span><span class=p>);</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span> <span class=c1>// n % 2 == 1</span>
            <span class=n>matrix</span> <span class=o>=</span> <span class=n>MatrixPower</span><span class=p>((</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>);</span>
            <span class=n>matrix</span> <span class=o>=</span> <span class=n>matrixMultiply</span><span class=p>(</span><span class=n>matrix</span><span class=p>,</span> <span class=n>matrix</span><span class=p>);</span>
            <span class=n>matrix</span> <span class=o>=</span> <span class=n>matrixMultiply</span><span class=p>(</span><span class=n>matrix</span><span class=p>,</span> <span class=k>new</span> <span class=n>Matrix2By2</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>));</span>
        <span class=p>}</span>

        <span class=k>return</span> <span class=n>matrix</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=kd>private</span> <span class=kt>long</span> <span class=nf>Fibonacci_Solution3</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span><span class=o>[]</span> <span class=n>results</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>};</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>&lt;</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=n>results</span><span class=o>[</span><span class=n>n</span><span class=o>]</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=n>Matrix2By2</span> <span class=n>matrix2By2</span> <span class=o>=</span> <span class=n>Matrix2By2</span><span class=p>.</span><span class=na>MatrixPower</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
    <span class=k>return</span> <span class=n>matrix2By2</span><span class=p>.</span><span class=na>m_00</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>该算法时间复杂度是<span><span class=MathJax_Preview>O(logn)</span><script type=math/tex>O(logn)</script></span>，在第16题”数值的整数次方”中会讨论这种算法。 </p> <div class="admonition info"> <p class=admonition-title>相关题目</p> <p>青蛙跳台阶问题：一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个n级的台阶总共有多少种跳法。 </p> </div> <div class="admonition info"> <p class=admonition-title>相关题目</p> <p>我们可以用2x1的小矩形横着或者竖着去覆盖更大的矩形。请问用8个2x1的小矩形无重叠地覆盖一个2x8的大矩形有多少种覆盖方法。<br> <span><span class=MathJax_Preview>f(8)=f(7)+f(6)</span><script type=math/tex>f(8)=f(7)+f(6)</script></span><br> <img alt=一个2x1的矩形和2x8的矩形 src=/assets/images/leetcode/fibonacci_relate_problem.png><br> <center>一个2x1的矩形和2x8的矩形</center></p> </div> <p>上面两个题目都是斐波那契数列的例子。</p> <h3 id=62>6.2 查找和排序<a class=headerlink href=#62 title="Permanent link">&para;</a></h3> <p>查找和排序都是在程序设计中经常用到的算法。查找相对而言较为简单，不外乎顺序查找、二分查找、哈希表查找和二叉排序树查找。</p> <p><strong>小提示</strong> </p> <p>如果要求在排序的数组或者部分排序的数组中查找一个数字或统计某个数字出现的次数，我们都可以尝试用二分查找算法。</p> <p>哈希表和二叉排序树查找的重点在于考察对应的数据结构而不是算法。哈希表最主要的优点是能够在O(1)时间内查找某一元素，是效率最高的查找方式；但其缺点是需要额外的空间实现哈希表。例如第50题“第一个只出现一次的字符”就是利用哈希表的特性来实现高效查找的。 </p> <p>与二叉排序树查找算法对应的数据结构是二叉搜索树。具体例子为第33题“二叉搜索树的后序遍历序列”和第36题“二叉搜索树与双向链表”。 </p> <p>排序与查找要复杂一点。我们需要知道插入排序、冒泡排序、归并排序、快速排序等不同算法的优劣，能够从额外空间消耗、平均时间复杂度和最差时间复杂度等方面去比较它们的优缺点。特别注意的是我们需要写出快速排序的代码。</p> <p>实现快速排序算法的关键在于先在数组中选择一个数字，接下来把数组中的数字分为两部分，比选择的数字小的数字移到数组左边，比选择的数字大的移到数组右边。接下来可以用递归的思路分别对每次选中的数字的左右两边排序 <div class=highlight><pre><span></span><code><span class=kd>public</span> <span class=kd>class</span> <span class=nc>QuickSort</span> <span class=p>{</span>

    <span class=kd>private</span> <span class=kd>static</span> <span class=kt>int</span> <span class=nf>partition</span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>numbers</span><span class=p>,</span> <span class=kt>int</span> <span class=n>lo</span><span class=p>,</span> <span class=kt>int</span> <span class=n>hi</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>numbers</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>numbers</span><span class=p>.</span><span class=na>length</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>lo</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>hi</span> <span class=o>&gt;=</span> <span class=n>numbers</span><span class=p>.</span><span class=na>length</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalArgumentException</span><span class=p>(</span><span class=s>&quot;Invalid params&quot;</span><span class=p>);</span>
        <span class=p>}</span>

        <span class=kt>int</span> <span class=n>key</span> <span class=o>=</span> <span class=n>numbers</span><span class=o>[</span><span class=n>lo</span><span class=o>]</span><span class=p>;</span>

        <span class=k>while</span> <span class=p>(</span><span class=n>lo</span> <span class=o>&lt;</span> <span class=n>hi</span><span class=p>)</span> <span class=p>{</span>
            <span class=c1>// 比选择的数字小的数字移到数组左边</span>
            <span class=k>while</span> <span class=p>(</span><span class=n>numbers</span><span class=o>[</span><span class=n>hi</span><span class=o>]</span> <span class=o>&gt;=</span> <span class=n>key</span> <span class=o>&amp;&amp;</span> <span class=n>hi</span> <span class=o>&gt;</span> <span class=n>lo</span><span class=p>)</span> <span class=p>{</span>
                <span class=n>hi</span><span class=o>--</span><span class=p>;</span>
            <span class=p>}</span>
            <span class=n>numbers</span><span class=o>[</span><span class=n>lo</span><span class=o>]</span> <span class=o>=</span> <span class=n>numbers</span><span class=o>[</span><span class=n>hi</span><span class=o>]</span><span class=p>;</span>

            <span class=c1>// 比选择的数字大的移到数组右边</span>
            <span class=k>while</span> <span class=p>(</span><span class=n>numbers</span><span class=o>[</span><span class=n>lo</span><span class=o>]</span> <span class=o>&lt;=</span> <span class=n>key</span> <span class=o>&amp;&amp;</span> <span class=n>hi</span> <span class=o>&gt;</span> <span class=n>lo</span><span class=p>)</span> <span class=p>{</span>
                <span class=n>lo</span><span class=o>++</span><span class=p>;</span>
            <span class=p>}</span>
            <span class=n>numbers</span><span class=o>[</span><span class=n>hi</span><span class=o>]</span> <span class=o>=</span> <span class=n>numbers</span><span class=o>[</span><span class=n>lo</span><span class=o>]</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=n>numbers</span><span class=o>[</span><span class=n>hi</span><span class=o>]</span> <span class=o>=</span> <span class=n>key</span><span class=p>;</span>

        <span class=k>return</span> <span class=n>hi</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>sort</span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>numbers</span><span class=p>,</span> <span class=kt>int</span> <span class=n>lo</span><span class=p>,</span> <span class=kt>int</span> <span class=n>hi</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>lo</span> <span class=o>&gt;=</span> <span class=n>hi</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>return</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=kt>int</span> <span class=n>index</span> <span class=o>=</span> <span class=n>partition</span><span class=p>(</span><span class=n>numbers</span><span class=p>,</span> <span class=n>lo</span><span class=p>,</span> <span class=n>hi</span><span class=p>);</span>
        <span class=n>sort</span><span class=p>(</span><span class=n>numbers</span><span class=p>,</span> <span class=n>lo</span><span class=p>,</span> <span class=n>index</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
        <span class=n>sort</span><span class=p>(</span><span class=n>numbers</span><span class=p>,</span> <span class=n>index</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>hi</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=p>)</span> <span class=p>{</span>
        <span class=kt>int</span><span class=o>[]</span> <span class=n>numbers</span> <span class=o>=</span> <span class=p>{</span><span class=mi>4</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=mi>8</span><span class=p>};</span>
        <span class=n>sort</span><span class=p>(</span><span class=n>numbers</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>numbers</span><span class=p>.</span><span class=na>length</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>

        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>num</span> <span class=p>:</span> <span class=n>numbers</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>print</span><span class=p>(</span><span class=s>&quot; &quot;</span> <span class=o>+</span> <span class=n>num</span><span class=p>);</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div></p> <p>上面的<code>partition</code>除了可以用在快速排序中，还可以用来实现在长度为n的数组中查找第k大的数字，第39题“数组中出现次数超过一半的数字”和第40题“最小的k个数”都可以用这个函数来解决。</p> <p><strong>插入排序</strong><br> <div class=highlight><pre><span></span><code><span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>sort</span><span class=p>(</span><span class=n>Comparable</span><span class=o>[]</span> <span class=n>a</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// 将a[]升序排列</span>
    <span class=kt>int</span> <span class=n>N</span> <span class=o>=</span> <span class=n>a</span><span class=p>.</span><span class=na>length</span><span class=p>;</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span> <span class=n>j</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>AbsSort</span><span class=p>.</span><span class=na>less</span><span class=p>(</span><span class=n>a</span><span class=o>[</span><span class=n>j</span><span class=o>]</span><span class=p>,</span> <span class=n>a</span><span class=o>[</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=o>]</span><span class=p>);</span> <span class=n>j</span><span class=o>--</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>AbsSort</span><span class=p>.</span><span class=na>exch</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div></p> <p><strong>冒泡排序</strong><br> <div class=highlight><pre><span></span><code><span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>sort</span><span class=p>(</span><span class=n>Comparable</span><span class=o>[]</span> <span class=n>a</span><span class=p>){</span>
    <span class=c1>// 将a[]升序排列</span>
    <span class=kt>int</span> <span class=n>N</span> <span class=o>=</span> <span class=n>a</span><span class=p>.</span><span class=na>length</span><span class=p>;</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>N</span> <span class=o>-</span> <span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>AbsSort</span><span class=p>.</span><span class=na>less</span><span class=p>(</span><span class=n>a</span><span class=o>[</span><span class=n>j</span><span class=o>]</span><span class=p>,</span> <span class=n>a</span><span class=o>[</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=o>]</span><span class=p>))</span> <span class=p>{</span>
                <span class=n>AbsSort</span><span class=p>.</span><span class=na>exch</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>);</span>
            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div></p> <p><strong>自顶向下归并排序</strong><br> <div class=highlight><pre><span></span><code><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Merge</span> <span class=kd>extends</span> <span class=n>AbsSort</span><span class=p>{</span>
    <span class=kd>private</span> <span class=kd>static</span> <span class=n>Comparable</span><span class=o>[]</span> <span class=n>aux</span><span class=p>;</span>        <span class=c1>// 归并所需的辅助数组</span>

    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>sort</span><span class=p>(</span><span class=n>Comparable</span><span class=o>[]</span> <span class=n>a</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>aux</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Comparable</span><span class=o>[</span><span class=n>a</span><span class=p>.</span><span class=na>length</span><span class=o>]</span><span class=p>;</span>
        <span class=n>sort</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>a</span><span class=p>.</span><span class=na>length</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=kd>private</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>sort</span><span class=p>(</span><span class=n>Comparable</span><span class=o>[]</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>lo</span><span class=p>,</span> <span class=kt>int</span> <span class=n>hi</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>hi</span> <span class=o>&lt;=</span> <span class=n>lo</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span>
        <span class=kt>int</span> <span class=n>mid</span> <span class=o>=</span> <span class=n>lo</span> <span class=o>+</span> <span class=p>(</span><span class=n>hi</span> <span class=o>-</span> <span class=n>lo</span><span class=p>)</span><span class=o>/</span><span class=mi>2</span><span class=p>;</span>
        <span class=n>sort</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>lo</span><span class=p>,</span> <span class=n>mid</span><span class=p>);</span>
        <span class=n>sort</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>mid</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>hi</span><span class=p>);</span>
        <span class=n>merge</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>lo</span><span class=p>,</span> <span class=n>mid</span><span class=p>,</span> <span class=n>hi</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=cm>/**</span>
<span class=cm>     * 原地归并</span>
<span class=cm>     */</span>
    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>merge</span><span class=p>(</span><span class=n>Comparable</span><span class=o>[]</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>lo</span><span class=p>,</span> <span class=kt>int</span> <span class=n>mid</span><span class=p>,</span> <span class=kt>int</span> <span class=n>hi</span><span class=p>)</span> <span class=p>{</span>
        <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>lo</span><span class=p>,</span> <span class=n>j</span> <span class=o>=</span> <span class=n>mid</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span>

        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=n>lo</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;=</span> <span class=n>hi</span><span class=p>;</span> <span class=n>k</span><span class=o>++</span><span class=p>)</span>
            <span class=n>aux</span><span class=o>[</span><span class=n>k</span><span class=o>]</span> <span class=o>=</span> <span class=n>a</span><span class=o>[</span><span class=n>k</span><span class=o>]</span><span class=p>;</span>

        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=n>lo</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;=</span> <span class=n>hi</span><span class=p>;</span> <span class=n>k</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>&gt;</span> <span class=n>mid</span><span class=p>)</span>                        <span class=n>a</span><span class=o>[</span><span class=n>k</span><span class=o>]</span> <span class=o>=</span> <span class=n>aux</span><span class=o>[</span><span class=n>j</span><span class=o>++]</span><span class=p>;</span>
            <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>j</span> <span class=o>&gt;</span> <span class=n>hi</span><span class=p>)</span>                    <span class=n>a</span><span class=o>[</span><span class=n>k</span><span class=o>]</span> <span class=o>=</span> <span class=n>aux</span><span class=o>[</span><span class=n>i</span><span class=o>++]</span><span class=p>;</span>
            <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>less</span><span class=p>(</span><span class=n>aux</span><span class=o>[</span><span class=n>j</span><span class=o>]</span><span class=p>,</span> <span class=n>aux</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>))</span>      <span class=n>a</span><span class=o>[</span><span class=n>k</span><span class=o>]</span> <span class=o>=</span> <span class=n>aux</span><span class=o>[</span><span class=n>j</span><span class=o>++]</span><span class=p>;</span>
            <span class=k>else</span>                                <span class=n>a</span><span class=o>[</span><span class=n>k</span><span class=o>]</span> <span class=o>=</span> <span class=n>aux</span><span class=o>[</span><span class=n>i</span><span class=o>++]</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div></p> <p><strong>自底向上的归并排序</strong><br> <div class=highlight><pre><span></span><code><span class=kd>public</span> <span class=kd>class</span> <span class=nc>MergeBU</span> <span class=kd>extends</span> <span class=n>AbsSort</span><span class=p>{</span>
    <span class=kd>private</span> <span class=kd>static</span>  <span class=n>Comparable</span><span class=o>[]</span> <span class=n>aux</span><span class=p>;</span>

    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>sort</span><span class=p>(</span><span class=n>Comparable</span><span class=o>[]</span> <span class=n>a</span><span class=p>)</span> <span class=p>{</span>
        <span class=kt>int</span> <span class=n>N</span> <span class=o>=</span> <span class=n>a</span><span class=p>.</span><span class=na>length</span><span class=p>;</span>
        <span class=n>aux</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Comparable</span><span class=o>[</span><span class=n>N</span><span class=o>]</span><span class=p>;</span>
        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>sz</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>sz</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>sz</span> <span class=o>=</span> <span class=n>sz</span><span class=o>+</span><span class=n>sz</span><span class=p>)</span>                    <span class=c1>// sz子数组大小</span>
            <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>lo</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>lo</span> <span class=o>&lt;</span> <span class=n>N</span><span class=o>-</span><span class=n>sz</span><span class=p>;</span> <span class=n>lo</span> <span class=o>+=</span> <span class=n>sz</span><span class=o>+</span><span class=n>sz</span><span class=p>)</span>            <span class=c1>// lo:子数组索引</span>
                <span class=n>merge</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>lo</span><span class=p>,</span> <span class=n>lo</span><span class=o>+</span><span class=n>sz</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>Math</span><span class=p>.</span><span class=na>min</span><span class=p>(</span><span class=n>lo</span><span class=o>+</span><span class=n>sz</span><span class=o>+</span><span class=n>sz</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>N</span><span class=o>-</span><span class=mi>1</span><span class=p>));</span>
    <span class=p>}</span>

    <span class=cm>/**</span>
<span class=cm>     * 原地归并</span>
<span class=cm>     */</span>
    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>merge</span><span class=p>(</span><span class=n>Comparable</span><span class=o>[]</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>lo</span><span class=p>,</span> <span class=kt>int</span> <span class=n>mid</span><span class=p>,</span> <span class=kt>int</span> <span class=n>hi</span><span class=p>)</span> <span class=p>{</span>
        <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>lo</span><span class=p>,</span> <span class=n>j</span> <span class=o>=</span> <span class=n>mid</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span>

        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=n>lo</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;=</span> <span class=n>hi</span><span class=p>;</span> <span class=n>k</span><span class=o>++</span><span class=p>)</span>
            <span class=n>aux</span><span class=o>[</span><span class=n>k</span><span class=o>]</span> <span class=o>=</span> <span class=n>a</span><span class=o>[</span><span class=n>k</span><span class=o>]</span><span class=p>;</span>

        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=n>lo</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;=</span> <span class=n>hi</span><span class=p>;</span> <span class=n>k</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>&gt;</span> <span class=n>mid</span><span class=p>)</span>                        <span class=n>a</span><span class=o>[</span><span class=n>k</span><span class=o>]</span> <span class=o>=</span> <span class=n>aux</span><span class=o>[</span><span class=n>j</span><span class=o>++]</span><span class=p>;</span>
            <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>j</span> <span class=o>&gt;</span> <span class=n>hi</span><span class=p>)</span>                    <span class=n>a</span><span class=o>[</span><span class=n>k</span><span class=o>]</span> <span class=o>=</span> <span class=n>aux</span><span class=o>[</span><span class=n>i</span><span class=o>++]</span><span class=p>;</span>
            <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>less</span><span class=p>(</span><span class=n>aux</span><span class=o>[</span><span class=n>j</span><span class=o>]</span><span class=p>,</span> <span class=n>aux</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>))</span>      <span class=n>a</span><span class=o>[</span><span class=n>k</span><span class=o>]</span> <span class=o>=</span> <span class=n>aux</span><span class=o>[</span><span class=n>j</span><span class=o>++]</span><span class=p>;</span>
            <span class=k>else</span>                                <span class=n>a</span><span class=o>[</span><span class=n>k</span><span class=o>]</span> <span class=o>=</span> <span class=n>aux</span><span class=o>[</span><span class=n>i</span><span class=o>++]</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div></p> <p>以下是常见排序算法的总结：</p> <table> <thead> <tr> <th>排序方法</th> <th>时间复杂度（平均）</th> <th>时间复杂度（最坏)</th> <th>时间复杂度（最好)</th> <th>空间复杂度</th> <th>稳定性</th> </tr> </thead> <tbody> <tr> <td>冒泡排序</td> <td><span><span class=MathJax_Preview>O(n^2)</span><script type=math/tex>O(n^2)</script></span></td> <td><span><span class=MathJax_Preview>O(n^2)</span><script type=math/tex>O(n^2)</script></span></td> <td><span><span class=MathJax_Preview>O(n)</span><script type=math/tex>O(n)</script></span></td> <td><span><span class=MathJax_Preview>O(1)</span><script type=math/tex>O(1)</script></span></td> <td>稳定</td> </tr> <tr> <td>简单选择排序</td> <td><span><span class=MathJax_Preview>O(n^2)</span><script type=math/tex>O(n^2)</script></span></td> <td><span><span class=MathJax_Preview>O(n^2)</span><script type=math/tex>O(n^2)</script></span></td> <td><span><span class=MathJax_Preview>O(n^2)</span><script type=math/tex>O(n^2)</script></span></td> <td><span><span class=MathJax_Preview>O(1)</span><script type=math/tex>O(1)</script></span></td> <td>不稳定</td> </tr> <tr> <td>直接插入排序</td> <td><span><span class=MathJax_Preview>O(n^2)</span><script type=math/tex>O(n^2)</script></span></td> <td><span><span class=MathJax_Preview>O(n^2)</span><script type=math/tex>O(n^2)</script></span></td> <td><span><span class=MathJax_Preview>O(n)</span><script type=math/tex>O(n)</script></span></td> <td><span><span class=MathJax_Preview>O(1)</span><script type=math/tex>O(1)</script></span></td> <td>稳定</td> </tr> <tr> <td>希尔排序</td> <td><span><span class=MathJax_Preview>O(n^{4/3})</span><script type=math/tex>O(n^{4/3})</script></span></td> <td><span><span class=MathJax_Preview>O(n^2)</span><script type=math/tex>O(n^2)</script></span></td> <td><span><span class=MathJax_Preview>O(n)</span><script type=math/tex>O(n)</script></span></td> <td><span><span class=MathJax_Preview>O(1)</span><script type=math/tex>O(1)</script></span></td> <td>不稳定</td> </tr> <tr> <td>堆排序</td> <td><span><span class=MathJax_Preview>O(nlog n)</span><script type=math/tex>O(nlog n)</script></span></td> <td><span><span class=MathJax_Preview>O(nlog n)</span><script type=math/tex>O(nlog n)</script></span></td> <td><span><span class=MathJax_Preview>O(nlog n)</span><script type=math/tex>O(nlog n)</script></span></td> <td><span><span class=MathJax_Preview>O(1)</span><script type=math/tex>O(1)</script></span></td> <td>不稳定</td> </tr> <tr> <td>快速排序</td> <td><span><span class=MathJax_Preview>O(nlog n)</span><script type=math/tex>O(nlog n)</script></span></td> <td><span><span class=MathJax_Preview>O(n^2)</span><script type=math/tex>O(n^2)</script></span></td> <td><span><span class=MathJax_Preview>O(nlog n)</span><script type=math/tex>O(nlog n)</script></span></td> <td><span><span class=MathJax_Preview>O(log n)</span><script type=math/tex>O(log n)</script></span></td> <td>不稳定</td> </tr> <tr> <td>归并排序</td> <td><span><span class=MathJax_Preview>O(nlog n)</span><script type=math/tex>O(nlog n)</script></span></td> <td><span><span class=MathJax_Preview>O(nlog n)</span><script type=math/tex>O(nlog n)</script></span></td> <td><span><span class=MathJax_Preview>O(nlog n)</span><script type=math/tex>O(nlog n)</script></span></td> <td><span><span class=MathJax_Preview>O(n)</span><script type=math/tex>O(n)</script></span></td> <td>稳定</td> </tr> </tbody> </table> <p><a href=https://en.wikipedia.org/wiki/Sorting_algorithm>Sorting algorithm</a></p> <h4 id=621-11>6.2.1 (11)旋转数组的最小数字<a class=headerlink href=#621-11 title="Permanent link">&para;</a></h4> <blockquote> <p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3, 4, 5, 1, 2}为{1, 2, 3, 4, 5}的一个旋转，该数组的最小值为1。 </p> </blockquote> <p>本题与<a href=/leetcode/leetcode81-90/#81-search-in-rotated-sorted-array-ii>LC-81-Search in Rotated Sorted Array II</a>比较类似；且前者要找具体的值，本题找最小值。但是具体思维可以借鉴，这样处理可以一般情况。</p> <p>考虑到以下特殊情况：当下标为lo和hi的两个数字相同的情况，当lo，mid，hi对应的数字都相等时，上面的算法认为此时最小的数字位于中间数字的前面。这可不一定。比如数组{1, 0, 1, 1, 1}和数组{1, 1, 1, 0, 1}都是增序数列{0, 1, 1, 1, 1}的一个旋转数组。在这两个数组中最小数字为别位于左右半区。所以上面的算法一定会失败一种情况。因此，当lo，mid，hi对应的数字都相等时，我们必须采用顺序查找。</p> <p>具体算法如下：</p> <div class=highlight><pre><span></span><code><span class=kt>int</span> <span class=nf>min</span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>numbers</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>numbers</span> <span class=o>==</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalArgumentException</span><span class=p>(</span><span class=s>&quot;Invalid params&quot;</span><span class=p>);</span>
    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>numbers</span><span class=p>.</span><span class=na>length</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=n>numbers</span><span class=o>[</span><span class=mi>0</span><span class=o>]</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=kt>int</span> <span class=n>lo</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>hi</span> <span class=o>=</span> <span class=n>numbers</span><span class=p>.</span><span class=na>length</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>

    <span class=k>while</span> <span class=p>(</span><span class=n>lo</span> <span class=o>&lt;</span> <span class=n>hi</span><span class=p>)</span> <span class=p>{</span>
        <span class=kt>int</span> <span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>lo</span> <span class=o>+</span> <span class=n>hi</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=p>;</span>

        <span class=c1>// 当lo，mid，hi对应的数字都相等时，采用顺序查找</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>numbers</span><span class=o>[</span><span class=n>lo</span><span class=o>]</span> <span class=o>==</span> <span class=n>numbers</span><span class=o>[</span><span class=n>mid</span><span class=o>]</span> <span class=o>&amp;&amp;</span>
                <span class=n>numbers</span><span class=o>[</span><span class=n>mid</span><span class=o>]</span> <span class=o>==</span> <span class=n>numbers</span><span class=o>[</span><span class=n>hi</span><span class=o>]</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>return</span> <span class=n>minInOrder</span><span class=p>(</span><span class=n>numbers</span><span class=p>,</span> <span class=n>lo</span><span class=p>,</span> <span class=n>hi</span><span class=p>);</span>
        <span class=p>}</span>

        <span class=k>if</span> <span class=p>(</span><span class=n>numbers</span><span class=o>[</span><span class=n>mid</span><span class=o>]</span> <span class=o>&gt;</span> <span class=n>numbers</span><span class=o>[</span><span class=n>hi</span><span class=o>]</span><span class=p>)</span> <span class=p>{</span>
            <span class=c1>// a[mid]&gt;a[hi]，说明最小值在右边，且肯定不会是a[mid]，因为a[mid]&gt;a[hi]&gt;=min</span>
            <span class=n>lo</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=c1>// a[mid]&lt;=a[hi]，最小值可能是mid，所以不能漏掉</span>
            <span class=n>hi</span> <span class=o>=</span> <span class=n>mid</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>numbers</span><span class=o>[</span><span class=n>hi</span><span class=o>]</span><span class=p>;</span>
<span class=p>}</span>

<span class=kd>private</span> <span class=kt>int</span> <span class=nf>minInOrder</span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>numbers</span><span class=p>,</span> <span class=kt>int</span> <span class=n>start</span><span class=p>,</span> <span class=kt>int</span> <span class=n>end</span><span class=p>)</span> <span class=p>{</span>

    <span class=kt>int</span> <span class=n>min</span> <span class=o>=</span> <span class=n>numbers</span><span class=o>[</span><span class=n>start</span><span class=o>]</span><span class=p>;</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>start</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>end</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>numbers</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>&lt;</span> <span class=n>min</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>min</span> <span class=o>=</span> <span class=n>numbers</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>;</span>
            <span class=k>return</span> <span class=n>min</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>min</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <h3 id=63>6.3 回溯法<a class=headerlink href=#63 title="Permanent link">&para;</a></h3> <p>回溯法可以看成蛮力法的升级版，它从解决问题每一步的所有可能选项里系统地选择出一个可行的解决方案。回溯法非常适合由多个步骤组成的问题，并且每个步骤都有很多选项。当我们在某一步选择了其中一个选项时，就进入下一步，然后又面临新的选项。我们就这样重复选择，直至到达最终的状态。<br> 用回溯法解决的问题的所有选项可以形象地用树状结构表示。在某一步有n个可能的选项，那么该步骤可以看成是树状结构中的一个节点，每个选项看成树中节点连接线，经过这些连接线到达该节点的n个子节点。树的叶节点对应着终结状态。如果在叶节点的状态满足题目的约束条件，那么我们找到了一个可行的解决方案。<br> 如果在叶节点的状态不满足约束条件，那么只好回溯到它的上一个节点在尝试其他的选项。如果上一个节点所有可能的选项都已经试过，并且不能到达满足约束条件的终结状态，则再次回溯到上一个节点。如果所有节点的所有选项都已经尝试过仍然不能到达满足约束条件的终结状态，则该问题无解。<br> 通常回溯法适合用递归实现代码。当我们到达某一个节点时，尝试所有可能的选项并在满足条件的前提下递归地抵达下一个节点。 </p> <h4 id=631-12>6.3.1 (12)矩阵中的路径<a class=headerlink href=#631-12 title="Permanent link">&para;</a></h4> <blockquote> <p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用下划线标出）。但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。 </p> </blockquote> <div> <div class=MathJax_Preview> A \underline{B} T G \\ C \underline{F} \underline{C} S \\ J D \underline{E} H </div> <script type="math/tex; mode=display">
A \underline{B} T G \\ C \underline{F} \underline{C} S \\ J D \underline{E} H
</script> </div> <p>此题同<a href=/leetcode/leetcode71-80/#79-word-search>LC-79-Word Search</a></p> <p>这是一个可以用回溯法解决的典型题。首先，在矩阵中任选一个格子ch作为路径的起点。如果路径上第i个字符刚好是ch，那么到相邻的格子寻找路径上的第i+1个字符。除矩阵边界上的格子之外，其他格子都有4个相邻的格子。重复这个过程，直到路径上的所有字符都在矩阵中找到相应的位置。<br> 由于回溯法的递归特性，路径可以看成一个栈。当在矩阵中定位了路径中前n个字符的位置之后，在与第n个字符对应的格子的周围都没有找到第n+1个字符，这时候只好在路径上回到第n-1的字符，重新定位第n个字符。<br> 由于路径不能重复进入矩阵的格子，所以还需要定义和字符矩阵大小一样的布尔值矩阵，用来识别路径是否已经进入了某个格子。 </p> <div class=highlight><pre><span></span><code><span class=kd>private</span> <span class=kt>int</span> <span class=n>pathLength</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>

<span class=kd>private</span> <span class=kt>boolean</span> <span class=nf>hasPath</span><span class=p>(</span><span class=n>String</span> <span class=n>matrix</span><span class=p>,</span> <span class=kt>int</span> <span class=n>rows</span><span class=p>,</span> <span class=kt>int</span> <span class=n>cols</span><span class=p>,</span> <span class=n>String</span> <span class=n>str</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>matrix</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>matrix</span><span class=p>.</span><span class=na>length</span><span class=p>()</span> <span class=o>!=</span> <span class=n>rows</span> <span class=o>*</span> <span class=n>cols</span> <span class=o>||</span> <span class=n>str</span> <span class=o>==</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=kc>false</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=kt>boolean</span><span class=o>[]</span> <span class=n>visited</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>boolean</span><span class=o>[</span><span class=n>matrix</span><span class=p>.</span><span class=na>length</span><span class=p>()</span><span class=o>]</span><span class=p>;</span>

    <span class=n>pathLength</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>

    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>row</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>row</span> <span class=o>&lt;</span> <span class=n>rows</span><span class=p>;</span> <span class=n>row</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>col</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>col</span> <span class=o>&lt;</span> <span class=n>cols</span><span class=p>;</span> <span class=n>col</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>hasPathInner</span><span class=p>(</span><span class=n>matrix</span><span class=p>,</span> <span class=n>rows</span><span class=p>,</span> <span class=n>cols</span><span class=p>,</span> <span class=n>row</span><span class=p>,</span> <span class=n>col</span><span class=p>,</span> <span class=n>str</span><span class=p>,</span> <span class=n>visited</span><span class=p>))</span> <span class=p>{</span>
                <span class=k>return</span> <span class=kc>true</span><span class=p>;</span>
            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=kc>false</span><span class=p>;</span>
<span class=p>}</span>

<span class=kd>private</span> <span class=kt>boolean</span> <span class=nf>hasPathInner</span><span class=p>(</span>
        <span class=n>String</span> <span class=n>matrix</span><span class=p>,</span> <span class=kt>int</span> <span class=n>rows</span><span class=p>,</span> <span class=kt>int</span> <span class=n>cols</span><span class=p>,</span> <span class=kt>int</span> <span class=n>row</span><span class=p>,</span> <span class=kt>int</span> <span class=n>col</span><span class=p>,</span> <span class=n>String</span> <span class=n>str</span><span class=p>,</span> <span class=kt>boolean</span><span class=o>[]</span> <span class=n>visited</span>
<span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>pathLength</span> <span class=o>==</span> <span class=n>str</span><span class=p>.</span><span class=na>length</span><span class=p>())</span> <span class=p>{</span>
        <span class=k>return</span> <span class=kc>true</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=kt>boolean</span> <span class=n>hasPath</span> <span class=o>=</span> <span class=kc>false</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>row</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>row</span> <span class=o>&lt;</span> <span class=n>rows</span> <span class=o>&amp;&amp;</span> <span class=n>col</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>col</span> <span class=o>&lt;</span> <span class=n>cols</span>
        <span class=o>&amp;&amp;</span> <span class=n>matrix</span><span class=p>.</span><span class=na>charAt</span><span class=p>(</span><span class=n>row</span> <span class=o>*</span> <span class=n>cols</span> <span class=o>+</span> <span class=n>col</span><span class=p>)</span> <span class=o>==</span> <span class=n>str</span><span class=p>.</span><span class=na>charAt</span><span class=p>(</span><span class=n>pathLength</span><span class=p>)</span>
        <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>visited</span><span class=o>[</span><span class=n>row</span> <span class=o>*</span> <span class=n>cols</span> <span class=o>+</span> <span class=n>col</span><span class=o>]</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>pathLength</span><span class=o>++</span><span class=p>;</span>

        <span class=n>visited</span><span class=o>[</span><span class=n>row</span> <span class=o>*</span> <span class=n>cols</span> <span class=o>+</span> <span class=n>col</span><span class=o>]</span> <span class=o>=</span> <span class=kc>true</span><span class=p>;</span>

        <span class=n>hasPath</span> <span class=o>=</span> <span class=n>hasPathInner</span><span class=p>(</span><span class=n>matrix</span><span class=p>,</span> <span class=n>rows</span><span class=p>,</span> <span class=n>cols</span><span class=p>,</span> <span class=n>row</span><span class=p>,</span> <span class=n>col</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span>
                <span class=n>str</span><span class=p>,</span> <span class=n>visited</span><span class=p>)</span>
                <span class=o>||</span> <span class=n>hasPathInner</span><span class=p>(</span><span class=n>matrix</span><span class=p>,</span> <span class=n>rows</span><span class=p>,</span> <span class=n>cols</span><span class=p>,</span> <span class=n>row</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=n>col</span><span class=p>,</span>
                <span class=n>str</span><span class=p>,</span> <span class=n>visited</span><span class=p>)</span>
                <span class=o>||</span> <span class=n>hasPathInner</span><span class=p>(</span><span class=n>matrix</span><span class=p>,</span> <span class=n>rows</span><span class=p>,</span> <span class=n>cols</span><span class=p>,</span> <span class=n>row</span><span class=p>,</span> <span class=n>col</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span>
                <span class=n>str</span><span class=p>,</span> <span class=n>visited</span><span class=p>)</span>
                <span class=o>||</span> <span class=n>hasPathInner</span><span class=p>(</span><span class=n>matrix</span><span class=p>,</span> <span class=n>rows</span><span class=p>,</span> <span class=n>cols</span><span class=p>,</span> <span class=n>row</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>col</span><span class=p>,</span>
                <span class=n>str</span><span class=p>,</span> <span class=n>visited</span><span class=p>);</span>

        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>hasPath</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>pathLength</span><span class=o>--</span><span class=p>;</span>
            <span class=n>visited</span><span class=o>[</span><span class=n>row</span> <span class=o>*</span> <span class=n>cols</span> <span class=o>+</span> <span class=n>col</span><span class=o>]</span> <span class=o>=</span> <span class=kc>false</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>hasPath</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <h4 id=632-13>6.3.2 (13)机器人的运动范围<a class=headerlink href=#632-13 title="Permanent link">&para;</a></h4> <blockquote> <p>地上有一个m行n列的方格。一个机器人从坐标(0, 0)的格子开始移动，它每一次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格(35, 37)，因为3+5+3+7=18。但它不能进入方格(35, 38)，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p> </blockquote> <p>和前面的题目类似，这个方格也可以看成<span><span class=MathJax_Preview>m\times{n}</span><script type=math/tex>m\times{n}</script></span>的矩阵。同样，在这个矩阵中，除边界上的格子之外，其他格子都有4个相邻的格子。<br> 机器人从坐标(0, 0)开始移动，当它准备进入(i, j)的格子时，通过检查坐标的位数来判断机器人是否可以进入。如果能够进入，则在判断它能否进入4个相邻的格子。因此，我们可以用如下的代码来实现回溯算法：</p> <div class=highlight><pre><span></span><code><span class=kd>private</span> <span class=kt>int</span> <span class=nf>movingCount</span><span class=p>(</span><span class=kt>int</span> <span class=n>threshold</span><span class=p>,</span> <span class=kt>int</span> <span class=n>rows</span><span class=p>,</span> <span class=kt>int</span> <span class=n>cols</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>threshold</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>rows</span> <span class=o>&lt;=</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>cols</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=kt>boolean</span><span class=o>[]</span> <span class=n>visited</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>boolean</span><span class=o>[</span><span class=n>rows</span> <span class=o>*</span> <span class=n>cols</span><span class=o>]</span><span class=p>;</span>

    <span class=k>return</span> <span class=n>movingCountInner</span><span class=p>(</span><span class=n>threshold</span><span class=p>,</span> <span class=n>rows</span><span class=p>,</span> <span class=n>cols</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>visited</span><span class=p>);</span>
<span class=p>}</span>

<span class=kd>private</span> <span class=kt>int</span> <span class=nf>movingCountInner</span><span class=p>(</span><span class=kt>int</span> <span class=n>threshold</span><span class=p>,</span> <span class=kt>int</span> <span class=n>rows</span><span class=p>,</span> <span class=kt>int</span> <span class=n>cols</span><span class=p>,</span> <span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>,</span> <span class=kt>boolean</span><span class=o>[]</span> <span class=n>visited</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>index</span> <span class=o>=</span> <span class=n>rows</span> <span class=o>*</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span><span class=p>;</span>

    <span class=kt>int</span> <span class=n>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>x</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>x</span> <span class=o>&lt;</span> <span class=n>cols</span> <span class=o>&amp;&amp;</span> <span class=n>y</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>y</span> <span class=o>&lt;</span> <span class=n>rows</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>visited</span><span class=o>[</span><span class=n>index</span><span class=o>]</span> <span class=o>&amp;&amp;</span> <span class=n>isMatched</span><span class=p>(</span><span class=n>threshold</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>))</span> <span class=p>{</span>
        <span class=n>visited</span><span class=o>[</span><span class=n>index</span><span class=o>]</span> <span class=o>=</span> <span class=kc>true</span><span class=p>;</span>
        <span class=n>count</span> <span class=o>=</span>
                <span class=n>movingCountInner</span><span class=p>(</span><span class=n>threshold</span><span class=p>,</span> <span class=n>rows</span><span class=p>,</span> <span class=n>cols</span><span class=p>,</span> <span class=n>x</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>visited</span><span class=p>)</span>
                <span class=o>+</span> <span class=n>movingCountInner</span><span class=p>(</span><span class=n>threshold</span><span class=p>,</span> <span class=n>rows</span><span class=p>,</span> <span class=n>cols</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=n>visited</span><span class=p>)</span>
                <span class=o>+</span> <span class=n>movingCountInner</span><span class=p>(</span><span class=n>threshold</span><span class=p>,</span> <span class=n>rows</span><span class=p>,</span> <span class=n>cols</span><span class=p>,</span> <span class=n>x</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>visited</span><span class=p>)</span>
                <span class=o>+</span> <span class=n>movingCountInner</span><span class=p>(</span><span class=n>threshold</span><span class=p>,</span> <span class=n>rows</span><span class=p>,</span> <span class=n>cols</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>visited</span><span class=p>)</span>
                <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=n>count</span><span class=p>;</span>
<span class=p>}</span>

<span class=kd>private</span> <span class=kt>boolean</span> <span class=nf>isMatched</span><span class=p>(</span><span class=kt>int</span> <span class=n>threshold</span><span class=p>,</span> <span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>sum</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=k>do</span> <span class=p>{</span>
        <span class=n>sum</span> <span class=o>+=</span> <span class=n>x</span> <span class=o>%</span> <span class=mi>10</span><span class=p>;</span>
        <span class=n>x</span> <span class=o>/=</span> <span class=mi>10</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=n>x</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>);</span>
    <span class=k>do</span> <span class=p>{</span>
        <span class=n>sum</span> <span class=o>+=</span> <span class=n>y</span> <span class=o>%</span> <span class=mi>10</span><span class=p>;</span>
        <span class=n>y</span> <span class=o>/=</span> <span class=mi>10</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=n>y</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>);</span>

    <span class=k>return</span> <span class=n>sum</span> <span class=o>&lt;=</span> <span class=n>threshold</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <h3 id=64>6.4 动态规划与贪婪算法<a class=headerlink href=#64 title="Permanent link">&para;</a></h3> <p>如果题目是求一个问题的最优解（通常是求最大值或者最小值），而且该问题能够分解成若干个子问题，而且子问题之间还有重叠的更小的子问题，就可以考虑使用动态规划来解决这个问题。<br> 我们在应用动态规划之前要分析能够把大问题分解为小问题，分解后的每个小问题也存在最优解。如果把小问题的最优解组合起来能够得到整个问题的最优解，那么我们可以应用动态规划来解决这个问题。<br> 例如第14题中，我们如何长度为n的绳子剪成若干段，使得得到的各段长度的乘积最大。这个问题的目标是求出各段绳子长度的乘积最大值，也就是 <strong>求一个问题的最优解</strong> ——这是可以应用动态规划求解的问题的第一个特点。<br> 我们把长度为<span><span class=MathJax_Preview>n</span><script type=math/tex>n</script></span>的绳子剪成若干段后得到的乘积最大值定义为函数<span><span class=MathJax_Preview>f(n)</span><script type=math/tex>f(n)</script></span>。假设我们把第一刀减在长度为<span><span class=MathJax_Preview>i(0&lt; i &lt; n)</span><script type=math/tex>i(0< i < n)</script></span>的位置，于是把绳子剪成了长度分别为i和n-i的两段。我们想要得到整个问题的最优解<span><span class=MathJax_Preview>f(n)</span><script type=math/tex>f(n)</script></span>，那么要同样用最优化的方法把长度为i和n-i的两段分别剪成若干段，使得它们各自剪出的每段绳子的长度乘积最大。也就是说 <strong>整体问题的最优解是依赖各个子问题的最优解</strong> ——这是可以应用动态规划求解的问题的第二个特点。<br> <strong>我们把大问题分解为若干个小问题，这些小问题之间还有相互重叠的更小的子问题</strong> ——这是可以应用动态规划求解的问题的第三个特点。假设绳子最初的长度为10，我们可以把绳子剪成长度分别为4和6的两段，也就是<span><span class=MathJax_Preview>f(4)</span><script type=math/tex>f(4)</script></span>和<span><span class=MathJax_Preview>f(6)</span><script type=math/tex>f(6)</script></span>都是<span><span class=MathJax_Preview>f(10)</span><script type=math/tex>f(10)</script></span>的子问题。接下来分别求解这两个子问题，我们可以把长度为4的绳子剪成均为2的两段，即<span><span class=MathJax_Preview>f(2)</span><script type=math/tex>f(2)</script></span>是<span><span class=MathJax_Preview>f(4)</span><script type=math/tex>f(4)</script></span>的子问题。同样，我们也可以把6剪成2和4的两段，即<span><span class=MathJax_Preview>f(2)</span><script type=math/tex>f(2)</script></span>和<span><span class=MathJax_Preview>f(4)</span><script type=math/tex>f(4)</script></span>都是<span><span class=MathJax_Preview>f(6)</span><script type=math/tex>f(6)</script></span>的子问题。我们注意到<span><span class=MathJax_Preview>f(2)</span><script type=math/tex>f(2)</script></span>是<span><span class=MathJax_Preview>f(4)</span><script type=math/tex>f(4)</script></span>和<span><span class=MathJax_Preview>f(6)</span><script type=math/tex>f(6)</script></span>公共的更小的子问题。<br> 由于子问题在分解大问题的过程中重复出现，为了避免重复求解子问题，我们可以用从下往上的顺序先计算小问题的最优解并存储下来，再以此为基础求取大问题的最优解。 <strong>从上往下分析问题，从下往上求解问题</strong> ，这是可以应用动态规划求解的问题的第四个特点。在大部分题目中，已解决的子问题的最优解都存储在一维或者二维数组中。<br> 在应用动态规划时，我们每一步都可能面临若干个选择。在求解第14题时，我们在剪一刀的时候就有n-1个选择。我们可以剪在任何位置，由于我们事先不知道剪在哪个位置是最优的解法，只好把所有的可能都尝试一遍，然后得出最优的剪法。 </p> <p>贪婪算法和动态规划不一样。<strong>当我们应用贪婪算法时，每一步都可以做出一个贪婪选择，基于这个选择，我们确定能够得到最优解。为什么贪婪选择能够得到最优解，这是我们应用贪婪算法时都需要问的问题，需要用数学方式来证明贪婪选择是正确的。</strong></p> <h4 id=641-14>6.4.1 (14)剪绳子<a class=headerlink href=#641-14 title="Permanent link">&para;</a></h4> <blockquote> <p>给你一根长度为n绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m≥1）。每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]*k[1]*…*k[m]可能的最大乘积是多少？例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。</p> </blockquote> <p><strong>解法一：动态规划</strong></p> <p><div class=highlight><pre><span></span><code><span class=kd>private</span> <span class=kt>int</span> <span class=nf>maxProductAfterCutting_solution1</span><span class=p>(</span><span class=kt>int</span> <span class=n>length</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>length</span> <span class=o>&lt;</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>length</span> <span class=o>==</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>length</span> <span class=o>==</span> <span class=mi>3</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=mi>2</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=kt>int</span><span class=o>[]</span> <span class=n>products</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=o>[</span><span class=n>length</span> <span class=o>+</span> <span class=mi>1</span><span class=o>]</span><span class=p>;</span>
    <span class=n>products</span><span class=o>[</span><span class=mi>0</span><span class=o>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>products</span><span class=o>[</span><span class=mi>1</span><span class=o>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
    <span class=n>products</span><span class=o>[</span><span class=mi>2</span><span class=o>]</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
    <span class=n>products</span><span class=o>[</span><span class=mi>3</span><span class=o>]</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>

    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>4</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>length</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=kt>int</span> <span class=n>max</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>i</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
            <span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=n>products</span><span class=o>[</span><span class=n>j</span><span class=o>]</span> <span class=o>*</span> <span class=n>products</span><span class=o>[</span><span class=n>i</span> <span class=o>-</span> <span class=n>j</span><span class=o>]</span><span class=p>;</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>result</span> <span class=o>&gt;</span> <span class=n>max</span><span class=p>)</span> <span class=p>{</span>
                <span class=n>max</span> <span class=o>=</span> <span class=n>result</span><span class=p>;</span>
            <span class=p>}</span>
            <span class=n>products</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=n>max</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>products</span><span class=o>[</span><span class=n>length</span><span class=o>]</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> 上述products中存储的就是子问题的最优解。数组中第i个元素表示把长度为i的绳子剪成若干段之后各段长度乘积的最大值，即<span><span class=MathJax_Preview>f(i)</span><script type=math/tex>f(i)</script></span>。注意，这是子问题的最优解，也就是说i是可以不进行切割的。</p> <p><strong>解法二：贪婪算法</strong></p> <p>我们按照如下的策略来剪绳子，则得到的各段绳子的长度的乘积最大：当n&gt;=5时，我们尽可能多地剪长度为3的绳子；当剩下的绳子长度为4时，把绳子剪成两段长度为2的绳子。 </p> <div class=highlight><pre><span></span><code><span class=kd>private</span> <span class=kt>int</span> <span class=nf>maxProductAfterCutting_solution2</span><span class=p>(</span><span class=kt>int</span> <span class=n>length</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>length</span> <span class=o>&lt;</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>length</span> <span class=o>==</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>length</span> <span class=o>==</span> <span class=mi>3</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=mi>2</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=c1>// 尽可能多剪去长度为3的绳子段</span>
    <span class=kt>int</span> <span class=n>timesOf3</span> <span class=o>=</span> <span class=n>length</span> <span class=o>/</span> <span class=mi>3</span><span class=p>;</span>

    <span class=c1>// 当绳子最后剩下的长度为4时，不能再减去长度为3的绳子段</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>length</span> <span class=o>-</span> <span class=n>timesOf3</span> <span class=o>*</span> <span class=mi>3</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>timesOf3</span><span class=o>--</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=c1>// 此时更好的方法是把绳子剪成长度为2的两段，因为2x2&gt;3x1</span>
    <span class=kt>int</span> <span class=n>timesOf2</span> <span class=o>=</span> <span class=p>(</span><span class=n>length</span> <span class=o>-</span> <span class=n>timesOf3</span> <span class=o>*</span> <span class=mi>3</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span>

    <span class=k>return</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=n>Math</span><span class=p>.</span><span class=na>pow</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=n>timesOf3</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=n>Math</span><span class=p>.</span><span class=na>pow</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>timesOf2</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div> <p>接下来我们证明这种思路的正确性。首先，当n&gt;=5时，我们可以证明2(n-2)&gt;n并且3(n-3)&gt;n。也就是说，当绳子剩下的长度大于或者等于5的时候，我们就把它剪成长度为3或者2的绳子段。另外，当n&gt;=5时，3(n-3)&gt;=2(n-2)，因此我们应该尽量多剪长度为3的绳子段。<br> 前面证明的前提是n&gt;=5。那么当绳子的长度为4时，2x2&gt;3x1，同时2x2=4，也就是说当绳子长度为4时其实没必要剪，只是题目要求至少一刀。</p> <h3 id=65>6.5 位运算<a class=headerlink href=#65 title="Permanent link">&para;</a></h3> <p>位运算只有5种运算：与、或、异或、左移、右移。<br> 与、或、异或运算的规律可以用下表总结：</p> <table> <thead> <tr> <th></th> <th></th> <th></th> <th></th> <th></th> </tr> </thead> <tbody> <tr> <td>与(&amp;)</td> <td>0 &amp; 0 = 0</td> <td>1 &amp; 0 = 0</td> <td>0 &amp; 1 = 0</td> <td>1 &amp; 1 = 1</td> </tr> <tr> <td>或(|)</td> <td>0 | 0 = 0</td> <td>1 | 0 = 1</td> <td>0 | 1 = 1</td> <td>1 | 1 = 1</td> </tr> <tr> <td>异或(^)</td> <td>0 ^ 0 = 0</td> <td>1 ^ 0 = 1</td> <td>0 ^ 1 = 1</td> <td>1 ^ 1 = 0</td> </tr> </tbody> </table> <p>左移运算符m&lt;&lt;n表示把m左移n位。在左移n位的时候，最左边的n位会被丢弃，同时在最右边补上n个0。比如：<br> 00001010 &lt;&lt; 2 = 00101000<br> 10001010 &lt;&lt; 3 = 01010000</p> <p>右移运算符m&gt;&gt;n表示把m右移n位。在右移n位的时候，最右边的n位将被丢弃。但右移时处理最左边位的情形要稍微复杂一点。如果数字是一个无符号数值，则用0填补最左边的n位；如果数字是一个有符号数值，则用数字的符号位填补最左边的n位。也就是说，如果数字原先是一个正数，则右移之后再最左边补n个0；如果数字原先是个负数，则右移之后再最左边补n个1。下面是对两个8位有符号数进行右移的例子：<br> 00001010 &gt;&gt; 2 = 00000010<br> 10001010 &gt;&gt; 3 = 11110001 </p> <h3 id=651-151>6.5.1 (15)二进制中1的个数<a class=headerlink href=#651-151 title="Permanent link">&para;</a></h3> <blockquote> <p>请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如把9表示成二进制是1001，有2位是1。因此如果输入9，该函数输出2。</p> </blockquote> <p><strong>解法一：常规解法</strong><br> 先判断整数二进制表示中最右边一位是不是1；然后把输入的整数右移一位，此时原来处于从右边数起的第二位被移到最右边了，再判断它是不是1；这样一直移动，直到整个整数变成0为止。现在的问题变成了怎么判断一个整数的最右边是不是1。这也很简单，只需要把整数和1做位与运算看结果是不是0就知道了。<br> 但是，如果输入一个负数，比如0x80000000，则运行的时候会发生什么情况？当把负数0x80000000右移一位的时候，并不是简单地把最高位的1移到第二位变成0x4000000，而是0xC000000。这是因为移位前是一个负数，仍然要保证移位后也是一个负数，因此移位后的最高位会设为1。如果一直做右移运算，那么最终这个数字就会变成0xFFFFFFFF而陷入死循环。<br> 为了避免死循环，我们可以不右移输入的数字n。而是左移一个flag。 </p> <div class=highlight><pre><span></span><code><span class=kt>int</span> <span class=nf>NumberOf1_Solution1</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>flag</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>

    <span class=k>while</span> <span class=p>(</span><span class=n>flag</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>((</span><span class=n>n</span> <span class=o>&amp;</span> <span class=n>flag</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>count</span><span class=o>++</span><span class=p>;</span>
        <span class=p>}</span>

        <span class=n>flag</span> <span class=o>=</span> <span class=n>flag</span> <span class=o>&lt;&lt;</span> <span class=mi>1</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>count</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p><strong>解法二：牛逼解法</strong> </p> <p>我们发现，把一个整数减去1，再和原整数做位与运算，会把该整数最右边的1变成0。比如下面两个例子<br> 1100 -&gt; (1011 &amp; 1100) = 1000 -&gt; 0<br> 1010 -&gt; (1001 &amp; 1010) = 1000 -&gt; 0</p> <div class=highlight><pre><span></span><code><span class=kt>int</span> <span class=nf>NumberOf1_Solution2</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>

    <span class=k>while</span> <span class=p>(</span><span class=n>n</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>count</span><span class=o>++</span><span class=p>;</span>
        <span class=n>n</span> <span class=o>=</span> <span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&amp;</span> <span class=n>n</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>count</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <div class="admonition info"> <p class=admonition-title>相关题目</p> <p>用一条语句判断一个整数是不是2的整数次方。<br> <em>一个整数如果是2的整数次方，那么它的二进制位表示中有且只有一位是1，而其他所有位都是0。根据前面的分析，把这个整数减去1之后再和它自己做与运算，这个整数中唯一的1就会变成0</em> </p> </div> <div class="admonition info"> <p class=admonition-title>相关题目</p> <p>输入两个整数m和n，计算需要改变m的二进制表示中的多少位才能得到n。比如10的二进制表示为1010，13的二进制表示为1101，需要改变1010中的3位才能得到1101。<br> <em>我们可以分为两步解决这个问题：第一步求这两个数的异或；第二步统计异或结果中1的位数</em></p> </div> <div class="admonition info"> <p class=admonition-title>举一反三</p> <p>把一个整数减去1之后再和原来的整数做位与运算，得到的结果相当于把整数的二进制表示中最右边的1变成0。很多二进制问题都可以用这种思路解决。</p> </div> <h3 id=7>7. 总结<a class=headerlink href=#7 title="Permanent link">&para;</a></h3> <p>数据结构题目一直是考查的重点。数组和字符串是两种最基本的数据结构。链表是使用频率最高的一种数据结构。如果想加大面试的难度，那么他很有可能会选用与树相关的题目。由于栈和递归调用密切相关，队列在图（包括树）的宽度优先遍历中需要用到，因此也需要掌握这两种数据结构。 </p> <p>算法是另一个重点。查找（特别是二分查找）和排序（特别是快速排序和归并排序）是经常考查的算法。回溯法很适合解决迷宫以及类似的问题。如果需要求一个问题的最优2解，那么可以尝试使用动态规划。假如我们在用动态规划分析问题时发现每一步都存在一个能得到最优解的选择，那么可以尝试使用贪婪算法。另外，我们还需要掌握分析时间复杂度的方法，理解即使同一思路，基于循环和递归的不同实现，它们的时间复杂度可能不大相同。很多时候我们会用自上而下的递归思路分析问题，却会基于自下而上的循环实现代码。 </p> <p>位运算是针对二进制数字的运算规律。只要熟练掌握了二进制的与、或、异或、左移、右移操作，就能解决相关问题。 </p> <hr> <div class=md-source-date> <small> 最后更新: <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">2021年10月8日</span> </small> </div> <h2 id=__comments>评论</h2> <div id=disqus_thread></div> <script>var disqus_config=function(){this.page.url="https://blog.yorek.xyz/leetcode/code_interviews_1/",this.page.identifier="/leetcode/code_interviews_1/"};window.addEventListener("load",function(){var e=document,i=e.createElement("script");i.src="//yorekliu.disqus.com/embed.js",i.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(i)})</script> </article> </div> </div> <a href=# class="md-top md-icon" data-md-component=top data-md-state=hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"/></svg> </a> </main> <footer class=md-footer> <nav class="md-footer__inner md-grid" aria-label=Footer> <a href=../ class="md-footer__link md-footer__link--prev" rel=prev> <div class="md-footer__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg> </div> <div class=md-footer__title> <div class=md-ellipsis> <span class=md-footer__direction> 上一页 </span> 算法目录 </div> </div> </a> <a href=../code_interviews_3/ class="md-footer__link md-footer__link--next" rel=next> <div class=md-footer__title> <div class=md-ellipsis> <span class=md-footer__direction> 下一页 </span> 高质量的代码 </div> </div> <div class="md-footer__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg> </div> </a> </nav> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-footer-copyright> <div class=md-footer-copyright__highlight> &copy; 2021 Yorek </div> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> <div class=md-footer-social> <a href=https://github.com/YorekLiu target=_blank rel=noopener title=github.com class=md-footer-social__link> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34-.46-1.16-1.11-1.47-1.11-1.47-.91-.62.07-.6.07-.6 1 .07 1.53 1.03 1.53 1.03.87 1.52 2.34 1.07 2.91.83.09-.65.35-1.09.63-1.34-2.22-.25-4.55-1.11-4.55-4.92 0-1.11.38-2 1.03-2.71-.1-.25-.45-1.29.1-2.64 0 0 .84-.27 2.75 1.02.79-.22 1.65-.33 2.5-.33.85 0 1.71.11 2.5.33 1.91-1.29 2.75-1.02 2.75-1.02.55 1.35.2 2.39.1 2.64.65.71 1.03 1.6 1.03 2.71 0 3.82-2.34 4.66-4.57 4.91.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2z"/></svg> </a> <a href=lyytogether@gmail.com target=_blank rel=noopener title class=md-footer-social__link> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="m20 8-8 5-8-5V6l8 5 8-5m0-2H4c-1.11 0-2 .89-2 2v12a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2z"/></svg> </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "../..", "features": ["navigation.tabs", "navigation.instant", "navigation.top"], "translations": {"clipboard.copy": "\u590d\u5236", "clipboard.copied": "\u5df2\u590d\u5236", "search.config.lang": "ja", "search.config.pipeline": "trimmer, stemmer", "search.config.separator": "[\\uff0c\\u3002]+", "search.placeholder": "\u641c\u7d22", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}, "search": "../../assets/javascripts/workers/search.fe42c31b.min.js", "version": null}</script> <script src=../../assets/javascripts/bundle.d892486b.min.js></script> <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script> </body> </html>