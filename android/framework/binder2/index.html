<!doctype html><html lang=zh class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="An Android Developer."><meta name=author content="Yorek Liu"><link href=https://blog.yorek.xyz/about-me/android/framework/binder2/ rel=canonical><link rel="shortcut icon" href=../../../assets/images/favicon.webp><meta name=generator content="mkdocs-1.1.2, mkdocs-material-6.2.5"><title>Binder深入理解——罗老师系列 - Yorek's</title><link rel=stylesheet href=../../../assets/stylesheets/main.15aa0b43.min.css><link rel=stylesheet href=../../../assets/stylesheets/palette.75751829.min.css><meta name=theme-color content=#ffffff><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback"><style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style><link rel=manifest href=../../../manifest.webmanifest crossorigin=use-credentials><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-155096376-1","auto"),ga("set","anonymizeIp",!0),ga("send","pageview"),document.addEventListener("DOMContentLoaded",function(){document.forms.search&&document.forms.search.query.addEventListener("blur",function(){if(this.value){var e=document.location.pathname;ga("send","pageview",e+"?q="+this.value)}})}),document.addEventListener("DOMContentSwitch",function(){ga("send","pageview",document.location.pathname)})</script><script async src=https://www.google-analytics.com/analytics.js></script></head> <body dir=ltr data-md-color-scheme data-md-color-primary=white data-md-color-accent=blue> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#1-service-manager class=md-skip> 跳转至 </a> </div> <div data-md-component=announce> </div> <header class=md-header data-md-component=header> <nav class="md-header-nav md-grid" aria-label=Header> <a href=https://blog.yorek.xyz/about-me title="Yorek's" class="md-header-nav__button md-logo" aria-label="Yorek's"> <img src=../../../assets/images/favicon.webp alt=logo> </a> <label class="md-header-nav__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg> </label> <div class=md-header-nav__title data-md-component=header-title> <div class=md-header-nav__ellipsis> <div class=md-header-nav__topic> <span class=md-ellipsis> Yorek's </span> </div> <div class=md-header-nav__topic> <span class=md-ellipsis> Binder深入理解——罗老师系列 </span> </div> </div> </div> <label class="md-header-nav__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=搜索 placeholder=搜索 autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query data-md-state=active required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg> </label> <button type=reset class="md-search__icon md-icon" aria-label=Clear data-md-component=search-reset tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg> </button> </form> <div class=md-search__output> <div class=md-search__scrollwrap data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> 正在初始化搜索引擎 </div> <ol class=md-search-result__list></ol> </div> </div> </div> </div> </div> </nav> </header> <div class=md-container data-md-component=container> <nav class=md-tabs aria-label=Tabs data-md-component=tabs> <div class="md-tabs__inner md-grid"> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../../3rd-library/3rd-library-source-code/ class="md-tabs__link md-tabs__link--active"> Android </a> </li> <li class=md-tabs__item> <a href=../../../flutter/flutter_first_project_1/ class=md-tabs__link> Flutter </a> </li> <li class=md-tabs__item> <a href=../../../leetcode/ class=md-tabs__link> LeetCode </a> </li> <li class=md-tabs__item> <a href=../../../design-pattern/design-pattern/ class=md-tabs__link> Books </a> </li> </ul> </div> </nav> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=https://blog.yorek.xyz/about-me title="Yorek's" class="md-nav__button md-logo" aria-label="Yorek's"> <img src=../../../assets/images/favicon.webp alt=logo> </a> Yorek's </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-1 type=checkbox id=nav-1 checked> <label class=md-nav__link for=nav-1> Android <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Android data-md-level=1> <label class=md-nav__title for=nav-1> <span class="md-nav__icon md-icon"></span> Android </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-1-1 type=checkbox id=nav-1-1> <label class=md-nav__link for=nav-1-1> 三方库源码解析 <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=三方库源码解析 data-md-level=2> <label class=md-nav__title for=nav-1-1> <span class="md-nav__icon md-icon"></span> 三方库源码解析 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../3rd-library/3rd-library-source-code/ class=md-nav__link> Android三方库源码分析 </a> </li> <li class=md-nav__item> <a href=../../3rd-library/matrix/ class=md-nav__link> 微信APM Matrix解析 </a> </li> <li class=md-nav__item> <a href=../../3rd-library/matrix-trace/ class=md-nav__link> Matrix-TraceCanary解析 </a> </li> <li class=md-nav__item> <a href=../../3rd-library/matrix-io/ class=md-nav__link> Matrix-IOCanary解析 </a> </li> <li class=md-nav__item> <a href=../../3rd-library/matrix-resource/ class=md-nav__link> Matrix-ResourceCanary解析 </a> </li> <li class=md-nav__item> <a href=../../3rd-library/matrix-sqlitelint/ class=md-nav__link> Matrix-SQLiteLint解析 </a> </li> <li class=md-nav__item> <a href=../../3rd-library/okhttp/ class=md-nav__link> OkHttp3源码解析 </a> </li> <li class=md-nav__item> <a href=../../3rd-library/retrofit/ class=md-nav__link> Retrofit2源码解析 </a> </li> <li class=md-nav__item> <a href=../../3rd-library/rxjava%26rxandroid/ class=md-nav__link> RxJava源码解析及使用实例 </a> </li> <li class=md-nav__item> <a href=../../other/RxJava/ class=md-nav__link> RxJava操作符大全 </a> </li> <li class=md-nav__item> <a href=../../3rd-library/glide1/ class=md-nav__link> Glide v4 源码解析（一） </a> </li> <li class=md-nav__item> <a href=../../3rd-library/glide2/ class=md-nav__link> Glide v4 源码解析（二） </a> </li> <li class=md-nav__item> <a href=../../3rd-library/glide3/ class=md-nav__link> Glide v4 源码解析（三） </a> </li> <li class=md-nav__item> <a href=../../3rd-library/glide4/ class=md-nav__link> Glide v4 源码解析（四） </a> </li> <li class=md-nav__item> <a href=../../3rd-library/glide5/ class=md-nav__link> Glide v4 源码解析（五） </a> </li> <li class=md-nav__item> <a href=../../3rd-library/glide6/ class=md-nav__link> Glide v4 源码解析（六） </a> </li> <li class=md-nav__item> <a href=../../3rd-library/glide7/ class=md-nav__link> Glide v4 源码解析（七） </a> </li> <li class=md-nav__item> <a href=../../3rd-library/migrate-to-glide/ class=md-nav__link> 杂记：从Picasso迁移至Glide </a> </li> <li class=md-nav__item> <a href=../../3rd-library/eventbus/ class=md-nav__link> EventBus源码解析 </a> </li> <li class=md-nav__item> <a href=../../3rd-library/leakcanary/ class=md-nav__link> LeakCanary2源码解析 </a> </li> <li class=md-nav__item> <a href=../../3rd-library/permissiondispatcher/ class=md-nav__link> PermissionDispatcher源码解析 </a> </li> <li class=md-nav__item> <a href=../../other/constraintlayout/ class=md-nav__link> ConstraintLayout使用大全 </a> </li> <li class=md-nav__item> <a href=../../other/dagger2/ class=md-nav__link> 初学者的Dagger2教程 </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-1-2 type=checkbox id=nav-1-2> <label class=md-nav__link for=nav-1-2> Android开发高手课 <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Android开发高手课 data-md-level=2> <label class=md-nav__title for=nav-1-2> <span class="md-nav__icon md-icon"></span> Android开发高手课 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../paid/master/ class=md-nav__link> Android开发高手课 </a> </li> <li class=md-nav__item> <a href=../../paid/master/crash_1/ class=md-nav__link> 01 | 崩溃优化（上）：关于“崩溃”那些事儿 </a> </li> <li class=md-nav__item> <a href=../../paid/master/crash_2/ class=md-nav__link> 02 | 崩溃优化（下）：应用崩溃了，你应该如何去分析？ </a> </li> <li class=md-nav__item> <a href=../../paid/master/memory_1/ class=md-nav__link> 03 | 内存优化（上）：4GB内存时代，再谈内存优化 </a> </li> <li class=md-nav__item> <a href=../../paid/master/memory_2/ class=md-nav__link> 04 | 内存优化（下）：内存优化这件事，应该从哪里着手？ </a> </li> <li class=md-nav__item> <a href=../../paid/master/stuck_1/ class=md-nav__link> 05 | 卡顿优化（上）：你要掌握的卡顿分析方法 </a> </li> <li class=md-nav__item> <a href=../../paid/master/stuck_2/ class=md-nav__link> 06 | 卡顿优化（下）：如何监控应用卡顿？ </a> </li> <li class=md-nav__item> <a href=../../paid/master/stuck_3/ class=md-nav__link> 06补充篇 | 卡顿优化：卡顿现场与卡顿分析 </a> </li> <li class=md-nav__item> <a href=../../paid/master/start_1/ class=md-nav__link> 07 | 启动优化（上）：从启动过程看启动速度优化 </a> </li> <li class=md-nav__item> <a href=../../paid/master/start_2/ class=md-nav__link> 08 | 启动优化（下）：优化启动速度的进阶方法 </a> </li> <li class=md-nav__item> <a href=../../paid/master/io_1/ class=md-nav__link> 09 | I/O优化（上）：开发工程师必备的I/O优化知识 </a> </li> <li class=md-nav__item> <a href=../../paid/master/io_2/ class=md-nav__link> 10 | I/O优化（中）：不同I/O方式的使用场景是什么？ </a> </li> <li class=md-nav__item> <a href=../../paid/master/io_3/ class=md-nav__link> 11 | I/O优化（下）：如何监控线上I/O操作？ </a> </li> <li class=md-nav__item> <a href=../../paid/master/storage_1/ class=md-nav__link> 12 | 存储优化（上）：常见的数据存储方法有哪些？ </a> </li> <li class=md-nav__item> <a href=../../paid/master/storage_2/ class=md-nav__link> 13 | 存储优化（中）：如何优化数据存储？ </a> </li> <li class=md-nav__item> <a href=../../paid/master/storage_3/ class=md-nav__link> 14 | 存储优化（下）：数据库SQLite的使用和优化 </a> </li> <li class=md-nav__item> <a href=../../paid/master/network_1/ class=md-nav__link> 15 | 网络优化（上）：移动开发工程师必备的网络优化知识 </a> </li> <li class=md-nav__item> <a href=../../paid/master/network_2/ class=md-nav__link> 16 | 网络优化（中）：复杂多变的移动网络该如何优化？ </a> </li> <li class=md-nav__item> <a href=../../paid/master/network_3/ class=md-nav__link> 17 | 网络优化（下）：大数据下网络该如何监控？ </a> </li> <li class=md-nav__item> <a href=../../paid/master/battery_1/ class=md-nav__link> 18 | 耗电优化（上）：从电量优化的演进看耗电分析 </a> </li> <li class=md-nav__item> <a href=../../paid/master/battery_2/ class=md-nav__link> 19 | 耗电优化（下）：耗电的优化方法与线上监控 </a> </li> <li class=md-nav__item> <a href=../../paid/master/ui_1/ class=md-nav__link> 20 | UI 优化（上）：UI 渲染的几个关键概念 </a> </li> <li class=md-nav__item> <a href=../../paid/master/ui_2/ class=md-nav__link> 21 | UI 优化（下）：如何优化 UI 渲染？ </a> </li> <li class=md-nav__item> <a href=../../paid/master/package_1/ class=md-nav__link> 22 | 包体积优化（上）：如何减少安装包大小？ </a> </li> <li class=md-nav__item> <a href=../../paid/master/package_2/ class=md-nav__link> 23 | 包体积优化（下）：资源优化的进阶实践 </a> </li> <li class=md-nav__item> <a href=../../paid/master/compile/ class=md-nav__link> 26 | 关于编译，你需要了解什么？ </a> </li> <li class=md-nav__item> <a href=../../paid/master/bytecode/ class=md-nav__link> 27 | 编译插桩的三种方法：AspectJ、ASM、ReDex </a> </li> <li class=md-nav__item> <a href=../../paid/master/native_hook/ class=md-nav__link> 35 | Native Hook 技术，天使还是魔鬼？ </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-1-3 type=checkbox id=nav-1-3 checked> <label class=md-nav__link for=nav-1-3> Framework系列 <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Framework系列 data-md-level=2> <label class=md-nav__title for=nav-1-3> <span class="md-nav__icon md-icon"></span> Framework系列 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%281%29/ class=md-nav__link> Activity </a> </li> <li class=md-nav__item> <a href=../Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%282%29/ class=md-nav__link> Service </a> </li> <li class=md-nav__item> <a href=../Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%283%29/ class=md-nav__link> Broadcasts </a> </li> <li class=md-nav__item> <a href=../Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%284%29/ class=md-nav__link> Content Providers与Fragment </a> </li> <li class=md-nav__item> <a href=../IPC%E6%9C%BA%E5%88%B6/ class=md-nav__link> IPC机制 </a> </li> <li class=md-nav__item> <a href=../View%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/ class=md-nav__link> View的事件体系 </a> </li> <li class=md-nav__item> <a href=../View%E7%9A%84%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86/ class=md-nav__link> View的绘制原理 </a> </li> <li class=md-nav__item> <a href=../RemoteViews/ class=md-nav__link> RemoteViews </a> </li> <li class=md-nav__item> <a href=../Drawable/ class=md-nav__link> Android中的Drawable资源 </a> </li> <li class=md-nav__item> <a href=../Android%E5%8A%A8%E7%94%BB/ class=md-nav__link> Android动画 </a> </li> <li class=md-nav__item> <a href=../Window%E4%B8%8EWindowManager/ class=md-nav__link> Window与WindowManager </a> </li> <li class=md-nav__item> <a href=../%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/ class=md-nav__link> 四大组件启动过程 </a> </li> <li class=md-nav__item> <a href=../Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/ class=md-nav__link> Android消息机制 </a> </li> <li class=md-nav__item> <a href=../Android%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0/ class=md-nav__link> Android线程与线程池 </a> </li> <li class=md-nav__item> <a href=../Bitmap%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%8E%E5%8A%A0%E8%BD%BD/ class=md-nav__link> Bitmap的缓存与加载 </a> </li> <li class=md-nav__item> <a href=../JNI%E4%B8%8ENDK/ class=md-nav__link> JNI与NDK编程简介 </a> </li> <li class=md-nav__item> <a href=../%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/ class=md-nav__link> Android性能优化 </a> </li> <li class=md-nav__item> <a href=../binder1-mediaservice/ class=md-nav__link> Binder深入理解——以MediaService为例 </a> </li> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" data-md-toggle=toc type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> Binder深入理解——罗老师系列 <span class="md-nav__icon md-icon"></span> </label> <a href=./ class="md-nav__link md-nav__link--active"> Binder深入理解——罗老师系列 </a> <nav class="md-nav md-nav--secondary" aria-label=目录> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> 目录 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=#1-service-manager class=md-nav__link> 1 Service Manager是如何成为守护进程的 </a> </li> <li class=md-nav__item> <a href=#2-binderserverclientservice-manager class=md-nav__link> 2 Binder中的Server和Client获得Service Manager接口之路 </a> </li> <li class=md-nav__item> <a href=#3-service-managerserverserver class=md-nav__link> 3 Service Manager在Server的启动中是如何为Server提供服务的 </a> </li> <li class=md-nav__item> <a href=#4-clientserver class=md-nav__link> 4 Client如何获得Server的远程接口 </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-1-4 type=checkbox id=nav-1-4> <label class=md-nav__link for=nav-1-4> 付费知识归档 <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=付费知识归档 data-md-level=2> <label class=md-nav__title for=nav-1-4> <span class="md-nav__icon md-icon"></span> 付费知识归档 </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-1-4-1 type=checkbox id=nav-1-4-1> <label class=md-nav__link for=nav-1-4-1> 某圈问题索引 <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=某圈问题索引 data-md-level=3> <label class=md-nav__title for=nav-1-4-1> <span class="md-nav__icon md-icon"></span> 某圈问题索引 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../paid/zsxq/zsxq_index/ class=md-nav__link> 某圈问题索引 </a> </li> <li class=md-nav__item> <a href=../../paid/zsxq/week1-synchronized/ class=md-nav__link> 理解Java中synchronized关键词 </a> </li> <li class=md-nav__item> <a href=../../paid/zsxq/week2-service/ class=md-nav__link> 理解Service </a> </li> <li class=md-nav__item> <a href=../../paid/zsxq/week3-activity/ class=md-nav__link> 理解Activity的启动模式 </a> </li> <li class=md-nav__item> <a href=../../paid/zsxq/week4-startActivityForResult/ class=md-nav__link> 关于startActivityForResult </a> </li> <li class=md-nav__item> <a href=../../paid/zsxq/week5-view/ class=md-nav__link> 关于View的知识 </a> </li> <li class=md-nav__item> <a href=../../paid/zsxq/week6-gradle/ class=md-nav__link> 关于Gradle的知识 </a> </li> <li class=md-nav__item> <a href=../../paid/zsxq/week7-serialization/ class=md-nav__link> 关于序列化的知识 </a> </li> <li class=md-nav__item> <a href=../../paid/zsxq/week10-classloader/ class=md-nav__link> Android中的ClassLoader </a> </li> <li class=md-nav__item> <a href=../../paid/zsxq/week11-binder/ class=md-nav__link> Binder简介 </a> </li> <li class=md-nav__item> <a href=../../paid/zsxq/week12-retrofit-okhttp/ class=md-nav__link> OkHttp和Retrofit的作用以及两者之间的联系 </a> </li> <li class=md-nav__item> <a href=../../paid/zsxq/week14-jvm-gc/ class=md-nav__link> JVM中垃圾回收策略 </a> </li> <li class=md-nav__item> <a href=../../paid/zsxq/week16-keep-app-alive/ class=md-nav__link> 进程保活 </a> </li> <li class=md-nav__item> <a href=../../paid/zsxq/week17-android-components/ class=md-nav__link> 四大组件的作用以及多进程 </a> </li> <li class=md-nav__item> <a href=../../paid/zsxq/week20-network-protocol/ class=md-nav__link> 网络协议 </a> </li> <li class=md-nav__item> <a href=../../paid/zsxq/week21-mvc%26mvp%26mvvm/ class=md-nav__link> MVC、MVP和MVVM </a> </li> <li class=md-nav__item> <a href=../../paid/zsxq/week22-android-studio-build/ class=md-nav__link> Android Studio build过程 </a> </li> <li class=md-nav__item> <a href=../../paid/zsxq/week23-load-large-bitmap/ class=md-nav__link> 大尺寸图片加载问题 </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-1-5 type=checkbox id=nav-1-5> <label class=md-nav__link for=nav-1-5> 日常记录 <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=日常记录 data-md-level=2> <label class=md-nav__title for=nav-1-5> <span class="md-nav__icon md-icon"></span> 日常记录 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../other/annotation/ class=md-nav__link> 注解的定义及解析 </a> </li> <li class=md-nav__item> <a href=../../other/best_throttle_in_mvvm/ class=md-nav__link> 这可能是MVVM中最优雅的按键防抖方案 </a> </li> <li class=md-nav__item> <a href=../../other/android-jenkins/ class=md-nav__link> Jenkins for android </a> </li> <li class=md-nav__item> <a href=../../other/SystemProrities/ class=md-nav__link> 普通Android程序使用SystemProrities </a> </li> <li class=md-nav__item> <a href=../../other/recyclerview-cache/ class=md-nav__link> ListView、RecyclerView缓存策略解析 </a> </li> <li class=md-nav__item> <a href=../../other/recyclerview-item-docoration/ class=md-nav__link> RecyclerView高级特性——ItemDecoration </a> </li> <li class=md-nav__item> <a href=../../other/recyclerview-others/ class=md-nav__link> RecyclerView的一些使用细节 </a> </li> <li class=md-nav__item> <a href=../../other/RecyclerView-Sort%26Delete/ class=md-nav__link> RecyclerView高级特性——拖拽排序以及滑动删除 </a> </li> <li class=md-nav__item> <a href=../../other/FAB-Behavior/ class=md-nav__link> FloatingActionButton上滑隐藏下滑显示 </a> </li> <li class=md-nav__item> <a href=../../other/nestedscrolling/ class=md-nav__link> NestedScrolling机制 </a> </li> <li class=md-nav__item> <a href=../../other/porterduff/ class=md-nav__link> 使用Porter-Duff合成数字图像 </a> </li> <li class=md-nav__item> <a href=../../other/runtime/ class=md-nav__link> Android Runtime </a> </li> <li class=md-nav__item> <a href=../../other/android_alias/ class=md-nav__link> Android马甲包的那些事儿 </a> </li> <li class=md-nav__item> <a href=../../other/Android-Development-Tool/ class=md-nav__link> Android神兵利器 </a> </li> <li class=md-nav__item> <a href=../../other/FileProvider/ class=md-nav__link> FileProvider </a> </li> <li class=md-nav__item> <a href=../../other/Android%E5%88%A4%E6%96%AD%E5%AF%BC%E8%88%AA%E6%A0%8F%E9%AB%98%E5%BA%A6/ class=md-nav__link> Android判断虚拟按键(导航栏)显示与否、高度以及获取屏幕实际高度 </a> </li> <li class=md-nav__item> <a href=../../other/Android%E5%9B%BE%E7%89%87%E9%80%89%E6%8B%A9%E5%99%A8/ class=md-nav__link> Android图片选择器 </a> </li> <li class=md-nav__item> <a href=../../other/Android%E5%BA%95%E9%83%A8%E5%AF%BC%E8%88%AA%E6%A0%8F%E6%A1%86%E6%9E%B6/ class=md-nav__link> Android原生底部导航栏 </a> </li> <li class=md-nav__item> <a href=../../other/Android%E6%90%9C%E7%B4%A2%E6%A0%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/ class=md-nav__link> Android搜索栏的实现 </a> </li> <li class=md-nav__item> <a href=../../other/Android%E6%9A%82%E5%81%9C%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%E7%9A%84%E6%92%AD%E6%94%BE/ class=md-nav__link> Android暂停酷狗、网易云音乐等音乐播放器的播放 </a> </li> <li class=md-nav__item> <a href=../../other/Android%E6%BB%91%E5%8A%A8%E8%BF%94%E5%9B%9E%E5%AE%9E%E8%B7%B5/ class=md-nav__link> Android滑动返回实践 </a> </li> <li class=md-nav__item> <a href=../../other/Android%E7%A8%8B%E5%BA%8F%E5%8F%8D%E7%BC%96%E8%AF%91/ class=md-nav__link> MacOS下Android程序反编译 </a> </li> <li class=md-nav__item> <a href=../../other/Android%E9%80%9A%E8%AE%AF%E5%BD%95%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%8F%96/ class=md-nav__link> Android通讯录快速读取 </a> </li> <li class=md-nav__item> <a href=../../other/soft-keyboard-in-app/ class=md-nav__link> App内自定义软键盘 </a> </li> <li class=md-nav__item> <a href=../../other/%E8%85%BE%E8%AE%AFX5%E5%86%85%E6%A0%B8%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97/ class=md-nav__link> 腾讯TBS X5浏览器内核入坑指南 </a> </li> <li class=md-nav__item> <a href=../../other/%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/ class=md-nav__link> 琐碎知识点 </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-2 type=checkbox id=nav-2> <label class=md-nav__link for=nav-2> Flutter <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Flutter data-md-level=1> <label class=md-nav__title for=nav-2> <span class="md-nav__icon md-icon"></span> Flutter </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../flutter/flutter_first_project_1/ class=md-nav__link> 年轻人的第一个Flutter程序(1) </a> </li> <li class=md-nav__item> <a href=../../../flutter/flutter_first_project_2/ class=md-nav__link> 年轻人的第一个Flutter程序(2) </a> </li> <li class=md-nav__item> <a href=../../../flutter/flutter_first_project_3/ class=md-nav__link> 年轻人的第一个Flutter程序(3) </a> </li> <li class=md-nav__item> <a href=../../../flutter/flutter_first_project_4/ class=md-nav__link> 年轻人的第一个Flutter程序(4) </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-3 type=checkbox id=nav-3> <label class=md-nav__link for=nav-3> LeetCode <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=LeetCode data-md-level=1> <label class=md-nav__title for=nav-3> <span class="md-nav__icon md-icon"></span> LeetCode </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../leetcode/ class=md-nav__link> 算法目录 </a> </li> <li class=md-nav__item> <a href=../../../leetcode/code_interviews_1/ class=md-nav__link> 数据结构、算法和数据操作 </a> </li> <li class=md-nav__item> <a href=../../../leetcode/code_interviews_3/ class=md-nav__link> 高质量的代码 </a> </li> <li class=md-nav__item> <a href=../../../leetcode/code_interviews_4/ class=md-nav__link> 解决问题的思路 </a> </li> <li class=md-nav__item> <a href=../../../leetcode/code_interviews_5/ class=md-nav__link> 优化时间和空间效率 </a> </li> <li class=md-nav__item> <a href=../../../leetcode/code_interviews_6/ class=md-nav__link> 面试中的各项能力 </a> </li> <li class=md-nav__item> <a href=../../../leetcode/array/ class=md-nav__link> Array </a> </li> <li class=md-nav__item> <a href=../../../leetcode/leetcode1-10/ class=md-nav__link> LeetCode(1-10) </a> </li> <li class=md-nav__item> <a href=../../../leetcode/leetcode11-20/ class=md-nav__link> LeetCode(11-20) </a> </li> <li class=md-nav__item> <a href=../../../leetcode/leetcode21-30/ class=md-nav__link> LeetCode(21-30) </a> </li> <li class=md-nav__item> <a href=../../../leetcode/leetcode31-40/ class=md-nav__link> LeetCode(31-40) </a> </li> <li class=md-nav__item> <a href=../../../leetcode/leetcode41-50/ class=md-nav__link> LeetCode(41-50) </a> </li> <li class=md-nav__item> <a href=../../../leetcode/leetcode51-60/ class=md-nav__link> LeetCode(51-60) </a> </li> <li class=md-nav__item> <a href=../../../leetcode/leetcode61-70/ class=md-nav__link> LeetCode(61-70) </a> </li> <li class=md-nav__item> <a href=../../../leetcode/leetcode71-80/ class=md-nav__link> LeetCode(71-80) </a> </li> <li class=md-nav__item> <a href=../../../leetcode/leetcode81-90/ class=md-nav__link> LeetCode(81-90) </a> </li> <li class=md-nav__item> <a href=../../../leetcode/leetcode91-100/ class=md-nav__link> LeetCode(91-100) </a> </li> <li class=md-nav__item> <a href=../../../leetcode/leetcode101-110/ class=md-nav__link> LeetCode(101-110) </a> </li> <li class=md-nav__item> <a href=../../../leetcode/leetcode111-120/ class=md-nav__link> LeetCode(111-120) </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-4 type=checkbox id=nav-4> <label class=md-nav__link for=nav-4> Books <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Books data-md-level=1> <label class=md-nav__title for=nav-4> <span class="md-nav__icon md-icon"></span> Books </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-4-1 type=checkbox id=nav-4-1> <label class=md-nav__link for=nav-4-1> Design Pattern <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label="Design Pattern" data-md-level=2> <label class=md-nav__title for=nav-4-1> <span class="md-nav__icon md-icon"></span> Design Pattern </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../design-pattern/design-pattern/ class=md-nav__link> 设计模式概述 </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/design-principle/ class=md-nav__link> 面向对象的六大原则 </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/singleton/ class=md-nav__link> 单例模式(Singleton) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/builder/ class=md-nav__link> 建造者模式(Builder) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/prototype/ class=md-nav__link> 原型模式(Prototype) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/factory-method/ class=md-nav__link> 工厂方法模式(Factory method) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/abstract-factory/ class=md-nav__link> 抽象工厂模式(Abstract factory) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/proxy/ class=md-nav__link> 代理模式(Proxy) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/composite/ class=md-nav__link> 组合模式(Composite) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/adapter/ class=md-nav__link> 适配器模式(Adapter) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/decorator/ class=md-nav__link> 装饰模式(Decorator) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/flyweight/ class=md-nav__link> 享元模式(Flyweight) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/facade/ class=md-nav__link> 外观模式(Facade) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/bridge/ class=md-nav__link> 桥接模式(Bridge) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/strategy/ class=md-nav__link> 策略模式(Strategy) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/state/ class=md-nav__link> 状态模式(State) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/chain-of-responsibility/ class=md-nav__link> 责任链模式(Chain of responsibility) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/interpreter/ class=md-nav__link> 解释器模式(Interpreter) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/command/ class=md-nav__link> 命令模式(Command) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/observer/ class=md-nav__link> 观察者模式(Observer) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/memento/ class=md-nav__link> 备忘录模式(Memento) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/iterator/ class=md-nav__link> 迭代器模式(Iterator) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/template-method/ class=md-nav__link> 模版方法模式(Template method) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/visitor/ class=md-nav__link> 访问者模式(Visitor) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/mediator/ class=md-nav__link> 中介者模式(Mediator) </a> </li> <li class=md-nav__item> <a href=../../../design-pattern/confusing-design-pattern/ class=md-nav__link> 易混淆的设计模式 </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-4-2 type=checkbox id=nav-4-2> <label class=md-nav__link for=nav-4-2> Effective Java <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label="Effective Java" data-md-level=2> <label class=md-nav__title for=nav-4-2> <span class="md-nav__icon md-icon"></span> Effective Java </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../effective-java/effective-java/ class=md-nav__link> Effective Java概述 </a> </li> <li class=md-nav__item> <a href=../../../effective-java/chapter1/ class=md-nav__link> 创建和销毁对象 </a> </li> <li class=md-nav__item> <a href=../../../effective-java/chapter2/ class=md-nav__link> 对于所有对象都通用的方法 </a> </li> <li class=md-nav__item> <a href=../../../effective-java/chapter3/ class=md-nav__link> 类和接口 </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-4-3 type=checkbox id=nav-4-3> <label class=md-nav__link for=nav-4-3> JVM <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=JVM data-md-level=2> <label class=md-nav__title for=nav-4-3> <span class="md-nav__icon md-icon"></span> JVM </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../jvm/jvm-content/ class=md-nav__link> 深入理解Java虚拟机 </a> </li> <li class=md-nav__item> <a href=../../../jvm/java-memory-area-oom/ class=md-nav__link> Java内存区域与内存溢出异常 </a> </li> <li class=md-nav__item> <a href=../../../jvm/java-gc/ class=md-nav__link> 垃圾收集器与内存分配策略 </a> </li> <li class=md-nav__item> <a href=../../../jvm/class-struct/ class=md-nav__link> 类文件结构 </a> </li> <li class=md-nav__item> <a href=../../../jvm/load-class/ class=md-nav__link> 虚拟机类加载机制 </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-4-4 type=checkbox id=nav-4-4> <label class=md-nav__link for=nav-4-4> Java <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Java data-md-level=2> <label class=md-nav__title for=nav-4-4> <span class="md-nav__icon md-icon"></span> Java </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../java/generics-java-kotlin/ class=md-nav__link> Java&Kotlin在泛型方面的区别 </a> </li> <li class=md-nav__item> <a href=../../../java/java-collections/ class=md-nav__link> Java集合总结 </a> </li> <li class=md-nav__item> <a href=../../../java/java-foundation/ class=md-nav__link> Java常见概念 </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-4-5 type=checkbox id=nav-4-5> <label class=md-nav__link for=nav-4-5> Refactoring <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Refactoring data-md-level=2> <label class=md-nav__title for=nav-4-5> <span class="md-nav__icon md-icon"></span> Refactoring </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../refactoring/refactoring/ class=md-nav__link> 重构：改善既有代码的设计 </a> </li> </ul> </nav> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label=目录> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> 目录 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=#1-service-manager class=md-nav__link> 1 Service Manager是如何成为守护进程的 </a> </li> <li class=md-nav__item> <a href=#2-binderserverclientservice-manager class=md-nav__link> 2 Binder中的Server和Client获得Service Manager接口之路 </a> </li> <li class=md-nav__item> <a href=#3-service-managerserverserver class=md-nav__link> 3 Service Manager在Server的启动中是如何为Server提供服务的 </a> </li> <li class=md-nav__item> <a href=#4-clientserver class=md-nav__link> 4 Client如何获得Server的远程接口 </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content> <article class="md-content__inner md-typeset"> <h1>Binder深入理解——罗老师系列</h1> <p>本博客Binder系列：</p> <ol> <li><a href=/android/paid/zsxq/week11-binder/ >Binder简介</a></li> <li><a href=/android/framework/binder1-mediaservice/ >Binder深入理解——以MediaService为例</a>，基于<a href=http://www.cnblogs.com/innost/archive/2011/01/09/1931456.html>Android深入浅出之Binder机制</a></li> <li><a href=/android/framework/binder2/ >Binder深入理解——罗老师系列</a>，基于<a href=https://blog.csdn.net/luoshengyang/article/details/6618363>Android进程间通信（IPC）机制Binder简要介绍和学习计划</a></li> </ol> <hr> <h2 id=1-service-manager>1 <a href=https://blog.csdn.net/luoshengyang/article/details/6621566>Service Manager是如何成为守护进程的</a><a class=headerlink href=#1-service-manager title="Permanent link">&para;</a></h2> <p>本节着重介绍组件Service Manager，它是整个Binder机制的守护进程，用来管理开发者创建的各种Server，并且向Client提供查询Server远程接口的功能。 </p> <p>既然Service Manager组件是用来管理Server并且向Client提供查询Server远程接口的功能，那么，Service Manager就必然要和Server以及Client进行通信了。我们知道，Service Manger、Client和Server三者分别是运行在独立的进程当中，这样它们之间的通信也属于进程间通信了，而且也是采用Binder机制进行进程间通信，因此，Service Manager在充当Binder机制的守护进程的角色的同时，也在充当Server的角色，然而，它是一种特殊的Server，下面我们将会看到它的特殊之处。</p> <p>在第2.1.8-BnServiceManager中，我们简单谈到了这部分内容，本节会进行更加深入的讲解。 </p> <p>本章kernel源码地址为<a href=https://android.googlesource.com/kernel/goldfish.git>https://android.googlesource.com/kernel/goldfish.git</a>，分支名为<a href=https://android.googlesource.com/kernel/goldfish.git/+/android-goldfish-2.6.29>android-goldfish-2.6.29</a></p> <p>Service Manager的main函数有三个功能：</p> <ol> <li>打开Binder设备文件</li> <li>告诉Binder驱动程序自己是Binder上下文管理者，即守护线程</li> <li>进入无穷循环，充当Server的角色，等待Client的请求</li> </ol> <p><strong>frameworks/base/cmds/servicemanager/service_manager.c</strong></p> <div class=highlight><pre><span></span><code><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>struct</span> <span class=nc>binder_state</span> <span class=o>*</span><span class=n>bs</span><span class=p>;</span>
    <span class=kt>void</span> <span class=o>*</span><span class=n>svcmgr</span> <span class=o>=</span> <span class=n>BINDER_SERVICE_MANAGER</span><span class=p>;</span>

    <span class=n>bs</span> <span class=o>=</span> <span class=n>binder_open</span><span class=p>(</span><span class=mi>128</span><span class=o>*</span><span class=mi>1024</span><span class=p>);</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>binder_become_context_manager</span><span class=p>(</span><span class=n>bs</span><span class=p>))</span> <span class=p>{</span>
        <span class=n>LOGE</span><span class=p>(</span><span class=s>&quot;cannot become context manager (%s)</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span> <span class=n>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
        <span class=k>return</span> <span class=mi>-1</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=n>svcmgr_handle</span> <span class=o>=</span> <span class=n>svcmgr</span><span class=p>;</span>
    <span class=n>binder_loop</span><span class=p>(</span><span class=n>bs</span><span class=p>,</span> <span class=n>svcmgr_handler</span><span class=p>);</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p><code>binder_state</code>结构体描述如下：</p> <p><strong>frameworks/base/cmds/servicemanager/binder.c</strong> <div class=highlight><pre><span></span><code><span class=k>struct</span> <span class=nc>binder_state</span>
<span class=p>{</span>
    <span class=kt>int</span> <span class=n>fd</span><span class=p>;</span>               <span class=c1>// 打开/dev/binder设备文件描述符</span>
    <span class=kt>void</span> <span class=o>*</span><span class=n>mapped</span><span class=p>;</span>         <span class=c1>// 设备文件/dev/binder映射到进程控件的起始地址</span>
    <span class=kt>unsigned</span> <span class=n>mapsize</span><span class=p>;</span>     <span class=c1>// 上述内存映射空间的大小</span>
<span class=p>};</span>
</code></pre></div></p> <p>宏<code>BINDER_SERVICE_MANAGER</code>定义在 <strong>frameworks/base/cmds/servicemanager/binder.h</strong> 中</p> <div class=highlight><pre><span></span><code><span class=cp>#define BINDER_SERVICE_MANAGER ((void*) 0)</span>
</code></pre></div> <p>它表示Service Manager的句柄为0。Binder通信机制使用句柄来代表远程接口，这个句柄的意义和Windows编程中用到的句柄是差不多的概念。<br> 前面说到，Service Manager在充当守护进程的同时，它充当Server的角色，当它作为远程接口使用时，它的句柄值便为0，这就是它的特殊之处，其余的Server的远程接口句柄值都是一个大于0，而且由Binder驱动程序自动进行分配的。</p> <p><code>main</code>函数首先执行<code>binder_open</code>打开Binder设备文件：</p> <div class=highlight><pre><span></span><code><span class=k>struct</span> <span class=nc>binder_state</span> <span class=o>*</span><span class=n>binder_open</span><span class=p>(</span><span class=kt>unsigned</span> <span class=n>mapsize</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>struct</span> <span class=nc>binder_state</span> <span class=o>*</span><span class=n>bs</span><span class=p>;</span>

    <span class=n>bs</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=n>bs</span><span class=p>));</span>
    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>bs</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>errno</span> <span class=o>=</span> <span class=n>ENOMEM</span><span class=p>;</span>
        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=n>bs</span><span class=o>-&gt;</span><span class=n>fd</span> <span class=o>=</span> <span class=n>open</span><span class=p>(</span><span class=s>&quot;/dev/binder&quot;</span><span class=p>,</span> <span class=n>O_RDWR</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>bs</span><span class=o>-&gt;</span><span class=n>fd</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&quot;binder: cannot open device (%s)</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span>
                <span class=n>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
        <span class=k>goto</span> <span class=n>fail_open</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=n>bs</span><span class=o>-&gt;</span><span class=n>mapsize</span> <span class=o>=</span> <span class=n>mapsize</span><span class=p>;</span>
    <span class=n>bs</span><span class=o>-&gt;</span><span class=n>mapped</span> <span class=o>=</span> <span class=n>mmap</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=n>mapsize</span><span class=p>,</span> <span class=n>PROT_READ</span><span class=p>,</span> <span class=n>MAP_PRIVATE</span><span class=p>,</span> <span class=n>bs</span><span class=o>-&gt;</span><span class=n>fd</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>bs</span><span class=o>-&gt;</span><span class=n>mapped</span> <span class=o>==</span> <span class=n>MAP_FAILED</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&quot;binder: cannot map device (%s)</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span>
                <span class=n>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
        <span class=k>goto</span> <span class=n>fail_map</span><span class=p>;</span>
    <span class=p>}</span>

        <span class=cm>/* TODO: check version */</span>

    <span class=k>return</span> <span class=n>bs</span><span class=p>;</span>

<span class=nl>fail_map</span><span class=p>:</span>
    <span class=n>close</span><span class=p>(</span><span class=n>bs</span><span class=o>-&gt;</span><span class=n>fd</span><span class=p>);</span>
<span class=nl>fail_open</span><span class=p>:</span>
    <span class=n>free</span><span class=p>(</span><span class=n>bs</span><span class=p>);</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>通过文件操作函数<code>open</code>来打开/dev/binder设备文件。<br> 设备文件/dev/binder是在Binder驱动程序模块初始化的时候创建的，我们先看一下这个设备文件的创建过程。<br> 先可以看到模块初始化入口<code>binder_init</code>：</p> <p><strong>kernel/drivers/staging/android/binder.c</strong></p> <div class=highlight><pre><span></span><code><span class=k>static</span> <span class=k>struct</span> <span class=nc>file_operations</span> <span class=n>binder_fops</span> <span class=o>=</span> <span class=p>{</span>
    <span class=p>.</span><span class=n>owner</span> <span class=o>=</span> <span class=n>THIS_MODULE</span><span class=p>,</span>
    <span class=p>.</span><span class=n>poll</span> <span class=o>=</span> <span class=n>binder_poll</span><span class=p>,</span>
    <span class=p>.</span><span class=n>unlocked_ioctl</span> <span class=o>=</span> <span class=n>binder_ioctl</span><span class=p>,</span>
    <span class=p>.</span><span class=n>mmap</span> <span class=o>=</span> <span class=n>binder_mmap</span><span class=p>,</span>
    <span class=p>.</span><span class=n>open</span> <span class=o>=</span> <span class=n>binder_open</span><span class=p>,</span>
    <span class=p>.</span><span class=n>flush</span> <span class=o>=</span> <span class=n>binder_flush</span><span class=p>,</span>
    <span class=p>.</span><span class=n>release</span> <span class=o>=</span> <span class=n>binder_release</span><span class=p>,</span>
<span class=p>};</span>

<span class=k>static</span> <span class=k>struct</span> <span class=nc>miscdevice</span> <span class=n>binder_miscdev</span> <span class=o>=</span> <span class=p>{</span>
    <span class=p>.</span><span class=n>minor</span> <span class=o>=</span> <span class=n>MISC_DYNAMIC_MINOR</span><span class=p>,</span>
    <span class=p>.</span><span class=n>name</span> <span class=o>=</span> <span class=s>&quot;binder&quot;</span><span class=p>,</span>
    <span class=p>.</span><span class=n>fops</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>binder_fops</span>
<span class=p>};</span>

<span class=k>static</span> <span class=kt>int</span> <span class=n>__init</span> <span class=n>binder_init</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>int</span> <span class=n>ret</span><span class=p>;</span>

    <span class=n>binder_proc_dir_entry_root</span> <span class=o>=</span> <span class=n>proc_mkdir</span><span class=p>(</span><span class=s>&quot;binder&quot;</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>binder_proc_dir_entry_root</span><span class=p>)</span>
        <span class=n>binder_proc_dir_entry_proc</span> <span class=o>=</span> <span class=n>proc_mkdir</span><span class=p>(</span><span class=s>&quot;proc&quot;</span><span class=p>,</span> <span class=n>binder_proc_dir_entry_root</span><span class=p>);</span>
    <span class=n>ret</span> <span class=o>=</span> <span class=n>misc_register</span><span class=p>(</span><span class=o>&amp;</span><span class=n>binder_miscdev</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>binder_proc_dir_entry_root</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>create_proc_read_entry</span><span class=p>(</span><span class=s>&quot;state&quot;</span><span class=p>,</span> <span class=n>S_IRUGO</span><span class=p>,</span> <span class=n>binder_proc_dir_entry_root</span><span class=p>,</span> <span class=n>binder_read_proc_state</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
        <span class=n>create_proc_read_entry</span><span class=p>(</span><span class=s>&quot;stats&quot;</span><span class=p>,</span> <span class=n>S_IRUGO</span><span class=p>,</span> <span class=n>binder_proc_dir_entry_root</span><span class=p>,</span> <span class=n>binder_read_proc_stats</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
        <span class=n>create_proc_read_entry</span><span class=p>(</span><span class=s>&quot;transactions&quot;</span><span class=p>,</span> <span class=n>S_IRUGO</span><span class=p>,</span> <span class=n>binder_proc_dir_entry_root</span><span class=p>,</span> <span class=n>binder_read_proc_transactions</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
        <span class=n>create_proc_read_entry</span><span class=p>(</span><span class=s>&quot;transaction_log&quot;</span><span class=p>,</span> <span class=n>S_IRUGO</span><span class=p>,</span> <span class=n>binder_proc_dir_entry_root</span><span class=p>,</span> <span class=n>binder_read_proc_transaction_log</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>binder_transaction_log</span><span class=p>);</span>
        <span class=n>create_proc_read_entry</span><span class=p>(</span><span class=s>&quot;failed_transaction_log&quot;</span><span class=p>,</span> <span class=n>S_IRUGO</span><span class=p>,</span> <span class=n>binder_proc_dir_entry_root</span><span class=p>,</span> <span class=n>binder_read_proc_transaction_log</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>binder_transaction_log_failed</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>创建设备文件的地方在<code>misc_register</code>函数里。<code>binder_init</code>函数的其他逻辑主要是在/proc目录创建各种Binder相关的文件，供用户访问。 </p> <p>从设备文件的操作方法<code>binder_fops</code>可以看出，前面的<code>binder_open</code>函数执行语句<code>open("/dev/binder", O_RDWR)</code>就进入Binder驱动程序的<code>binder_open</code>函数了。</p> <div class=highlight><pre><span></span><code><span class=k>static</span> <span class=kt>int</span> <span class=n>binder_open</span><span class=p>(</span><span class=k>struct</span> <span class=nc>inode</span> <span class=o>*</span><span class=n>nodp</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>file</span> <span class=o>*</span><span class=n>filp</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>struct</span> <span class=nc>binder_proc</span> <span class=o>*</span><span class=n>proc</span><span class=p>;</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>binder_debug_mask</span> <span class=o>&amp;</span> <span class=n>BINDER_DEBUG_OPEN_CLOSE</span><span class=p>)</span>
        <span class=n>printk</span><span class=p>(</span><span class=n>KERN_INFO</span> <span class=s>&quot;binder_open: %d:%d</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span> <span class=n>current</span><span class=o>-&gt;</span><span class=n>group_leader</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=n>current</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>);</span>

    <span class=n>proc</span> <span class=o>=</span> <span class=n>kzalloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=n>proc</span><span class=p>),</span> <span class=n>GFP_KERNEL</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>proc</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
        <span class=k>return</span> <span class=o>-</span><span class=n>ENOMEM</span><span class=p>;</span>
    <span class=n>get_task_struct</span><span class=p>(</span><span class=n>current</span><span class=p>);</span>
    <span class=n>proc</span><span class=o>-&gt;</span><span class=n>tsk</span> <span class=o>=</span> <span class=n>current</span><span class=p>;</span>
    <span class=n>INIT_LIST_HEAD</span><span class=p>(</span><span class=o>&amp;</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>);</span>
    <span class=n>init_waitqueue_head</span><span class=p>(</span><span class=o>&amp;</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>wait</span><span class=p>);</span>
    <span class=n>proc</span><span class=o>-&gt;</span><span class=n>default_priority</span> <span class=o>=</span> <span class=n>task_nice</span><span class=p>(</span><span class=n>current</span><span class=p>);</span>
    <span class=n>mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>binder_lock</span><span class=p>);</span>
    <span class=n>binder_stats</span><span class=p>.</span><span class=n>obj_created</span><span class=p>[</span><span class=n>BINDER_STAT_PROC</span><span class=p>]</span><span class=o>++</span><span class=p>;</span>
    <span class=n>hlist_add_head</span><span class=p>(</span><span class=o>&amp;</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>proc_node</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>binder_procs</span><span class=p>);</span>
    <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pid</span> <span class=o>=</span> <span class=n>current</span><span class=o>-&gt;</span><span class=n>group_leader</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>;</span>
    <span class=n>INIT_LIST_HEAD</span><span class=p>(</span><span class=o>&amp;</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>delivered_death</span><span class=p>);</span>    <span class=c1>// 2</span>
    <span class=n>filp</span><span class=o>-&gt;</span><span class=n>private_data</span> <span class=o>=</span> <span class=n>proc</span><span class=p>;</span>                 <span class=c1>// 1</span>
    <span class=n>mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>binder_lock</span><span class=p>);</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>binder_proc_dir_entry_proc</span><span class=p>)</span> <span class=p>{</span>
        <span class=kt>char</span> <span class=n>strbuf</span><span class=p>[</span><span class=mi>11</span><span class=p>];</span>
        <span class=n>snprintf</span><span class=p>(</span><span class=n>strbuf</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>strbuf</span><span class=p>),</span> <span class=s>&quot;%u&quot;</span><span class=p>,</span> <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>);</span>
        <span class=n>remove_proc_entry</span><span class=p>(</span><span class=n>strbuf</span><span class=p>,</span> <span class=n>binder_proc_dir_entry_proc</span><span class=p>);</span>
        <span class=n>create_proc_read_entry</span><span class=p>(</span><span class=n>strbuf</span><span class=p>,</span> <span class=n>S_IRUGO</span><span class=p>,</span> <span class=n>binder_proc_dir_entry_proc</span><span class=p>,</span> <span class=n>binder_read_proc_proc</span><span class=p>,</span> <span class=n>proc</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>这个函数的主要作用是创建一个struct<code>binder_proc</code>数据结构来保存打开设备文件/dev/binder的进程的上下文信息，并且将这个进程上下文信息保存在打开文件结构struct<code>file</code>的私有数据成员变量<code>private_data</code>中。这样，在执行其它文件操作时，就通过打开文件结构struct<code>file</code>来取回这个进程上下文信息了。这个进程上下文信息同时还会保存在一个全局哈希表<code>binder_procs</code>中，驱动程序内部使用。</p> <div class=highlight><pre><span></span><code><span class=k>static</span> <span class=nf>HLIST_HEAD</span><span class=p>(</span><span class=n>binder_procs</span><span class=p>);</span>
</code></pre></div> <p>结构体<code>binder_proc</code>的定义如下，rb_root表示红黑树：</p> <div class=highlight><pre><span></span><code><span class=k>struct</span> <span class=nc>binder_proc</span> <span class=p>{</span>
    <span class=k>struct</span> <span class=nc>hlist_node</span> <span class=n>proc_node</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>rb_root</span> <span class=n>threads</span><span class=p>;</span>          <span class=c1>// 保存binder_proc进程内用于处理用户请求的线程，最大数量由max_threads决定</span>
    <span class=k>struct</span> <span class=nc>rb_root</span> <span class=n>nodes</span><span class=p>;</span>            <span class=c1>// 保存binder_proc进程内的Binder实体</span>
    <span class=c1>// 下面两个都表示保存binder_proc进程内的Binder引用，即引用的其它进程的Binder实体</span>
    <span class=k>struct</span> <span class=nc>rb_root</span> <span class=n>refs_by_desc</span><span class=p>;</span>     <span class=c1>// 以句柄为key值</span>
    <span class=k>struct</span> <span class=nc>rb_root</span> <span class=n>refs_by_node</span><span class=p>;</span>     <span class=c1>// 以引用的实体节点的地址值为key值</span>
    <span class=kt>int</span> <span class=n>pid</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>vm_area_struct</span> <span class=o>*</span><span class=n>vma</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>task_struct</span> <span class=o>*</span><span class=n>tsk</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>files_struct</span> <span class=o>*</span><span class=n>files</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>hlist_node</span> <span class=n>deferred_work_node</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>deferred_work</span><span class=p>;</span>
    <span class=kt>void</span> <span class=o>*</span><span class=n>buffer</span><span class=p>;</span>                    <span class=c1>// 表示要映射的物理内存在内核空间中的起始位置</span>
    <span class=c1>// 内核使用的虚拟地址与进程使用的虚拟地址之间的差值</span>
    <span class=c1>// 即如果某个物理页面在内核空间中对应的虚拟地址是addr的话</span>
    <span class=c1>// 那么这个物理页面在进程空间对应的虚拟地址就为addr + user_buffer_offset</span>
    <span class=kt>ptrdiff_t</span> <span class=n>user_buffer_offset</span><span class=p>;</span>

    <span class=k>struct</span> <span class=nc>list_head</span> <span class=n>buffers</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>rb_root</span> <span class=n>free_buffers</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>rb_root</span> <span class=n>allocated_buffers</span><span class=p>;</span>
    <span class=kt>size_t</span> <span class=n>free_async_space</span><span class=p>;</span>

    <span class=k>struct</span> <span class=nc>page</span> <span class=o>**</span><span class=n>pages</span><span class=p>;</span>             <span class=c1>// struct page是用来描述物理页面的数据结构</span>
    <span class=kt>size_t</span> <span class=n>buffer_size</span><span class=p>;</span>              <span class=c1>// 要映射的内存的大小</span>
    <span class=kt>uint32_t</span> <span class=n>buffer_free</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>list_head</span> <span class=n>todo</span><span class=p>;</span>
    <span class=n>wait_queue_head_t</span> <span class=n>wait</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>binder_stats</span> <span class=n>stats</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>list_head</span> <span class=n>delivered_death</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>max_threads</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>requested_threads</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>requested_threads_started</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>ready_threads</span><span class=p>;</span>
    <span class=kt>long</span> <span class=n>default_priority</span><span class=p>;</span>
<span class=p>};</span>
</code></pre></div> <p>这样设备文件/dev/binder就打开了，接着是对打开的设备文件进行内存映射操作<code>mmap(NULL, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, 0)</code>，对应Binder驱动程序的<code>binder_mmap</code>操作：</p> <div class=highlight><pre><span></span><code><span class=k>static</span> <span class=kt>int</span> <span class=n>binder_mmap</span><span class=p>(</span><span class=k>struct</span> <span class=nc>file</span> <span class=o>*</span><span class=n>filp</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>vm_area_struct</span> <span class=o>*</span><span class=n>vma</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>int</span> <span class=n>ret</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>vm_struct</span> <span class=o>*</span><span class=n>area</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>binder_proc</span> <span class=o>*</span><span class=n>proc</span> <span class=o>=</span> <span class=n>filp</span><span class=o>-&gt;</span><span class=n>private_data</span><span class=p>;</span>
    <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>failure_string</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>binder_buffer</span> <span class=o>*</span><span class=n>buffer</span><span class=p>;</span>

    <span class=k>if</span> <span class=p>((</span><span class=n>vma</span><span class=o>-&gt;</span><span class=n>vm_end</span> <span class=o>-</span> <span class=n>vma</span><span class=o>-&gt;</span><span class=n>vm_start</span><span class=p>)</span> <span class=o>&gt;</span> <span class=n>SZ_4M</span><span class=p>)</span>
        <span class=n>vma</span><span class=o>-&gt;</span><span class=n>vm_end</span> <span class=o>=</span> <span class=n>vma</span><span class=o>-&gt;</span><span class=n>vm_start</span> <span class=o>+</span> <span class=n>SZ_4M</span><span class=p>;</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>binder_debug_mask</span> <span class=o>&amp;</span> <span class=n>BINDER_DEBUG_OPEN_CLOSE</span><span class=p>)</span>
        <span class=n>printk</span><span class=p>(</span><span class=n>KERN_INFO</span>
            <span class=s>&quot;binder_mmap: %d %lx-%lx (%ld K) vma %lx pagep %lx</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span>
            <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=n>vma</span><span class=o>-&gt;</span><span class=n>vm_start</span><span class=p>,</span> <span class=n>vma</span><span class=o>-&gt;</span><span class=n>vm_end</span><span class=p>,</span>
            <span class=p>(</span><span class=n>vma</span><span class=o>-&gt;</span><span class=n>vm_end</span> <span class=o>-</span> <span class=n>vma</span><span class=o>-&gt;</span><span class=n>vm_start</span><span class=p>)</span> <span class=o>/</span> <span class=n>SZ_1K</span><span class=p>,</span> <span class=n>vma</span><span class=o>-&gt;</span><span class=n>vm_flags</span><span class=p>,</span>
            <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)</span><span class=n>pgprot_val</span><span class=p>(</span><span class=n>vma</span><span class=o>-&gt;</span><span class=n>vm_page_prot</span><span class=p>));</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>vma</span><span class=o>-&gt;</span><span class=n>vm_flags</span> <span class=o>&amp;</span> <span class=n>FORBIDDEN_MMAP_FLAGS</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>EPERM</span><span class=p>;</span>
        <span class=n>failure_string</span> <span class=o>=</span> <span class=s>&quot;bad vm_flags&quot;</span><span class=p>;</span>
        <span class=k>goto</span> <span class=n>err_bad_arg</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>vma</span><span class=o>-&gt;</span><span class=n>vm_flags</span> <span class=o>=</span> <span class=p>(</span><span class=n>vma</span><span class=o>-&gt;</span><span class=n>vm_flags</span> <span class=o>|</span> <span class=n>VM_DONTCOPY</span><span class=p>)</span> <span class=o>&amp;</span> <span class=o>~</span><span class=n>VM_MAYWRITE</span><span class=p>;</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>EBUSY</span><span class=p>;</span>
        <span class=n>failure_string</span> <span class=o>=</span> <span class=s>&quot;already mapped&quot;</span><span class=p>;</span>
        <span class=k>goto</span> <span class=n>err_already_mapped</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=n>area</span> <span class=o>=</span> <span class=n>get_vm_area</span><span class=p>(</span><span class=n>vma</span><span class=o>-&gt;</span><span class=n>vm_end</span> <span class=o>-</span> <span class=n>vma</span><span class=o>-&gt;</span><span class=n>vm_start</span><span class=p>,</span> <span class=n>VM_IOREMAP</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>area</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>ENOMEM</span><span class=p>;</span>
        <span class=n>failure_string</span> <span class=o>=</span> <span class=s>&quot;get_vm_area&quot;</span><span class=p>;</span>
        <span class=k>goto</span> <span class=n>err_get_vm_area_failed</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>proc</span><span class=o>-&gt;</span><span class=n>buffer</span> <span class=o>=</span> <span class=n>area</span><span class=o>-&gt;</span><span class=n>addr</span><span class=p>;</span>
    <span class=n>proc</span><span class=o>-&gt;</span><span class=n>user_buffer_offset</span> <span class=o>=</span> <span class=n>vma</span><span class=o>-&gt;</span><span class=n>vm_start</span> <span class=o>-</span> <span class=p>(</span><span class=kt>uintptr_t</span><span class=p>)</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=p>;</span>

<span class=cp>#ifdef CONFIG_CPU_CACHE_VIPT</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>cache_is_vipt_aliasing</span><span class=p>())</span> <span class=p>{</span>
        <span class=k>while</span> <span class=p>(</span><span class=n>CACHE_COLOUR</span><span class=p>((</span><span class=n>vma</span><span class=o>-&gt;</span><span class=n>vm_start</span> <span class=o>^</span> <span class=p>(</span><span class=kt>uint32_t</span><span class=p>)</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=p>)))</span> <span class=p>{</span>
            <span class=n>printk</span><span class=p>(</span><span class=n>KERN_INFO</span> <span class=s>&quot;binder_mmap: %d %lx-%lx maps %p bad alignment</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span> <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=n>vma</span><span class=o>-&gt;</span><span class=n>vm_start</span><span class=p>,</span> <span class=n>vma</span><span class=o>-&gt;</span><span class=n>vm_end</span><span class=p>,</span> <span class=n>proc</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=p>);</span>
            <span class=n>vma</span><span class=o>-&gt;</span><span class=n>vm_start</span> <span class=o>+=</span> <span class=n>PAGE_SIZE</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=cp>#endif</span>
    <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pages</span> <span class=o>=</span> <span class=n>kzalloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>pages</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=o>*</span> <span class=p>((</span><span class=n>vma</span><span class=o>-&gt;</span><span class=n>vm_end</span> <span class=o>-</span> <span class=n>vma</span><span class=o>-&gt;</span><span class=n>vm_start</span><span class=p>)</span> <span class=o>/</span> <span class=n>PAGE_SIZE</span><span class=p>),</span> <span class=n>GFP_KERNEL</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>pages</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>ENOMEM</span><span class=p>;</span>
        <span class=n>failure_string</span> <span class=o>=</span> <span class=s>&quot;alloc page array&quot;</span><span class=p>;</span>
        <span class=k>goto</span> <span class=n>err_alloc_pages_failed</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>proc</span><span class=o>-&gt;</span><span class=n>buffer_size</span> <span class=o>=</span> <span class=n>vma</span><span class=o>-&gt;</span><span class=n>vm_end</span> <span class=o>-</span> <span class=n>vma</span><span class=o>-&gt;</span><span class=n>vm_start</span><span class=p>;</span>

    <span class=n>vma</span><span class=o>-&gt;</span><span class=n>vm_ops</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>binder_vm_ops</span><span class=p>;</span>
    <span class=n>vma</span><span class=o>-&gt;</span><span class=n>vm_private_data</span> <span class=o>=</span> <span class=n>proc</span><span class=p>;</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>binder_update_page_range</span><span class=p>(</span><span class=n>proc</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>proc</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=p>,</span> <span class=n>proc</span><span class=o>-&gt;</span><span class=n>buffer</span> <span class=o>+</span> <span class=n>PAGE_SIZE</span><span class=p>,</span> <span class=n>vma</span><span class=p>))</span> <span class=p>{</span>
        <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>ENOMEM</span><span class=p>;</span>
        <span class=n>failure_string</span> <span class=o>=</span> <span class=s>&quot;alloc small buf&quot;</span><span class=p>;</span>
        <span class=k>goto</span> <span class=n>err_alloc_small_buf_failed</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>buffer</span> <span class=o>=</span> <span class=n>proc</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=p>;</span>
    <span class=n>INIT_LIST_HEAD</span><span class=p>(</span><span class=o>&amp;</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>buffers</span><span class=p>);</span>
    <span class=n>list_add</span><span class=p>(</span><span class=o>&amp;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>entry</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>buffers</span><span class=p>);</span>
    <span class=n>buffer</span><span class=o>-&gt;</span><span class=n>free</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
    <span class=n>binder_insert_free_buffer</span><span class=p>(</span><span class=n>proc</span><span class=p>,</span> <span class=n>buffer</span><span class=p>);</span>
    <span class=n>proc</span><span class=o>-&gt;</span><span class=n>free_async_space</span> <span class=o>=</span> <span class=n>proc</span><span class=o>-&gt;</span><span class=n>buffer_size</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span>
    <span class=n>barrier</span><span class=p>();</span>
    <span class=n>proc</span><span class=o>-&gt;</span><span class=n>files</span> <span class=o>=</span> <span class=n>get_files_struct</span><span class=p>(</span><span class=n>current</span><span class=p>);</span>
    <span class=n>proc</span><span class=o>-&gt;</span><span class=n>vma</span> <span class=o>=</span> <span class=n>vma</span><span class=p>;</span>

    <span class=cm>/*printk(KERN_INFO &quot;binder_mmap: %d %lx-%lx maps %p\n&quot;, proc-&gt;pid, vma-&gt;vm_start, vma-&gt;vm_end, proc-&gt;buffer);*/</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>

<span class=nl>err_alloc_small_buf_failed</span><span class=p>:</span>
    <span class=n>kfree</span><span class=p>(</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>pages</span><span class=p>);</span>
    <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pages</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
<span class=nl>err_alloc_pages_failed</span><span class=p>:</span>
    <span class=n>vfree</span><span class=p>(</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=p>);</span>
    <span class=n>proc</span><span class=o>-&gt;</span><span class=n>buffer</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
<span class=nl>err_get_vm_area_failed</span><span class=p>:</span>
<span class=nl>err_already_mapped</span><span class=p>:</span>
<span class=nl>err_bad_arg</span><span class=p>:</span>
    <span class=n>printk</span><span class=p>(</span><span class=n>KERN_ERR</span> <span class=s>&quot;binder_mmap: %d %lx-%lx %s failed %d</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span> <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=n>vma</span><span class=o>-&gt;</span><span class=n>vm_start</span><span class=p>,</span> <span class=n>vma</span><span class=o>-&gt;</span><span class=n>vm_end</span><span class=p>,</span> <span class=n>failure_string</span><span class=p>,</span> <span class=n>ret</span><span class=p>);</span>
    <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>函数首先通过<code>filp-&gt;private_data</code>得到在打开设备文件/dev/binder时创建的struct<code>binder_proc</code>结构。内存映射信息放在<code>vma</code>参数中。 </p> <p>注意，这里的<code>vma</code>的数据类型是struct<code>vm_area_struct</code>，它表示的是一块连续的虚拟地址空间区域，在函数变量声明的地方，我们还看到有一个类似的结构体struct<code>vm_struct</code>，这个数据结构也是表示一块连续的虚拟地址空间区域，那么，<strong>这两者的区别是什么呢？</strong><br> 在Linux中，struct<code>vm_area_struct</code>表示的虚拟地址是给进程使用的，而struct<code>vm_struct</code>表示的虚拟地址是给内核使用的，它们对应的物理页面都可以是不连续的。struct<code>vm_area_struct</code>表示的地址空间范围是0~3G，而struct<code>vm_struc</code>t表示的地址空间范围是(3G + 896M + 8M) ~ 4G。<br> struct<code>vm_struct</code>表示的地址空间范围为什么不是3G~4G呢？原来，<strong>3G ~ (3G + 896M)范围的地址是用来映射连续的物理页面的，这个范围的虚拟地址和对应的实际物理地址有着简单的对应关系，即对应0~896M的物理地址空间。而(3G + 896M) ~ (3G + 896M + 8M)是安全保护区域（例如，所有指向这8M地址空间的指针都是非法的）</strong>，因此struct<code>vm_struct</code>使用(3G + 896M + 8M) ~ 4G地址空间来映射非连续的物理页面。</p> <blockquote> <p>有关Linux的内存管理知识，可以参考罗老师的<a href=https://blog.csdn.net/luoshengyang/article/details/6557518>Android学习启动篇</a>一文提到的《Understanding the Linux Kernel》一书中的第8章。</p> </blockquote> <p>这里为什么会同时使用进程虚拟地址空间和内核虚拟地址空间来映射同一个物理页面呢？这就是Binder进程间通信机制的精髓所在了。<strong>同一个物理页面，一方映射到进程虚拟地址空间，一方面映射到内核虚拟地址空间，这样，进程和内核之间就可以减少一次内存拷贝了，提到了进程间通信效率</strong>。举个例子如，Client要将一块内存数据传递给Server，一般的做法是，Client将这块数据从它的进程空间拷贝到内核空间中，然后内核再将这个数据从内核空间拷贝到Server的进程空间，这样，Server就可以访问这个数据了。但是在这种方法中，执行了两次内存拷贝操作，而采用我们上面提到的方法，只需要把Client进程空间的数据拷贝一次到内核空间，然后Server与内核共享这个数据就可以了，整个过程只需要执行一次内存拷贝，提高了效率。</p> <p><code>binder_mmap</code>的原理讲完了，这个函数的逻辑就好理解了。再解释一下Binder驱动程序管理这个内存映射地址空间的方法，即是如何管理buffer ~ (buffer + buffer_size)这段地址空间的，这个地址空间被划分为一段一段来管理，每一段是结构体struct <code>binder_buffer</code>来描述：</p> <div class=highlight><pre><span></span><code><span class=k>struct</span> <span class=nc>binder_buffer</span> <span class=p>{</span>
    <span class=k>struct</span> <span class=nc>list_head</span> <span class=n>entry</span><span class=p>;</span> <span class=cm>/* free and allocated entries by addesss */</span>
    <span class=k>struct</span> <span class=nc>rb_node</span> <span class=n>rb_node</span><span class=p>;</span> <span class=cm>/* free entry by size or allocated entry */</span>
                <span class=cm>/* by address */</span>
    <span class=kt>unsigned</span> <span class=nl>free</span> <span class=p>:</span> <span class=mi>1</span><span class=p>;</span>
    <span class=kt>unsigned</span> <span class=nl>allow_user_free</span> <span class=p>:</span> <span class=mi>1</span><span class=p>;</span>
    <span class=kt>unsigned</span> <span class=nl>async_transaction</span> <span class=p>:</span> <span class=mi>1</span><span class=p>;</span>
    <span class=kt>unsigned</span> <span class=nl>debug_id</span> <span class=p>:</span> <span class=mi>29</span><span class=p>;</span>

    <span class=k>struct</span> <span class=nc>binder_transaction</span> <span class=o>*</span><span class=n>transaction</span><span class=p>;</span>

    <span class=k>struct</span> <span class=nc>binder_node</span> <span class=o>*</span><span class=n>target_node</span><span class=p>;</span>
    <span class=kt>size_t</span> <span class=n>data_size</span><span class=p>;</span>
    <span class=kt>size_t</span> <span class=n>offsets_size</span><span class=p>;</span>
    <span class=kt>uint8_t</span> <span class=n>data</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
<span class=p>};</span>
</code></pre></div> <p>每一个<code>binder_buffer</code>通过其成员<code>entry</code>按从低址到高地址连入到struct <code>binder_proc</code>中的<code>buffers</code>表示的链表中去，同时，每一个<code>binder_buffer</code>又分为正在使用的和空闲的，通过<code>free</code>成员变量来区分，空闲的<code>binder_buffer</code>通过成员变量<code>rb_node</code>连入到struct <code>binder_proc</code>中的<code>free_buffers</code>表示的红黑树中去，正在使用的<code>binder_buffer</code>通过成员变量<code>rb_node</code>连入到struct <code>binder_proc</code>中的<code>allocated_buffers</code>表示的红黑树中去。这样做当然是为了方便查询和维护这块地址空间了，这一点我们可以从其它的代码中看到，等遇到的时候我们再分析。</p> <p>现在回到<code>binder_mmap</code>函数，首先是对参数作一些健康体检（sanity check），例如，要映射的内存大小不能超过SIZE_4M，即4M，回到service_manager.c中的main 函数，这里传进来的值是128 * 1024个字节，即128K。通过健康体检后，调用<code>get_vm_area</code>函数获得一个空闲的<code>vm_struct</code>区间，并初始化<code>proc</code>结构体的<code>buffer</code>、<code>user_buffer_offset</code>、<code>pages</code>和<code>buffer_size</code>成员变量，接着调用<code>binder_update_page_range</code>来为虚拟地址空间proc-&gt;buffer ~ proc-&gt;buffer + PAGE_SIZE分配一个空闲的物理页面，同时这段地址空间使用一个<code>binder_buffer</code>来描述，分别插入到<code>proc-&gt;buffers</code>链表和<code>proc-&gt;free_buffers</code>红黑树中去，最后，还初始化了proc结构体的<code>free_async_space</code>、<code>files</code>和<code>vma</code>三个成员变量。</p> <p>我们进入<code>binder_update_page_range</code>看一下Binder驱动程序是如何实现把一个物理页面同时映射到内核空间和进程空间去的。 </p> <div class=highlight><pre><span></span><code><span class=k>static</span> <span class=kt>int</span> <span class=n>binder_update_page_range</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_proc</span> <span class=o>*</span><span class=n>proc</span><span class=p>,</span> <span class=kt>int</span> <span class=n>allocate</span><span class=p>,</span>
    <span class=kt>void</span> <span class=o>*</span><span class=n>start</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>end</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>vm_area_struct</span> <span class=o>*</span><span class=n>vma</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>void</span> <span class=o>*</span><span class=n>page_addr</span><span class=p>;</span>
    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>user_page_addr</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>vm_struct</span> <span class=n>tmp_area</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>page</span> <span class=o>**</span><span class=n>page</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>mm_struct</span> <span class=o>*</span><span class=n>mm</span><span class=p>;</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>binder_debug_mask</span> <span class=o>&amp;</span> <span class=n>BINDER_DEBUG_BUFFER_ALLOC</span><span class=p>)</span>
        <span class=n>printk</span><span class=p>(</span><span class=n>KERN_INFO</span> <span class=s>&quot;binder: %d: %s pages %p-%p</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span>
               <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=n>allocate</span> <span class=o>?</span> <span class=s>&quot;allocate&quot;</span> <span class=o>:</span> <span class=s>&quot;free&quot;</span><span class=p>,</span> <span class=n>start</span><span class=p>,</span> <span class=n>end</span><span class=p>);</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>end</span> <span class=o>&lt;=</span> <span class=n>start</span><span class=p>)</span>
        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>vma</span><span class=p>)</span>
        <span class=n>mm</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=k>else</span>
        <span class=n>mm</span> <span class=o>=</span> <span class=n>get_task_mm</span><span class=p>(</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>tsk</span><span class=p>);</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>mm</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>down_write</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mm</span><span class=o>-&gt;</span><span class=n>mmap_sem</span><span class=p>);</span>
        <span class=n>vma</span> <span class=o>=</span> <span class=n>proc</span><span class=o>-&gt;</span><span class=n>vma</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>allocate</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
        <span class=k>goto</span> <span class=n>free_range</span><span class=p>;</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>vma</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>printk</span><span class=p>(</span><span class=n>KERN_ERR</span> <span class=s>&quot;binder: %d: binder_alloc_buf failed to &quot;</span>
               <span class=s>&quot;map pages in userspace, no vma</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span> <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>);</span>
        <span class=k>goto</span> <span class=n>err_no_vma</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>for</span> <span class=p>(</span><span class=n>page_addr</span> <span class=o>=</span> <span class=n>start</span><span class=p>;</span> <span class=n>page_addr</span> <span class=o>&lt;</span> <span class=n>end</span><span class=p>;</span> <span class=n>page_addr</span> <span class=o>+=</span> <span class=n>PAGE_SIZE</span><span class=p>)</span> <span class=p>{</span>
        <span class=kt>int</span> <span class=n>ret</span><span class=p>;</span>
        <span class=k>struct</span> <span class=nc>page</span> <span class=o>**</span><span class=n>page_array_ptr</span><span class=p>;</span>
        <span class=n>page</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>pages</span><span class=p>[(</span><span class=n>page_addr</span> <span class=o>-</span> <span class=n>proc</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=p>)</span> <span class=o>/</span> <span class=n>PAGE_SIZE</span><span class=p>];</span>

        <span class=n>BUG_ON</span><span class=p>(</span><span class=o>*</span><span class=n>page</span><span class=p>);</span>
        <span class=o>*</span><span class=n>page</span> <span class=o>=</span> <span class=n>alloc_page</span><span class=p>(</span><span class=n>GFP_KERNEL</span> <span class=o>|</span> <span class=n>__GFP_ZERO</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=n>page</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>printk</span><span class=p>(</span><span class=n>KERN_ERR</span> <span class=s>&quot;binder: %d: binder_alloc_buf failed &quot;</span>
                   <span class=s>&quot;for page at %p</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span> <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=n>page_addr</span><span class=p>);</span>
            <span class=k>goto</span> <span class=n>err_alloc_page_failed</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=n>tmp_area</span><span class=p>.</span><span class=n>addr</span> <span class=o>=</span> <span class=n>page_addr</span><span class=p>;</span>
        <span class=n>tmp_area</span><span class=p>.</span><span class=n>size</span> <span class=o>=</span> <span class=n>PAGE_SIZE</span> <span class=o>+</span> <span class=n>PAGE_SIZE</span> <span class=cm>/* guard page? */</span><span class=p>;</span>
        <span class=n>page_array_ptr</span> <span class=o>=</span> <span class=n>page</span><span class=p>;</span>
        <span class=n>ret</span> <span class=o>=</span> <span class=n>map_vm_area</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tmp_area</span><span class=p>,</span> <span class=n>PAGE_KERNEL</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>page_array_ptr</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>ret</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>printk</span><span class=p>(</span><span class=n>KERN_ERR</span> <span class=s>&quot;binder: %d: binder_alloc_buf failed &quot;</span>
                   <span class=s>&quot;to map page at %p in kernel</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span>
                   <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=n>page_addr</span><span class=p>);</span>
            <span class=k>goto</span> <span class=n>err_map_kernel_failed</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=n>user_page_addr</span> <span class=o>=</span>
            <span class=p>(</span><span class=kt>uintptr_t</span><span class=p>)</span><span class=n>page_addr</span> <span class=o>+</span> <span class=n>proc</span><span class=o>-&gt;</span><span class=n>user_buffer_offset</span><span class=p>;</span>
        <span class=n>ret</span> <span class=o>=</span> <span class=n>vm_insert_page</span><span class=p>(</span><span class=n>vma</span><span class=p>,</span> <span class=n>user_page_addr</span><span class=p>,</span> <span class=n>page</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>ret</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>printk</span><span class=p>(</span><span class=n>KERN_ERR</span> <span class=s>&quot;binder: %d: binder_alloc_buf failed &quot;</span>
                   <span class=s>&quot;to map page at %lx in userspace</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span>
                   <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=n>user_page_addr</span><span class=p>);</span>
            <span class=k>goto</span> <span class=n>err_vm_insert_page_failed</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=cm>/* vm_insert_page does not seem to increment the refcount */</span>
    <span class=p>}</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>mm</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>up_write</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mm</span><span class=o>-&gt;</span><span class=n>mmap_sem</span><span class=p>);</span>
        <span class=n>mmput</span><span class=p>(</span><span class=n>mm</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>

<span class=nl>free_range</span><span class=p>:</span>
    <span class=k>for</span> <span class=p>(</span><span class=n>page_addr</span> <span class=o>=</span> <span class=n>end</span> <span class=o>-</span> <span class=n>PAGE_SIZE</span><span class=p>;</span> <span class=n>page_addr</span> <span class=o>&gt;=</span> <span class=n>start</span><span class=p>;</span>
         <span class=n>page_addr</span> <span class=o>-=</span> <span class=n>PAGE_SIZE</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>page</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>pages</span><span class=p>[(</span><span class=n>page_addr</span> <span class=o>-</span> <span class=n>proc</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=p>)</span> <span class=o>/</span> <span class=n>PAGE_SIZE</span><span class=p>];</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>vma</span><span class=p>)</span>
            <span class=n>zap_page_range</span><span class=p>(</span><span class=n>vma</span><span class=p>,</span> <span class=p>(</span><span class=kt>uintptr_t</span><span class=p>)</span><span class=n>page_addr</span> <span class=o>+</span>
                <span class=n>proc</span><span class=o>-&gt;</span><span class=n>user_buffer_offset</span><span class=p>,</span> <span class=n>PAGE_SIZE</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
<span class=nl>err_vm_insert_page_failed</span><span class=p>:</span>
        <span class=n>unmap_kernel_range</span><span class=p>((</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)</span><span class=n>page_addr</span><span class=p>,</span> <span class=n>PAGE_SIZE</span><span class=p>);</span>
<span class=nl>err_map_kernel_failed</span><span class=p>:</span>
        <span class=n>__free_page</span><span class=p>(</span><span class=o>*</span><span class=n>page</span><span class=p>);</span>
        <span class=o>*</span><span class=n>page</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
<span class=nl>err_alloc_page_failed</span><span class=p>:</span>
        <span class=p>;</span>
    <span class=p>}</span>
<span class=nl>err_no_vma</span><span class=p>:</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>mm</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>up_write</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mm</span><span class=o>-&gt;</span><span class=n>mmap_sem</span><span class=p>);</span>
        <span class=n>mmput</span><span class=p>(</span><span class=n>mm</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=o>-</span><span class=n>ENOMEM</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>这个函数既可以分配物理页面，也可以用来释放物理页面，通过allocate参数来区别，这里我们只关注分配物理页面的情况。要分配物理页面的虚拟地址空间范围为(start ~ end)，函数前面的一些检查逻辑就不看了，直接看中间的for循环：</p> <div class=highlight><pre><span></span><code><span class=k>for</span> <span class=p>(</span><span class=n>page_addr</span> <span class=o>=</span> <span class=n>start</span><span class=p>;</span> <span class=n>page_addr</span> <span class=o>&lt;</span> <span class=n>end</span><span class=p>;</span> <span class=n>page_addr</span> <span class=o>+=</span> <span class=n>PAGE_SIZE</span><span class=p>)</span> <span class=p>{</span>
  <span class=kt>int</span> <span class=n>ret</span><span class=p>;</span>
  <span class=k>struct</span> <span class=nc>page</span> <span class=o>**</span><span class=n>page_array_ptr</span><span class=p>;</span>
  <span class=n>page</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>pages</span><span class=p>[(</span><span class=n>page_addr</span> <span class=o>-</span> <span class=n>proc</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=p>)</span> <span class=o>/</span> <span class=n>PAGE_SIZE</span><span class=p>];</span>

  <span class=n>BUG_ON</span><span class=p>(</span><span class=o>*</span><span class=n>page</span><span class=p>);</span>
  <span class=o>*</span><span class=n>page</span> <span class=o>=</span> <span class=n>alloc_page</span><span class=p>(</span><span class=n>GFP_KERNEL</span> <span class=o>|</span> <span class=n>__GFP_ZERO</span><span class=p>);</span>
  <span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=n>page</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>printk</span><span class=p>(</span><span class=n>KERN_ERR</span> <span class=s>&quot;binder: %d: binder_alloc_buf failed &quot;</span>
           <span class=s>&quot;for page at %p</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span> <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=n>page_addr</span><span class=p>);</span>
    <span class=k>goto</span> <span class=n>err_alloc_page_failed</span><span class=p>;</span>
  <span class=p>}</span>
  <span class=n>tmp_area</span><span class=p>.</span><span class=n>addr</span> <span class=o>=</span> <span class=n>page_addr</span><span class=p>;</span>
  <span class=n>tmp_area</span><span class=p>.</span><span class=n>size</span> <span class=o>=</span> <span class=n>PAGE_SIZE</span> <span class=o>+</span> <span class=n>PAGE_SIZE</span> <span class=cm>/* guard page? */</span><span class=p>;</span>
  <span class=n>page_array_ptr</span> <span class=o>=</span> <span class=n>page</span><span class=p>;</span>
  <span class=n>ret</span> <span class=o>=</span> <span class=n>map_vm_area</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tmp_area</span><span class=p>,</span> <span class=n>PAGE_KERNEL</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>page_array_ptr</span><span class=p>);</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>ret</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>printk</span><span class=p>(</span><span class=n>KERN_ERR</span> <span class=s>&quot;binder: %d: binder_alloc_buf failed &quot;</span>
           <span class=s>&quot;to map page at %p in kernel</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span>
           <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=n>page_addr</span><span class=p>);</span>
    <span class=k>goto</span> <span class=n>err_map_kernel_failed</span><span class=p>;</span>
  <span class=p>}</span>
  <span class=n>user_page_addr</span> <span class=o>=</span>
    <span class=p>(</span><span class=kt>uintptr_t</span><span class=p>)</span><span class=n>page_addr</span> <span class=o>+</span> <span class=n>proc</span><span class=o>-&gt;</span><span class=n>user_buffer_offset</span><span class=p>;</span>
  <span class=n>ret</span> <span class=o>=</span> <span class=n>vm_insert_page</span><span class=p>(</span><span class=n>vma</span><span class=p>,</span> <span class=n>user_page_addr</span><span class=p>,</span> <span class=n>page</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>ret</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>printk</span><span class=p>(</span><span class=n>KERN_ERR</span> <span class=s>&quot;binder: %d: binder_alloc_buf failed &quot;</span>
           <span class=s>&quot;to map page at %lx in userspace</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span>
           <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=n>user_page_addr</span><span class=p>);</span>
    <span class=k>goto</span> <span class=n>err_vm_insert_page_failed</span><span class=p>;</span>
  <span class=p>}</span>
  <span class=cm>/* vm_insert_page does not seem to increment the refcount */</span>
<span class=p>}</span>
</code></pre></div> <p>首先是调用<code>alloc_page</code>来分配一个物理页面，这个函数返回一个struct <code>page</code>物理页面描述符，根据这个描述的内容初始化好<code>struct vm_struct tmp_area</code>结构体，然后通过<code>map_vm_area</code>将这个物理页面插入到<code>tmp_area</code>描述的内核空间去，接着通过page_addr + proc-&gt;user_buffer_offset获得进程虚拟空间地址，并通过<code>vm_insert_page</code>函数将这个物理页面插入到进程地址空间去，参数<code>vma</code>代表了要插入的进程的地址空间。</p> <p>这样Service Manager的主函数中<code>binder_open</code>已经完成了功能，下面看看<code>binder_become_context_manager</code>函数如何让Service Manager成为守护线程的。 </p> <p><strong>frameworks/base/cmds/servicemanager/binder.c</strong> <div class=highlight><pre><span></span><code><span class=kt>int</span> <span class=nf>binder_become_context_manager</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_state</span> <span class=o>*</span><span class=n>bs</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>return</span> <span class=n>ioctl</span><span class=p>(</span><span class=n>bs</span><span class=o>-&gt;</span><span class=n>fd</span><span class=p>,</span> <span class=n>BINDER_SET_CONTEXT_MGR</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div></p> <p>这里通过调用<code>ioctl</code>文件操作函数来通知Binder驱动程序自己是守护进程，命令号是<code>BINDER_SET_CONTEXT_MGR</code>，没有参数。<br> <code>BINDER_SET_CONTEXT_MGR</code>的定义在kernel中，为<code>#define BINDER_SET_CONTEXT_MGR _IOW('b', 7, int)</code>。</p> <p>然后就进入了Binder驱动程序的<code>binder_ioctl</code>函数（<strong>why??</strong>），这里我们只关注<code>BINDER_SET_CONTEXT_MGR</code>。</p> <blockquote> <p>From: <a href=https://www.jianshu.com/p/49830c3473b7>https://www.jianshu.com/p/49830c3473b7</a><br> ioctl是Linux中常见的系统调用，它用于对底层设备的一些特性进行控制的用户态接口，应用程序在调用ioctl进行设备控制时，最后会调用到设备注册struct file_operations结构体对象时的unlocked_ioctl或者compat_ioctl两个钩子上，具体是调用哪个钩子判断标准如下：<br> compat_ioctl : 32位的应用运行在64位的内核上，这个钩子被调用。<br> unlocked_ioctl: 64位的应用运行在64位的内核或者32位的应用运行在32位的内核上，则调用这个钩子。<br> Binder做为Android中进程间高效通信的核心组件，其底层是以misc设备驱动的形式实现的，但它本身并没有实现read,write操作，所有的控制都是通过ioctl操作来实现。在Binder驱动的struct file_operations定义中可见，它的compat_ioctl和unlocked_ioctl两个钩子的的实现都是对应到binder_ioctl上的。</p> </blockquote> <div class=highlight><pre><span></span><code><span class=k>static</span> <span class=kt>long</span> <span class=n>binder_ioctl</span><span class=p>(</span><span class=k>struct</span> <span class=nc>file</span> <span class=o>*</span><span class=n>filp</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>cmd</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>arg</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>int</span> <span class=n>ret</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>binder_proc</span> <span class=o>*</span><span class=n>proc</span> <span class=o>=</span> <span class=n>filp</span><span class=o>-&gt;</span><span class=n>private_data</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>binder_thread</span> <span class=o>*</span><span class=kr>thread</span><span class=p>;</span>
    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>size</span> <span class=o>=</span> <span class=n>_IOC_SIZE</span><span class=p>(</span><span class=n>cmd</span><span class=p>);</span>
    <span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=n>ubuf</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=p>)</span><span class=n>arg</span><span class=p>;</span>

    <span class=cm>/*printk(KERN_INFO &quot;binder_ioctl: %d:%d %x %lx\n&quot;, proc-&gt;pid, current-&gt;pid, cmd, arg);*/</span>

    <span class=n>ret</span> <span class=o>=</span> <span class=n>wait_event_interruptible</span><span class=p>(</span><span class=n>binder_user_error_wait</span><span class=p>,</span> <span class=n>binder_stop_on_user_error</span> <span class=o>&lt;</span> <span class=mi>2</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>ret</span><span class=p>)</span>
        <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>

    <span class=n>mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>binder_lock</span><span class=p>);</span>
    <span class=kr>thread</span> <span class=o>=</span> <span class=n>binder_get_thread</span><span class=p>(</span><span class=n>proc</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=kr>thread</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>ENOMEM</span><span class=p>;</span>
        <span class=k>goto</span> <span class=n>err</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>switch</span> <span class=p>(</span><span class=n>cmd</span><span class=p>)</span> <span class=p>{</span>
    <span class=p>...</span>
    <span class=k>case</span> <span class=nl>BINDER_SET_CONTEXT_MGR</span><span class=p>:</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>binder_context_mgr_node</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>printk</span><span class=p>(</span><span class=n>KERN_ERR</span> <span class=s>&quot;binder: BINDER_SET_CONTEXT_MGR already set</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>);</span>
            <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>EBUSY</span><span class=p>;</span>
            <span class=k>goto</span> <span class=n>err</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>binder_context_mgr_uid</span> <span class=o>!=</span> <span class=mi>-1</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>binder_context_mgr_uid</span> <span class=o>!=</span> <span class=n>current</span><span class=o>-&gt;</span><span class=n>cred</span><span class=o>-&gt;</span><span class=n>euid</span><span class=p>)</span> <span class=p>{</span>
                <span class=n>printk</span><span class=p>(</span><span class=n>KERN_ERR</span> <span class=s>&quot;binder: BINDER_SET_&quot;</span>
                       <span class=s>&quot;CONTEXT_MGR bad uid %d != %d</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span>
                       <span class=n>current</span><span class=o>-&gt;</span><span class=n>cred</span><span class=o>-&gt;</span><span class=n>euid</span><span class=p>,</span>
                       <span class=n>binder_context_mgr_uid</span><span class=p>);</span>
                <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>EPERM</span><span class=p>;</span>
                <span class=k>goto</span> <span class=n>err</span><span class=p>;</span>
            <span class=p>}</span>
        <span class=p>}</span> <span class=k>else</span>
            <span class=n>binder_context_mgr_uid</span> <span class=o>=</span> <span class=n>current</span><span class=o>-&gt;</span><span class=n>cred</span><span class=o>-&gt;</span><span class=n>euid</span><span class=p>;</span>
        <span class=n>binder_context_mgr_node</span> <span class=o>=</span> <span class=n>binder_new_node</span><span class=p>(</span><span class=n>proc</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>binder_context_mgr_node</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>ENOMEM</span><span class=p>;</span>
            <span class=k>goto</span> <span class=n>err</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=n>binder_context_mgr_node</span><span class=o>-&gt;</span><span class=n>local_weak_refs</span><span class=o>++</span><span class=p>;</span>
        <span class=n>binder_context_mgr_node</span><span class=o>-&gt;</span><span class=n>local_strong_refs</span><span class=o>++</span><span class=p>;</span>
        <span class=n>binder_context_mgr_node</span><span class=o>-&gt;</span><span class=n>has_strong_ref</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
        <span class=n>binder_context_mgr_node</span><span class=o>-&gt;</span><span class=n>has_weak_ref</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
        <span class=k>break</span><span class=p>;</span>
    <span class=p>...</span>
    <span class=k>default</span><span class=o>:</span>
        <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>EINVAL</span><span class=p>;</span>
        <span class=k>goto</span> <span class=n>err</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>ret</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
<span class=nl>err</span><span class=p>:</span>
    <span class=k>if</span> <span class=p>(</span><span class=kr>thread</span><span class=p>)</span>
        <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>looper</span> <span class=o>&amp;=</span> <span class=o>~</span><span class=n>BINDER_LOOPER_STATE_NEED_RETURN</span><span class=p>;</span>
    <span class=n>mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>binder_lock</span><span class=p>);</span>
    <span class=n>wait_event_interruptible</span><span class=p>(</span><span class=n>binder_user_error_wait</span><span class=p>,</span> <span class=n>binder_stop_on_user_error</span> <span class=o>&lt;</span> <span class=mi>2</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>&amp;&amp;</span> <span class=n>ret</span> <span class=o>!=</span> <span class=o>-</span><span class=n>ERESTARTSYS</span><span class=p>)</span>
        <span class=n>printk</span><span class=p>(</span><span class=n>KERN_INFO</span> <span class=s>&quot;binder: %d:%d ioctl %x %lx returned %d</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span> <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=n>current</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=n>cmd</span><span class=p>,</span> <span class=n>arg</span><span class=p>,</span> <span class=n>ret</span><span class=p>);</span>
    <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>继续分析这个函数之前，又要解释两个数据结构了，一个是<code>struct binder_thread</code>结构体，顾名思久，它表示一个线程，这里就是执行<code>binder_become_context_manager</code>函数的线程了。 </p> <div class=highlight><pre><span></span><code><span class=k>struct</span> <span class=nc>binder_thread</span> <span class=p>{</span>
    <span class=k>struct</span> <span class=nc>binder_proc</span> <span class=o>*</span><span class=n>proc</span><span class=p>;</span>      <span class=c1>// 该线程所属的进程</span>
    <span class=k>struct</span> <span class=nc>rb_node</span> <span class=n>rb_node</span><span class=p>;</span>        <span class=c1>// 链入binder_proc中threads红黑树的节点</span>
    <span class=kt>int</span> <span class=n>pid</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>looper</span><span class=p>;</span>                    <span class=c1>// 线程状态，枚举值如下</span>
    <span class=k>struct</span> <span class=nc>binder_transaction</span> <span class=o>*</span><span class=n>transaction_stack</span><span class=p>;</span>  <span class=c1>// 线程正在处理的事务</span>
    <span class=k>struct</span> <span class=nc>list_head</span> <span class=n>todo</span><span class=p>;</span>         <span class=c1>// 发往该线程的数据列表</span>
  <span class=c1>// 操作结果返回码</span>
    <span class=kt>uint32_t</span> <span class=n>return_error</span><span class=p>;</span> <span class=cm>/* Write failed, return error code in read buf */</span>
    <span class=kt>uint32_t</span> <span class=n>return_error2</span><span class=p>;</span> <span class=cm>/* Write failed, return error code in read */</span>
        <span class=cm>/* buffer. Used when sending a reply to a dead process that */</span>
        <span class=cm>/* we are also waiting on */</span>
    <span class=n>wait_queue_head_t</span> <span class=n>wait</span><span class=p>;</span>        <span class=c1>// 用来阻塞线程等待某个事件的发生</span>
    <span class=k>struct</span> <span class=nc>binder_stats</span> <span class=n>stats</span><span class=p>;</span>     <span class=c1>// 用来保存一些统计信息</span>
<span class=p>};</span>

<span class=c1>// 线程状态枚举值</span>
<span class=k>enum</span> <span class=p>{</span>
    <span class=n>BINDER_LOOPER_STATE_REGISTERED</span>  <span class=o>=</span> <span class=mh>0x01</span><span class=p>,</span>
    <span class=n>BINDER_LOOPER_STATE_ENTERED</span>     <span class=o>=</span> <span class=mh>0x02</span><span class=p>,</span>
    <span class=n>BINDER_LOOPER_STATE_EXITED</span>      <span class=o>=</span> <span class=mh>0x04</span><span class=p>,</span>
    <span class=n>BINDER_LOOPER_STATE_INVALID</span>     <span class=o>=</span> <span class=mh>0x08</span><span class=p>,</span>
    <span class=n>BINDER_LOOPER_STATE_WAITING</span>     <span class=o>=</span> <span class=mh>0x10</span><span class=p>,</span>
    <span class=n>BINDER_LOOPER_STATE_NEED_RETURN</span> <span class=o>=</span> <span class=mh>0x20</span>
<span class=p>}</span>
</code></pre></div> <p>另外一个数据结构是<code>struct binder_node</code>，它表示一个binder实体</p> <div class=highlight><pre><span></span><code><span class=k>struct</span> <span class=nc>binder_node</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>debug_id</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>binder_work</span> <span class=n>work</span><span class=p>;</span>
    <span class=c1>// rb_node和dead_node组成一个联合体。</span>
    <span class=c1>// 如果这个Binder实体还在正常使用</span>
    <span class=c1>// 则使用rb_node来连入proc-&gt;nodes所表示的红黑树的节点</span>
    <span class=c1>// 这棵红黑树用来组织属于这个进程的所有Binder实体；</span>
    <span class=c1>//</span>
    <span class=c1>// 如果这个Binder实体所属的进程已经销毁</span>
    <span class=c1>// 而这个Binder实体又被其它进程所引用</span>
    <span class=c1>// 则这个Binder实体通过dead_node进入到一个哈希表中去存放。</span>
    <span class=k>union</span> <span class=p>{</span>
        <span class=k>struct</span> <span class=nc>rb_node</span> <span class=n>rb_node</span><span class=p>;</span>
        <span class=k>struct</span> <span class=nc>hlist_node</span> <span class=n>dead_node</span><span class=p>;</span>
    <span class=p>};</span>
    <span class=k>struct</span> <span class=nc>binder_proc</span> <span class=o>*</span><span class=n>proc</span><span class=p>;</span>    <span class=c1>// 表示这个Binder实例所属于进程</span>
    <span class=k>struct</span> <span class=nc>hlist_head</span> <span class=n>refs</span><span class=p>;</span>      <span class=c1>// 所有引用了该Binder实体的Binder引用连接起来构成一个链表</span>
    <span class=c1>// 以下三个表示Binder实体的引用计数</span>
    <span class=kt>int</span> <span class=n>internal_strong_refs</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>local_weak_refs</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>local_strong_refs</span><span class=p>;</span>
    <span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=n>ptr</span><span class=p>;</span>            <span class=c1>// Binder实体在用户空间的地址附加数据</span>
    <span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=n>cookie</span><span class=p>;</span>         <span class=c1>// Binder实体在用户空间的附加数据</span>
    <span class=kt>unsigned</span> <span class=nl>has_strong_ref</span> <span class=p>:</span> <span class=mi>1</span><span class=p>;</span>
    <span class=kt>unsigned</span> <span class=nl>pending_strong_ref</span> <span class=p>:</span> <span class=mi>1</span><span class=p>;</span>
    <span class=kt>unsigned</span> <span class=nl>has_weak_ref</span> <span class=p>:</span> <span class=mi>1</span><span class=p>;</span>
    <span class=kt>unsigned</span> <span class=nl>pending_weak_ref</span> <span class=p>:</span> <span class=mi>1</span><span class=p>;</span>
    <span class=kt>unsigned</span> <span class=nl>has_async_transaction</span> <span class=p>:</span> <span class=mi>1</span><span class=p>;</span>
    <span class=kt>unsigned</span> <span class=nl>accept_fds</span> <span class=p>:</span> <span class=mi>1</span><span class=p>;</span>
    <span class=kt>int</span> <span class=nl>min_priority</span> <span class=p>:</span> <span class=mi>8</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>list_head</span> <span class=n>async_todo</span><span class=p>;</span>
<span class=p>};</span>
</code></pre></div> <p>介绍完两个struct之后，回到<code>binder_ioctl</code>函数中，首先是通过<code>filp-&gt;private_data</code>获得<code>proc</code>变量，接着通过<code>binder_get_thread</code>函数获得线程信息，我们来看一下这个函数：</p> <div class=highlight><pre><span></span><code><span class=k>static</span> <span class=k>struct</span> <span class=nc>binder_thread</span> <span class=o>*</span><span class=n>binder_get_thread</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_proc</span> <span class=o>*</span><span class=n>proc</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>struct</span> <span class=nc>binder_thread</span> <span class=o>*</span><span class=kr>thread</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>rb_node</span> <span class=o>*</span><span class=n>parent</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>rb_node</span> <span class=o>**</span><span class=n>p</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>threads</span><span class=p>.</span><span class=n>rb_node</span><span class=p>;</span>

    <span class=k>while</span> <span class=p>(</span><span class=o>*</span><span class=n>p</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>parent</span> <span class=o>=</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span>
        <span class=kr>thread</span> <span class=o>=</span> <span class=n>rb_entry</span><span class=p>(</span><span class=n>parent</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>binder_thread</span><span class=p>,</span> <span class=n>rb_node</span><span class=p>);</span>

        <span class=k>if</span> <span class=p>(</span><span class=n>current</span><span class=o>-&gt;</span><span class=n>pid</span> <span class=o>&lt;</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>)</span>
            <span class=n>p</span> <span class=o>=</span> <span class=o>&amp;</span><span class=p>(</span><span class=o>*</span><span class=n>p</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>rb_left</span><span class=p>;</span>
        <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>current</span><span class=o>-&gt;</span><span class=n>pid</span> <span class=o>&gt;</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>)</span>
            <span class=n>p</span> <span class=o>=</span> <span class=o>&amp;</span><span class=p>(</span><span class=o>*</span><span class=n>p</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>rb_right</span><span class=p>;</span>
        <span class=k>else</span>
            <span class=k>break</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=n>p</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
        <span class=kr>thread</span> <span class=o>=</span> <span class=n>kzalloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=kr>thread</span><span class=p>),</span> <span class=n>GFP_KERNEL</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=kr>thread</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
            <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
        <span class=n>binder_stats</span><span class=p>.</span><span class=n>obj_created</span><span class=p>[</span><span class=n>BINDER_STAT_THREAD</span><span class=p>]</span><span class=o>++</span><span class=p>;</span>
        <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>proc</span> <span class=o>=</span> <span class=n>proc</span><span class=p>;</span>
        <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>pid</span> <span class=o>=</span> <span class=n>current</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>;</span>
        <span class=n>init_waitqueue_head</span><span class=p>(</span><span class=o>&amp;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>wait</span><span class=p>);</span>
        <span class=n>INIT_LIST_HEAD</span><span class=p>(</span><span class=o>&amp;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>);</span>
        <span class=n>rb_link_node</span><span class=p>(</span><span class=o>&amp;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>rb_node</span><span class=p>,</span> <span class=n>parent</span><span class=p>,</span> <span class=n>p</span><span class=p>);</span>
        <span class=n>rb_insert_color</span><span class=p>(</span><span class=o>&amp;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>rb_node</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>threads</span><span class=p>);</span>
        <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>looper</span> <span class=o>|=</span> <span class=n>BINDER_LOOPER_STATE_NEED_RETURN</span><span class=p>;</span>
        <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_OK</span><span class=p>;</span>
        <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>return_error2</span> <span class=o>=</span> <span class=n>BR_OK</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=kr>thread</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>这里把当前线程current的pid作为键值，在进程<code>proc-&gt;threads</code>表示的红黑树中进行查找，看是否已经为当前线程创建过了<code>binder_thread</code>信息。在这个场景下，由于当前线程是第一次进到这里，所以肯定找不到，即<code>*p == NULL</code>成立，于是，就为当前线程创建一个线程上下文信息结构体<code>binder_thread</code>，并初始化相应成员变量，并插入到<code>proc-&gt;threads</code>所表示的红黑树中去，下次要使用时就可以从proc中找到了。注意，这里的<code>thread-&gt;looper |= BINDER_LOOPER_STATE_NEED_RETURN</code>。</p> <p>回到<code>binder_ioctl</code>函数，继续往下面，有两个全局变量<code>binder_context_mgr_node</code>和<code>binder_context_mgr_uid</code>，它定义如下：</p> <div class=highlight><pre><span></span><code><span class=k>static</span> <span class=k>struct</span> <span class=nc>binder_node</span> <span class=o>*</span><span class=n>binder_context_mgr_node</span><span class=p>;</span>
<span class=k>static</span> <span class=kt>uid_t</span> <span class=n>binder_context_mgr_uid</span> <span class=o>=</span> <span class=mi>-1</span><span class=p>;</span>
</code></pre></div> <p><code>binder_context_mgr_node</code>用来表示Service Manager实体，<code>binder_context_mgr_uid</code>表示Service Manager守护进程的uid。<br> 在这个场景下，由于当前线程是第一次进到这里，所以<code>binder_context_mgr_node</code>为NULL，<code>binder_context_mgr_uid</code>为-1，于是初始化<code>binder_context_mgr_uid</code>为<code>current-&gt;cred-&gt;euid</code>，这样，当前线程就成为Binder机制的守护进程了，并且通过<code>binder_new_node()</code>为Service Manager创建Binder实体：</p> <div class=highlight><pre><span></span><code><span class=k>static</span> <span class=k>struct</span> <span class=nc>binder_node</span> <span class=o>*</span>
<span class=n>binder_new_node</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_proc</span> <span class=o>*</span><span class=n>proc</span><span class=p>,</span> <span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=n>ptr</span><span class=p>,</span> <span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=n>cookie</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>struct</span> <span class=nc>rb_node</span> <span class=o>**</span><span class=n>p</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>nodes</span><span class=p>.</span><span class=n>rb_node</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>rb_node</span> <span class=o>*</span><span class=n>parent</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>binder_node</span> <span class=o>*</span><span class=n>node</span><span class=p>;</span>

    <span class=k>while</span> <span class=p>(</span><span class=o>*</span><span class=n>p</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>parent</span> <span class=o>=</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span>
        <span class=n>node</span> <span class=o>=</span> <span class=n>rb_entry</span><span class=p>(</span><span class=n>parent</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>binder_node</span><span class=p>,</span> <span class=n>rb_node</span><span class=p>);</span>

        <span class=k>if</span> <span class=p>(</span><span class=n>ptr</span> <span class=o>&lt;</span> <span class=n>node</span><span class=o>-&gt;</span><span class=n>ptr</span><span class=p>)</span>
            <span class=n>p</span> <span class=o>=</span> <span class=o>&amp;</span><span class=p>(</span><span class=o>*</span><span class=n>p</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>rb_left</span><span class=p>;</span>
        <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>ptr</span> <span class=o>&gt;</span> <span class=n>node</span><span class=o>-&gt;</span><span class=n>ptr</span><span class=p>)</span>
            <span class=n>p</span> <span class=o>=</span> <span class=o>&amp;</span><span class=p>(</span><span class=o>*</span><span class=n>p</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>rb_right</span><span class=p>;</span>
        <span class=k>else</span>
            <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=n>node</span> <span class=o>=</span> <span class=n>kzalloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=n>node</span><span class=p>),</span> <span class=n>GFP_KERNEL</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>node</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
        <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=n>binder_stats</span><span class=p>.</span><span class=n>obj_created</span><span class=p>[</span><span class=n>BINDER_STAT_NODE</span><span class=p>]</span><span class=o>++</span><span class=p>;</span>
    <span class=n>rb_link_node</span><span class=p>(</span><span class=o>&amp;</span><span class=n>node</span><span class=o>-&gt;</span><span class=n>rb_node</span><span class=p>,</span> <span class=n>parent</span><span class=p>,</span> <span class=n>p</span><span class=p>);</span>
    <span class=n>rb_insert_color</span><span class=p>(</span><span class=o>&amp;</span><span class=n>node</span><span class=o>-&gt;</span><span class=n>rb_node</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>nodes</span><span class=p>);</span>
    <span class=n>node</span><span class=o>-&gt;</span><span class=n>debug_id</span> <span class=o>=</span> <span class=o>++</span><span class=n>binder_last_id</span><span class=p>;</span>
    <span class=n>node</span><span class=o>-&gt;</span><span class=n>proc</span> <span class=o>=</span> <span class=n>proc</span><span class=p>;</span>
    <span class=n>node</span><span class=o>-&gt;</span><span class=n>ptr</span> <span class=o>=</span> <span class=n>ptr</span><span class=p>;</span>
    <span class=n>node</span><span class=o>-&gt;</span><span class=n>cookie</span> <span class=o>=</span> <span class=n>cookie</span><span class=p>;</span>
    <span class=n>node</span><span class=o>-&gt;</span><span class=n>work</span><span class=p>.</span><span class=n>type</span> <span class=o>=</span> <span class=n>BINDER_WORK_NODE</span><span class=p>;</span>
    <span class=n>INIT_LIST_HEAD</span><span class=p>(</span><span class=o>&amp;</span><span class=n>node</span><span class=o>-&gt;</span><span class=n>work</span><span class=p>.</span><span class=n>entry</span><span class=p>);</span>
    <span class=n>INIT_LIST_HEAD</span><span class=p>(</span><span class=o>&amp;</span><span class=n>node</span><span class=o>-&gt;</span><span class=n>async_todo</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>binder_debug_mask</span> <span class=o>&amp;</span> <span class=n>BINDER_DEBUG_INTERNAL_REFS</span><span class=p>)</span>
        <span class=n>printk</span><span class=p>(</span><span class=n>KERN_INFO</span> <span class=s>&quot;binder: %d:%d node %d u%p c%p created</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span>
               <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=n>current</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=n>node</span><span class=o>-&gt;</span><span class=n>debug_id</span><span class=p>,</span>
               <span class=n>node</span><span class=o>-&gt;</span><span class=n>ptr</span><span class=p>,</span> <span class=n>node</span><span class=o>-&gt;</span><span class=n>cookie</span><span class=p>);</span>
    <span class=k>return</span> <span class=n>node</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>注意，这里传进来的<code>ptr</code>和<code>cookie</code>均为<code>NULL</code>。函数首先检查<code>proc-&gt;nodes</code>红黑树中是否已经存在以<code>ptr</code>为键值的<code>node</code>，如果已经存在，就返回NULL。在这个场景下，由于当前线程是第一次进入到这里，所以肯定不存在，于是就新建了一个<code>ptr</code>为<code>NULL</code>的<code>binder_node</code>，并且初始化其它成员变量，并插入到<code>proc-&gt;nodes</code>红黑树中去。</p> <p><code>binder_new_node</code>返回到<code>binder_ioctl</code>函数后，就把新建的<code>binder_node</code>指针保存在<code>binder_context_mgr_node</code>中了，紧接着，又初始化了<code>binder_context_mgr_node</code>的引用计数值。</p> <p>这样，<code>BINDER_SET_CONTEXT_MGR</code>命令就执行完毕了。<code>binder_ioctl</code>函数返回之前，执行了下面语句：</p> <div class=highlight><pre><span></span><code><span class=k>if</span> <span class=p>(</span><span class=kr>thread</span><span class=p>)</span>
        <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>looper</span> <span class=o>&amp;=</span> <span class=o>~</span><span class=n>BINDER_LOOPER_STATE_NEED_RETURN</span><span class=p>;</span>
</code></pre></div> <p>回忆上面执行binder_get_thread时，<code>thread-&gt;looper |= BINDER_LOOPER_STATE_NEED_RETURN</code>，执行了这条语句后，<code>thread-&gt;looper = 0</code>。</p> <p>回到Service Manager的main函数中，下一步就是调用<code>binder_loop</code>函数。</p> <div class=highlight><pre><span></span><code><span class=kt>void</span> <span class=nf>binder_loop</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_state</span> <span class=o>*</span><span class=n>bs</span><span class=p>,</span> <span class=n>binder_handler</span> <span class=n>func</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>int</span> <span class=n>res</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>binder_write_read</span> <span class=n>bwr</span><span class=p>;</span>
    <span class=kt>unsigned</span> <span class=n>readbuf</span><span class=p>[</span><span class=mi>32</span><span class=p>];</span>

    <span class=n>bwr</span><span class=p>.</span><span class=n>write_size</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>bwr</span><span class=p>.</span><span class=n>write_consumed</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>bwr</span><span class=p>.</span><span class=n>write_buffer</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>

    <span class=n>readbuf</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>BC_ENTER_LOOPER</span><span class=p>;</span>
    <span class=n>binder_write</span><span class=p>(</span><span class=n>bs</span><span class=p>,</span> <span class=n>readbuf</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>unsigned</span><span class=p>));</span>

    <span class=k>for</span> <span class=p>(;;)</span> <span class=p>{</span>
        <span class=n>bwr</span><span class=p>.</span><span class=n>read_size</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>readbuf</span><span class=p>);</span>
        <span class=n>bwr</span><span class=p>.</span><span class=n>read_consumed</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
        <span class=n>bwr</span><span class=p>.</span><span class=n>read_buffer</span> <span class=o>=</span> <span class=p>(</span><span class=kt>unsigned</span><span class=p>)</span> <span class=n>readbuf</span><span class=p>;</span>

        <span class=n>res</span> <span class=o>=</span> <span class=n>ioctl</span><span class=p>(</span><span class=n>bs</span><span class=o>-&gt;</span><span class=n>fd</span><span class=p>,</span> <span class=n>BINDER_WRITE_READ</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>bwr</span><span class=p>);</span>

        <span class=k>if</span> <span class=p>(</span><span class=n>res</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>LOGE</span><span class=p>(</span><span class=s>&quot;binder_loop: ioctl failed (%s)</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span> <span class=n>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
            <span class=k>break</span><span class=p>;</span>
        <span class=p>}</span>

        <span class=n>res</span> <span class=o>=</span> <span class=n>binder_parse</span><span class=p>(</span><span class=n>bs</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>readbuf</span><span class=p>,</span> <span class=n>bwr</span><span class=p>.</span><span class=n>read_consumed</span><span class=p>,</span> <span class=n>func</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>res</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>LOGE</span><span class=p>(</span><span class=s>&quot;binder_loop: unexpected reply?!</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>);</span>
            <span class=k>break</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>res</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>LOGE</span><span class=p>(</span><span class=s>&quot;binder_loop: io error %d %s</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span> <span class=n>res</span><span class=p>,</span> <span class=n>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
            <span class=k>break</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div> <p>首先是通过<code>binder_write</code>函数执行<code>BC_ENTER_LOOPER</code>命令告诉Binder驱动程序，Service Manager要进入循环了。接下来在循环中调用了<code>ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr)</code>。<br> 这里又要介绍一下设备文件/dev/binder文件操作函数<code>ioctl</code>的操作码<code>BINDER_WRITE_READ</code>了，首先看定义：</p> <div class=highlight><pre><span></span><code><span class=cp>#define BINDER_WRITE_READ           _IOWR(&#39;b&#39;, 1, struct binder_write_read)</span>
</code></pre></div> <p>这个io操作码有一个参数，形式为<code>struct binder_write_read</code>：</p> <div class=highlight><pre><span></span><code><span class=k>struct</span> <span class=nc>binder_write_read</span> <span class=p>{</span>
    <span class=kt>signed</span> <span class=kt>long</span> <span class=n>write_size</span><span class=p>;</span> <span class=cm>/* bytes to write */</span>
    <span class=kt>signed</span> <span class=kt>long</span> <span class=n>write_consumed</span><span class=p>;</span> <span class=cm>/* bytes consumed by driver */</span>
    <span class=kt>unsigned</span> <span class=kt>long</span>   <span class=n>write_buffer</span><span class=p>;</span>
    <span class=kt>signed</span> <span class=kt>long</span> <span class=n>read_size</span><span class=p>;</span>  <span class=cm>/* bytes to read */</span>
    <span class=kt>signed</span> <span class=kt>long</span> <span class=n>read_consumed</span><span class=p>;</span>  <span class=cm>/* bytes consumed by driver */</span>
    <span class=kt>unsigned</span> <span class=kt>long</span>   <span class=n>read_buffer</span><span class=p>;</span>
<span class=p>};</span>
</code></pre></div> <p>用户空间程序和Binder驱动程序交互大多数都是通过<code>BINDER_WRITE_READ</code>命令的，<code>write_bufffer</code>和<code>read_buffer</code>所指向的数据结构还指定了具体要执行的操作，<code>write_bufffer</code>和<code>read_buffer</code>所指向的结构体是<code>struct binder_transaction_data</code>：</p> <div class=highlight><pre><span></span><code><span class=k>struct</span> <span class=nc>binder_transaction_data</span> <span class=p>{</span>
    <span class=cm>/* The first two are only used for bcTRANSACTION and brTRANSACTION,</span>
<span class=cm>     * identifying the target and contents of the transaction.</span>
<span class=cm>     */</span>
    <span class=k>union</span> <span class=p>{</span>
        <span class=kt>size_t</span>  <span class=n>handle</span><span class=p>;</span> <span class=cm>/* target descriptor of command transaction */</span>
        <span class=kt>void</span>    <span class=o>*</span><span class=n>ptr</span><span class=p>;</span>   <span class=cm>/* target descriptor of return transaction */</span>
    <span class=p>}</span> <span class=n>target</span><span class=p>;</span>
    <span class=kt>void</span>        <span class=o>*</span><span class=n>cookie</span><span class=p>;</span>    <span class=cm>/* target object cookie */</span>
    <span class=kt>unsigned</span> <span class=kt>int</span>    <span class=n>code</span><span class=p>;</span>       <span class=cm>/* transaction command */</span>

    <span class=cm>/* General information about the transaction. */</span>
    <span class=kt>unsigned</span> <span class=kt>int</span>    <span class=n>flags</span><span class=p>;</span>
    <span class=kt>pid_t</span>       <span class=n>sender_pid</span><span class=p>;</span>
    <span class=kt>uid_t</span>       <span class=n>sender_euid</span><span class=p>;</span>
    <span class=kt>size_t</span>      <span class=n>data_size</span><span class=p>;</span>  <span class=cm>/* number of bytes of data */</span>
    <span class=kt>size_t</span>      <span class=n>offsets_size</span><span class=p>;</span>   <span class=cm>/* number of bytes of offsets */</span>

    <span class=cm>/* If this transaction is inline, the data immediately</span>
<span class=cm>     * follows here; otherwise, it ends with a pointer to</span>
<span class=cm>     * the data buffer.</span>
<span class=cm>     */</span>
    <span class=k>union</span> <span class=p>{</span>
        <span class=k>struct</span> <span class=p>{</span>
            <span class=cm>/* transaction data */</span>
            <span class=k>const</span> <span class=kt>void</span>  <span class=o>*</span><span class=n>buffer</span><span class=p>;</span>
            <span class=cm>/* offsets from buffer to flat_binder_object structs */</span>
            <span class=k>const</span> <span class=kt>void</span>  <span class=o>*</span><span class=n>offsets</span><span class=p>;</span>
        <span class=p>}</span> <span class=n>ptr</span><span class=p>;</span>
        <span class=kt>uint8_t</span> <span class=n>buf</span><span class=p>[</span><span class=mi>8</span><span class=p>];</span>
    <span class=p>}</span> <span class=n>data</span><span class=p>;</span>
<span class=p>};</span>
</code></pre></div> <p>有一个联合体<code>target</code>，当这个<code>BINDER_WRITE_READ</code>命令的目标对象是本地Binder实体时，就使用<code>ptr</code>来表示这个对象在本进程中的地址，否则就使用<code>handle</code>来表示这个Binder实体的引用。只有目标对象是Binder实体时，<code>cookie</code>成员变量才有意义，表示一些附加数据，由Binder实体来解释这个附加数据。<code>code</code>表示要对目标对象请求的命令代码，有很多请求代码，这里就不列举了，在这个场景中，就是<code>BC_ENTER_LOOPER</code>了，用来告诉Binder驱动程序， Service Manager要进入循环了。其余的请求命令代码可以参考kernel/common/drivers/staging/android/binder.h文件中定义的两个枚举类型<code>BinderDriverReturnProtocol</code>和<code>BinderDriverCommandProtocol</code>。<br> <code>flags</code>成员变量表示事务标志：</p> <div class=highlight><pre><span></span><code><span class=k>enum</span> <span class=n>transaction_flags</span> <span class=p>{</span>
    <span class=n>TF_ONE_WAY</span>  <span class=o>=</span> <span class=mh>0x01</span><span class=p>,</span> <span class=cm>/* this is a one-way call: async, no return */</span>
    <span class=n>TF_ROOT_OBJECT</span>  <span class=o>=</span> <span class=mh>0x04</span><span class=p>,</span> <span class=cm>/* contents are the component&#39;s root object */</span>
    <span class=n>TF_STATUS_CODE</span>  <span class=o>=</span> <span class=mh>0x08</span><span class=p>,</span> <span class=cm>/* contents are a 32-bit status code */</span>
    <span class=n>TF_ACCEPT_FDS</span>   <span class=o>=</span> <span class=mh>0x10</span><span class=p>,</span> <span class=cm>/* allow replies with file descriptors */</span>
<span class=p>};</span>
</code></pre></div> <p><code>sender_pid</code>和<code>sender_euid</code>表示发送者进程的pid和euid。<br> <code>data_size</code>表示data.buffer缓冲区的大小，<code>offsets_size</code>表示data.offsets缓冲区的大小。 </p> <p>这里需要解释一下<code>data</code>成员变量，命令的真正要传输的数据就保存在<code>data.buffer</code>缓冲区中，前面的成员变量都是一些用来描述数据的特征的。<code>data.buffer</code>所表示的缓冲区数据分为两类，一类是普通数据，Binder驱动程序不关心，一类是Binder实体或者Binder引用，这需要Binder驱动程序介入处理。为什么呢？想想，如果一个进程A传递了一个Binder实体或Binder引用给进程B，那么，Binder驱动程序就需要介入维护这个Binder实体或者引用的引用计数，防止B进程还在使用这个Binder实体时，A却销毁这个实体，这样的话，B进程就会crash了。所以在传输数据时，如果数据中含有Binder实体和Binder引用，就需要告诉Binder驱动程序它们的具体位置，以便Binder驱动程序能够去维护它们。<code>data.offsets</code>的作用就在这里了，它指定在<code>data.buffer</code>缓冲区中，所有Binder实体或者引用的偏移位置。每一个Binder实体或者引用，通过<code>struct flat_binder_object</code>来表示：</p> <div class=highlight><pre><span></span><code><span class=cm>/*</span>
<span class=cm> * This is the flattened representation of a Binder object for transfer</span>
<span class=cm> * between processes.  The &#39;offsets&#39; supplied as part of a binder transaction</span>
<span class=cm> * contains offsets into the data where these structures occur.  The Binder</span>
<span class=cm> * driver takes care of re-writing the structure type and data as it moves</span>
<span class=cm> * between processes.</span>
<span class=cm> */</span>
<span class=k>struct</span> <span class=nc>flat_binder_object</span> <span class=p>{</span>
    <span class=cm>/* 8 bytes for large_flat_header. */</span>
    <span class=kt>unsigned</span> <span class=kt>long</span>       <span class=n>type</span><span class=p>;</span>
    <span class=kt>unsigned</span> <span class=kt>long</span>       <span class=n>flags</span><span class=p>;</span>

    <span class=cm>/* 8 bytes of data. */</span>
    <span class=k>union</span> <span class=p>{</span>
        <span class=kt>void</span>        <span class=o>*</span><span class=n>binder</span><span class=p>;</span>    <span class=cm>/* local object */</span>
        <span class=kt>signed</span> <span class=kt>long</span> <span class=n>handle</span><span class=p>;</span>     <span class=cm>/* remote object */</span>
    <span class=p>};</span>

    <span class=cm>/* extra data associated with local object */</span>
    <span class=kt>void</span>            <span class=o>*</span><span class=n>cookie</span><span class=p>;</span>
<span class=p>};</span>
</code></pre></div> <p><code>type</code>表示Binder对象的类型，它取值如下所示：</p> <div class=highlight><pre><span></span><code><span class=k>enum</span> <span class=p>{</span>
    <span class=n>BINDER_TYPE_BINDER</span>  <span class=o>=</span> <span class=n>B_PACK_CHARS</span><span class=p>(</span><span class=sc>&#39;s&#39;</span><span class=p>,</span> <span class=sc>&#39;b&#39;</span><span class=p>,</span> <span class=sc>&#39;*&#39;</span><span class=p>,</span> <span class=n>B_TYPE_LARGE</span><span class=p>),</span>
    <span class=n>BINDER_TYPE_WEAK_BINDER</span> <span class=o>=</span> <span class=n>B_PACK_CHARS</span><span class=p>(</span><span class=sc>&#39;w&#39;</span><span class=p>,</span> <span class=sc>&#39;b&#39;</span><span class=p>,</span> <span class=sc>&#39;*&#39;</span><span class=p>,</span> <span class=n>B_TYPE_LARGE</span><span class=p>),</span>
    <span class=n>BINDER_TYPE_HANDLE</span>  <span class=o>=</span> <span class=n>B_PACK_CHARS</span><span class=p>(</span><span class=sc>&#39;s&#39;</span><span class=p>,</span> <span class=sc>&#39;h&#39;</span><span class=p>,</span> <span class=sc>&#39;*&#39;</span><span class=p>,</span> <span class=n>B_TYPE_LARGE</span><span class=p>),</span>
    <span class=n>BINDER_TYPE_WEAK_HANDLE</span> <span class=o>=</span> <span class=n>B_PACK_CHARS</span><span class=p>(</span><span class=sc>&#39;w&#39;</span><span class=p>,</span> <span class=sc>&#39;h&#39;</span><span class=p>,</span> <span class=sc>&#39;*&#39;</span><span class=p>,</span> <span class=n>B_TYPE_LARGE</span><span class=p>),</span>
    <span class=n>BINDER_TYPE_FD</span>      <span class=o>=</span> <span class=n>B_PACK_CHARS</span><span class=p>(</span><span class=sc>&#39;f&#39;</span><span class=p>,</span> <span class=sc>&#39;d&#39;</span><span class=p>,</span> <span class=sc>&#39;*&#39;</span><span class=p>,</span> <span class=n>B_TYPE_LARGE</span><span class=p>),</span>
<span class=p>};</span>
</code></pre></div> <p><code>flags</code>表示Binder对象的标志，该域只对第一次传递Binder实体时有效，因为此刻驱动需要在内核中创建相应的实体节点，有些参数需要从该域取出。<br> 最后，<code>binder</code>表示这是一个Binder实体，<code>handle</code>表示这是一个Binder引用，当这是一个Binder实体时，<code>cookie</code>才有意义，表示附加数据，由进程自己解释。</p> <p>数据结构分析完了，回到<code>binder_loop</code>函数中，首先是执行<code>BC_ENTER_LOOPER</code>命令：</p> <div class=highlight><pre><span></span><code><span class=n>readbuf</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>BC_ENTER_LOOPER</span><span class=p>;</span>
<span class=n>binder_write</span><span class=p>(</span><span class=n>bs</span><span class=p>,</span> <span class=n>readbuf</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>unsigned</span><span class=p>));</span>
</code></pre></div> <p>进入到<code>binder_write</code>函数中</p> <div class=highlight><pre><span></span><code><span class=kt>int</span> <span class=nf>binder_write</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_state</span> <span class=o>*</span><span class=n>bs</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>data</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=n>len</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>struct</span> <span class=nc>binder_write_read</span> <span class=n>bwr</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>res</span><span class=p>;</span>
    <span class=n>bwr</span><span class=p>.</span><span class=n>write_size</span> <span class=o>=</span> <span class=n>len</span><span class=p>;</span>
    <span class=n>bwr</span><span class=p>.</span><span class=n>write_consumed</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>bwr</span><span class=p>.</span><span class=n>write_buffer</span> <span class=o>=</span> <span class=p>(</span><span class=kt>unsigned</span><span class=p>)</span> <span class=n>data</span><span class=p>;</span>
    <span class=n>bwr</span><span class=p>.</span><span class=n>read_size</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>bwr</span><span class=p>.</span><span class=n>read_consumed</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>bwr</span><span class=p>.</span><span class=n>read_buffer</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>res</span> <span class=o>=</span> <span class=n>ioctl</span><span class=p>(</span><span class=n>bs</span><span class=o>-&gt;</span><span class=n>fd</span><span class=p>,</span> <span class=n>BINDER_WRITE_READ</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>bwr</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>res</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&quot;binder_write: ioctl failed (%s)</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span>
                <span class=n>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=n>res</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>注意这里的<code>binder_write_read</code>变量bwr，<code>write_size</code>大小为4，表示<code>write_buffer</code>缓冲区大小为4，它的内容是一个<code>BC_ENTER_LOOPER</code>命令协议号，<code>read_buffer</code>为空。接着又是调用<code>ioctl</code>函数进入到Binder驱动程序的<code>binder_ioctl</code>函数，这里我们也只是关注<code>BC_ENTER_LOOPER</code>相关的逻辑：</p> <div class=highlight><pre><span></span><code><span class=k>case</span> <span class=nl>BINDER_WRITE_READ</span><span class=p>:</span> <span class=p>{</span>
  <span class=k>struct</span> <span class=nc>binder_write_read</span> <span class=n>bwr</span><span class=p>;</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>size</span> <span class=o>!=</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_write_read</span><span class=p>))</span> <span class=p>{</span>
    <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>EINVAL</span><span class=p>;</span>
    <span class=k>goto</span> <span class=n>err</span><span class=p>;</span>
  <span class=p>}</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>copy_from_user</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bwr</span><span class=p>,</span> <span class=n>ubuf</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>bwr</span><span class=p>)))</span> <span class=p>{</span>
    <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
    <span class=k>goto</span> <span class=n>err</span><span class=p>;</span>
  <span class=p>}</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>binder_debug_mask</span> <span class=o>&amp;</span> <span class=n>BINDER_DEBUG_READ_WRITE</span><span class=p>)</span>
    <span class=n>printk</span><span class=p>(</span><span class=n>KERN_INFO</span> <span class=s>&quot;binder: %d:%d write %ld at %08lx, read %ld at %08lx</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span>
           <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=n>bwr</span><span class=p>.</span><span class=n>write_size</span><span class=p>,</span> <span class=n>bwr</span><span class=p>.</span><span class=n>write_buffer</span><span class=p>,</span> <span class=n>bwr</span><span class=p>.</span><span class=n>read_size</span><span class=p>,</span> <span class=n>bwr</span><span class=p>.</span><span class=n>read_buffer</span><span class=p>);</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>bwr</span><span class=p>.</span><span class=n>write_size</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>ret</span> <span class=o>=</span> <span class=n>binder_thread_write</span><span class=p>(</span><span class=n>proc</span><span class=p>,</span> <span class=kr>thread</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=p>)</span><span class=n>bwr</span><span class=p>.</span><span class=n>write_buffer</span><span class=p>,</span> <span class=n>bwr</span><span class=p>.</span><span class=n>write_size</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>bwr</span><span class=p>.</span><span class=n>write_consumed</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>bwr</span><span class=p>.</span><span class=n>read_consumed</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
      <span class=k>if</span> <span class=p>(</span><span class=n>copy_to_user</span><span class=p>(</span><span class=n>ubuf</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>bwr</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>bwr</span><span class=p>)))</span>
        <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
      <span class=k>goto</span> <span class=n>err</span><span class=p>;</span>
    <span class=p>}</span>
  <span class=p>}</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>bwr</span><span class=p>.</span><span class=n>read_size</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>ret</span> <span class=o>=</span> <span class=n>binder_thread_read</span><span class=p>(</span><span class=n>proc</span><span class=p>,</span> <span class=kr>thread</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=p>)</span><span class=n>bwr</span><span class=p>.</span><span class=n>read_buffer</span><span class=p>,</span> <span class=n>bwr</span><span class=p>.</span><span class=n>read_size</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>bwr</span><span class=p>.</span><span class=n>read_consumed</span><span class=p>,</span> <span class=n>filp</span><span class=o>-&gt;</span><span class=n>f_flags</span> <span class=o>&amp;</span> <span class=n>O_NONBLOCK</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>list_empty</span><span class=p>(</span><span class=o>&amp;</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>))</span>
      <span class=n>wake_up_interruptible</span><span class=p>(</span><span class=o>&amp;</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>wait</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
      <span class=k>if</span> <span class=p>(</span><span class=n>copy_to_user</span><span class=p>(</span><span class=n>ubuf</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>bwr</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>bwr</span><span class=p>)))</span>
        <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
      <span class=k>goto</span> <span class=n>err</span><span class=p>;</span>
    <span class=p>}</span>
  <span class=p>}</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>binder_debug_mask</span> <span class=o>&amp;</span> <span class=n>BINDER_DEBUG_READ_WRITE</span><span class=p>)</span>
    <span class=n>printk</span><span class=p>(</span><span class=n>KERN_INFO</span> <span class=s>&quot;binder: %d:%d wrote %ld of %ld, read return %ld of %ld</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span>
           <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=n>bwr</span><span class=p>.</span><span class=n>write_consumed</span><span class=p>,</span> <span class=n>bwr</span><span class=p>.</span><span class=n>write_size</span><span class=p>,</span> <span class=n>bwr</span><span class=p>.</span><span class=n>read_consumed</span><span class=p>,</span> <span class=n>bwr</span><span class=p>.</span><span class=n>read_size</span><span class=p>);</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>copy_to_user</span><span class=p>(</span><span class=n>ubuf</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>bwr</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>bwr</span><span class=p>)))</span> <span class=p>{</span>
    <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
    <span class=k>goto</span> <span class=n>err</span><span class=p>;</span>
  <span class=p>}</span>
  <span class=k>break</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>在这段代码开始的时候调用了<code>binder_get_thread</code>，从<code>proc</code>中直接获取到了<code>binder_thread</code>，不需要重新创建(代码没有贴出来)。 </p> <p>正式开始分析上面的代码：首先是通过<code>copy_from_user(&amp;bwr, ubuf, sizeof(bwr))</code>语句把用户传递进来的参数转换成<code>struct binder_write_read</code>结构体，并保存在本地变量<code>bwr</code>中，这里可以看出<code>bwr.write_size</code>等于4，于是进入<code>binder_thread_write</code>函数，这里我们只关注<code>BC_ENTER_LOOPER</code>相关的代码：</p> <div class=highlight><pre><span></span><code><span class=kt>int</span>
<span class=nf>binder_thread_write</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_proc</span> <span class=o>*</span><span class=n>proc</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>binder_thread</span> <span class=o>*</span><span class=kr>thread</span><span class=p>,</span>
            <span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=n>buffer</span><span class=p>,</span> <span class=kt>int</span> <span class=n>size</span><span class=p>,</span> <span class=kt>signed</span> <span class=kt>long</span> <span class=o>*</span><span class=n>consumed</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>uint32_t</span> <span class=n>cmd</span><span class=p>;</span>
    <span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=n>ptr</span> <span class=o>=</span> <span class=n>buffer</span> <span class=o>+</span> <span class=o>*</span><span class=n>consumed</span><span class=p>;</span>
    <span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=n>end</span> <span class=o>=</span> <span class=n>buffer</span> <span class=o>+</span> <span class=n>size</span><span class=p>;</span>

    <span class=k>while</span> <span class=p>(</span><span class=n>ptr</span> <span class=o>&lt;</span> <span class=n>end</span> <span class=o>&amp;&amp;</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>return_error</span> <span class=o>==</span> <span class=n>BR_OK</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>get_user</span><span class=p>(</span><span class=n>cmd</span><span class=p>,</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>__user</span> <span class=o>*</span><span class=p>)</span><span class=n>ptr</span><span class=p>))</span>
            <span class=k>return</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
        <span class=n>ptr</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>_IOC_NR</span><span class=p>(</span><span class=n>cmd</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>ARRAY_SIZE</span><span class=p>(</span><span class=n>binder_stats</span><span class=p>.</span><span class=n>bc</span><span class=p>))</span> <span class=p>{</span>
            <span class=n>binder_stats</span><span class=p>.</span><span class=n>bc</span><span class=p>[</span><span class=n>_IOC_NR</span><span class=p>(</span><span class=n>cmd</span><span class=p>)]</span><span class=o>++</span><span class=p>;</span>
            <span class=n>proc</span><span class=o>-&gt;</span><span class=n>stats</span><span class=p>.</span><span class=n>bc</span><span class=p>[</span><span class=n>_IOC_NR</span><span class=p>(</span><span class=n>cmd</span><span class=p>)]</span><span class=o>++</span><span class=p>;</span>
            <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>stats</span><span class=p>.</span><span class=n>bc</span><span class=p>[</span><span class=n>_IOC_NR</span><span class=p>(</span><span class=n>cmd</span><span class=p>)]</span><span class=o>++</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=k>switch</span> <span class=p>(</span><span class=n>cmd</span><span class=p>)</span> <span class=p>{</span>
        <span class=p>...</span>
        <span class=k>case</span> <span class=nl>BC_ENTER_LOOPER</span><span class=p>:</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>binder_debug_mask</span> <span class=o>&amp;</span> <span class=n>BINDER_DEBUG_THREADS</span><span class=p>)</span>
                <span class=n>printk</span><span class=p>(</span><span class=n>KERN_INFO</span> <span class=s>&quot;binder: %d:%d BC_ENTER_LOOPER</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span>
                       <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>);</span>
            <span class=k>if</span> <span class=p>(</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>looper</span> <span class=o>&amp;</span> <span class=n>BINDER_LOOPER_STATE_REGISTERED</span><span class=p>)</span> <span class=p>{</span>
                <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>looper</span> <span class=o>|=</span> <span class=n>BINDER_LOOPER_STATE_INVALID</span><span class=p>;</span>
                <span class=n>binder_user_error</span><span class=p>(</span><span class=s>&quot;binder: %d:%d ERROR:&quot;</span>
                    <span class=s>&quot; BC_ENTER_LOOPER called after &quot;</span>
                    <span class=s>&quot;BC_REGISTER_LOOPER</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span>
                    <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>);</span>
            <span class=p>}</span>
            <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>looper</span> <span class=o>|=</span> <span class=n>BINDER_LOOPER_STATE_ENTERED</span><span class=p>;</span>
            <span class=k>break</span><span class=p>;</span>
        <span class=p>...</span>
        <span class=k>default</span><span class=o>:</span>
            <span class=n>printk</span><span class=p>(</span><span class=n>KERN_ERR</span> <span class=s>&quot;binder: %d:%d unknown command %d</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span> <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=n>cmd</span><span class=p>);</span>
            <span class=k>return</span> <span class=o>-</span><span class=n>EINVAL</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=o>*</span><span class=n>consumed</span> <span class=o>=</span> <span class=n>ptr</span> <span class=o>-</span> <span class=n>buffer</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>回忆前面执行<code>binder_become_context_manager</code>到<code>binder_ioctl</code>时，调用<code>binder_get_thread</code>函数创建的<code>thread-&gt;looper</code>值为0，所以这里执行完<code>BC_ENTER_LOOPER</code>时，<code>thread-&gt;looper</code>值就变为<code>BINDER_LOOPER_STATE_ENTERED</code>了，表明当前线程进入循环状态了。</p> <p>回到<code>binder_ioctl</code>函数，由于<code>bwr.read_size == 0</code>，<code>binder_thread_read</code>函数就不会被执行了，这样，<code>binder_ioctl</code>的任务就完成了。</p> <p>回到<code>binder_loop</code>函数，进入for循环：</p> <div class=highlight><pre><span></span><code><span class=k>for</span> <span class=p>(;;)</span> <span class=p>{</span>
    <span class=n>bwr</span><span class=p>.</span><span class=n>read_size</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>readbuf</span><span class=p>);</span>
    <span class=n>bwr</span><span class=p>.</span><span class=n>read_consumed</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>bwr</span><span class=p>.</span><span class=n>read_buffer</span> <span class=o>=</span> <span class=p>(</span><span class=kt>unsigned</span><span class=p>)</span> <span class=n>readbuf</span><span class=p>;</span>

    <span class=n>res</span> <span class=o>=</span> <span class=n>ioctl</span><span class=p>(</span><span class=n>bs</span><span class=o>-&gt;</span><span class=n>fd</span><span class=p>,</span> <span class=n>BINDER_WRITE_READ</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>bwr</span><span class=p>);</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>res</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>LOGE</span><span class=p>(</span><span class=s>&quot;binder_loop: ioctl failed (%s)</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span> <span class=n>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
        <span class=k>break</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=n>res</span> <span class=o>=</span> <span class=n>binder_parse</span><span class=p>(</span><span class=n>bs</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>readbuf</span><span class=p>,</span> <span class=n>bwr</span><span class=p>.</span><span class=n>read_consumed</span><span class=p>,</span> <span class=n>func</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>res</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>LOGE</span><span class=p>(</span><span class=s>&quot;binder_loop: unexpected reply?!</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>);</span>
        <span class=k>break</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>res</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>LOGE</span><span class=p>(</span><span class=s>&quot;binder_loop: io error %d %s</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span> <span class=n>res</span><span class=p>,</span> <span class=n>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
        <span class=k>break</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div> <p>又是执行一个<code>ioctl</code>命令，注意，这里的<code>bwr</code>参数各个成员的值：</p> <div class=highlight><pre><span></span><code><span class=n>bwr</span><span class=p>.</span><span class=n>write_size</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
<span class=n>bwr</span><span class=p>.</span><span class=n>write_consumed</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
<span class=n>bwr</span><span class=p>.</span><span class=n>write_buffer</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
<span class=n>readbuf</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>BC_ENTER_LOOPER</span><span class=p>;</span>
<span class=n>bwr</span><span class=p>.</span><span class=n>read_size</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>readbuf</span><span class=p>);</span>
<span class=n>bwr</span><span class=p>.</span><span class=n>read_consumed</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
<span class=n>bwr</span><span class=p>.</span><span class=n>read_buffer</span> <span class=o>=</span> <span class=p>(</span><span class=kt>unsigned</span><span class=p>)</span> <span class=n>readbuf</span><span class=p>;</span>
</code></pre></div> <p>再次进入到<code>binder_ioctl</code>函数，此时<code>bwr.write_size</code>等于0，于是不会执行<code>binder_thread_write</code>函数，<code>bwr.read_size</code>等于32，于是进入到<code>binder_thread_read</code>函数：</p> <div class=highlight><pre><span></span><code><span class=k>static</span> <span class=kt>int</span>
<span class=n>binder_thread_read</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_proc</span> <span class=o>*</span><span class=n>proc</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>binder_thread</span> <span class=o>*</span><span class=kr>thread</span><span class=p>,</span>
    <span class=kt>void</span>  <span class=n>__user</span> <span class=o>*</span><span class=n>buffer</span><span class=p>,</span> <span class=kt>int</span> <span class=n>size</span><span class=p>,</span> <span class=kt>signed</span> <span class=kt>long</span> <span class=o>*</span><span class=n>consumed</span><span class=p>,</span> <span class=kt>int</span> <span class=n>non_block</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=n>ptr</span> <span class=o>=</span> <span class=n>buffer</span> <span class=o>+</span> <span class=o>*</span><span class=n>consumed</span><span class=p>;</span>
    <span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=n>end</span> <span class=o>=</span> <span class=n>buffer</span> <span class=o>+</span> <span class=n>size</span><span class=p>;</span>

    <span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>wait_for_proc_work</span><span class=p>;</span>

    <span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=n>consumed</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>put_user</span><span class=p>(</span><span class=n>BR_NOOP</span><span class=p>,</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>__user</span> <span class=o>*</span><span class=p>)</span><span class=n>ptr</span><span class=p>))</span>
            <span class=k>return</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
        <span class=n>ptr</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>);</span>
    <span class=p>}</span>

<span class=nl>retry</span><span class=p>:</span>
    <span class=n>wait_for_proc_work</span> <span class=o>=</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>transaction_stack</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=o>&amp;&amp;</span> <span class=n>list_empty</span><span class=p>(</span><span class=o>&amp;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>);</span>

    <span class=k>if</span> <span class=p>(</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>return_error</span> <span class=o>!=</span> <span class=n>BR_OK</span> <span class=o>&amp;&amp;</span> <span class=n>ptr</span> <span class=o>&lt;</span> <span class=n>end</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>return_error2</span> <span class=o>!=</span> <span class=n>BR_OK</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>put_user</span><span class=p>(</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>return_error2</span><span class=p>,</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>__user</span> <span class=o>*</span><span class=p>)</span><span class=n>ptr</span><span class=p>))</span>
                <span class=k>return</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
            <span class=n>ptr</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>);</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>ptr</span> <span class=o>==</span> <span class=n>end</span><span class=p>)</span>
                <span class=k>goto</span> <span class=n>done</span><span class=p>;</span>
            <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>return_error2</span> <span class=o>=</span> <span class=n>BR_OK</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>put_user</span><span class=p>(</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>return_error</span><span class=p>,</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>__user</span> <span class=o>*</span><span class=p>)</span><span class=n>ptr</span><span class=p>))</span>
            <span class=k>return</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
        <span class=n>ptr</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>);</span>
        <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_OK</span><span class=p>;</span>
        <span class=k>goto</span> <span class=n>done</span><span class=p>;</span>
    <span class=p>}</span>


    <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>looper</span> <span class=o>|=</span> <span class=n>BINDER_LOOPER_STATE_WAITING</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>wait_for_proc_work</span><span class=p>)</span>
        <span class=n>proc</span><span class=o>-&gt;</span><span class=n>ready_threads</span><span class=o>++</span><span class=p>;</span>
    <span class=n>mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>binder_lock</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>wait_for_proc_work</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>looper</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>BINDER_LOOPER_STATE_REGISTERED</span> <span class=o>|</span>
                    <span class=n>BINDER_LOOPER_STATE_ENTERED</span><span class=p>)))</span> <span class=p>{</span>
            <span class=n>binder_user_error</span><span class=p>(</span><span class=s>&quot;binder: %d:%d ERROR: Thread waiting &quot;</span>
                <span class=s>&quot;for process work before calling BC_REGISTER_&quot;</span>
                <span class=s>&quot;LOOPER or BC_ENTER_LOOPER (state %x)</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span>
                <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>looper</span><span class=p>);</span>
            <span class=n>wait_event_interruptible</span><span class=p>(</span><span class=n>binder_user_error_wait</span><span class=p>,</span> <span class=n>binder_stop_on_user_error</span> <span class=o>&lt;</span> <span class=mi>2</span><span class=p>);</span>
        <span class=p>}</span>
        <span class=n>binder_set_nice</span><span class=p>(</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>default_priority</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>non_block</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>binder_has_proc_work</span><span class=p>(</span><span class=n>proc</span><span class=p>,</span> <span class=kr>thread</span><span class=p>))</span>
                <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>EAGAIN</span><span class=p>;</span>
        <span class=p>}</span> <span class=k>else</span>
            <span class=n>ret</span> <span class=o>=</span> <span class=n>wait_event_interruptible_exclusive</span><span class=p>(</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>wait</span><span class=p>,</span> <span class=n>binder_has_proc_work</span><span class=p>(</span><span class=n>proc</span><span class=p>,</span> <span class=kr>thread</span><span class=p>));</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>non_block</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>binder_has_thread_work</span><span class=p>(</span><span class=kr>thread</span><span class=p>))</span>
                <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>EAGAIN</span><span class=p>;</span>
        <span class=p>}</span> <span class=k>else</span>
            <span class=n>ret</span> <span class=o>=</span> <span class=n>wait_event_interruptible</span><span class=p>(</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>wait</span><span class=p>,</span> <span class=n>binder_has_thread_work</span><span class=p>(</span><span class=kr>thread</span><span class=p>));</span>
    <span class=p>}</span>
    <span class=p>...</span>
<span class=p>}</span>
</code></pre></div> <p>传入的参数<code>*consumed == 0</code>，于是写入一个值<code>BR_NOOP</code>到参数<code>ptr</code>指向的缓冲区中去，即用户传进来的<code>bwr.read_buffer</code>缓冲区。这时候，<code>thread-&gt;transaction_stack == NULL</code>，并且<code>thread-&gt;todo</code>列表也是空的，这表示当前线程没有事务需要处理，于是<code>wait_for_proc_work</code>为true，表示要去查看proc是否有未处理的事务。当前<code>thread-&gt;return_error == BR_OK</code>，这是前面创建binder_thread时初始化设置的。于是继续往下执行，设置thread的状态为<code>BINDER_LOOPER_STATE_WAITING</code>，表示线程处于等待状态。调用<code>binder_set_nice</code>函数设置当前线程的优先级别为<code>proc-&gt;default_priority</code>，这是因为thread要去处理属于proc的事务，因此要将此thread的优先级别设置和proc一样。在这个场景中，proc也没有事务处理，即<code>binder_has_proc_work(proc, thread)</code>为false。如果文件打开模式为非阻塞模式，即<code>non_block</code>为true，那么函数就直接返回-EAGAIN，要求用户重新执行<code>ioctl</code>；否则的话，就通过当前线程就通过<code>wait_event_interruptible_exclusive</code>函数进入休眠状态，等待请求到来再唤醒了。</p> <p>至此，我们就从源代码一步一步地分析完Service Manager是如何成为Android进程间通信（IPC）机制Binder守护进程的了。<br> 总结一下，Service Manager是成为Android进程间通信（IPC）机制Binder守护进程的过程是这样的：<br> 1.&nbsp;打开/dev/binder文件：<code>open("/dev/binder", O_RDWR);</code><br> 2.&nbsp;建立128K内存映射：<code>mmap(NULL, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, 0);</code><br> 3.&nbsp;通知Binder驱动程序它是守护进程：<code>binder_become_context_manager(bs);</code><br> 4.&nbsp;进入循环等待请求的到来：<code>binder_loop(bs, svcmgr_handler);</code><br> 在这个过程中，在Binder驱动程序中建立了一个<code>struct binder_proc</code>结构、一个<code>struct binder_thread</code>结构和一个<code>struct binder_node</code>结构，这样，Service Manager就在Android系统的进程间通信机制Binder担负起守护进程的职责了。</p> <h2 id=2-binderserverclientservice-manager>2 <a href=https://blog.csdn.net/luoshengyang/article/details/6627260>Binder中的Server和Client获得Service Manager接口之路</a><a class=headerlink href=#2-binderserverclientservice-manager title="Permanent link">&para;</a></h2> <p><strong>上一节介绍了Service Manager是如何成为Binder机制的守护进程的。既然作为守护进程，Service Manager的职责当然就是为Server和Client服务了。那么，Server和Client如何获得Service Manager接口，进而享受它提供的服务呢？本文将简要分析Server和Client获得Service Manager的过程。</strong></p> <p>我们知道，Service Manager在Binder机制中既充当守护进程的角色，同时它也充当着Server角色，然而它又与一般的Server不一样。对于普通的Server来说，Client如果想要获得Server的远程接口，那么必须通过Service Manager远程接口提供的getService接口来获得，这本身就是一个使用Binder机制来进行进程间通信的过程。而对于Service Manager这个Server来说，Client如果想要获得Service Manager远程接口，却不必通过进程间通信机制来获得，因为Service Manager远程接口是一个特殊的Binder引用，它的引用句柄一定是0。</p> <p>获取Service Manager远程接口的函数是<code>defaultServiceManager()</code>，声明在 <strong>frameworks/base/include/binder/IServiceManager.h</strong></p> <div class=highlight><pre><span></span><code><span class=n>sp</span><span class=o>&lt;</span><span class=n>IServiceManager</span><span class=o>&gt;</span> <span class=n>defaultServiceManager</span><span class=p>();</span>
</code></pre></div> <p>实现在：<strong>frameworks/base/include/binder/IServiceManager.cpp</strong></p> <div class=highlight><pre><span></span><code><span class=n>sp</span><span class=o>&lt;</span><span class=n>IServiceManager</span><span class=o>&gt;</span> <span class=n>defaultServiceManager</span><span class=p>()</span>
<span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>gDefaultServiceManager</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=k>return</span> <span class=n>gDefaultServiceManager</span><span class=p>;</span>

    <span class=p>{</span>
        <span class=n>AutoMutex</span> <span class=nf>_l</span><span class=p>(</span><span class=n>gDefaultServiceManagerLock</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>gDefaultServiceManager</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>gDefaultServiceManager</span> <span class=o>=</span> <span class=n>interface_cast</span><span class=o>&lt;</span><span class=n>IServiceManager</span><span class=o>&gt;</span><span class=p>(</span>
                                                                     <span class=n>ProcessState</span><span class=o>::</span><span class=n>self</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>getContextObject</span><span class=p>(</span><span class=nb>NULL</span><span class=p>));</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>gDefaultServiceManager</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p><code>gDefaultServiceManagerLock</code>和<code>gDefaultServiceManager</code>是全局变量，定义在 <strong>frameworks/base/libs/binder/Static.cpp</strong> 文件中：</p> <p><code>c Mutex gDefaultServiceManagerLock; sp&lt;IServiceManager&gt; gDefaultServiceManager;</code></p> <p>从这个函数可以看出，<code>gDefaultServiceManager</code>是单例模式，调用<code>defaultServiceManager</code>函数时，如果<code>gDefaultServiceManager</code>已经创建，则直接返回，否则通过<code>interface_cast&lt;IServiceManager&gt;(ProcessState::self()-&gt;getContextObject(NULL))</code>来创建一个，并保存在<code>gDefaultServiceManager</code>全局变量中。</p> <p>在继续介绍<code>interface_cast&lt;IServiceManager&gt;(ProcessState::self()-&gt;getContextObject(NULL))</code>的实现之前，先来看一个类图，这能够帮助们了解Service Manager远程接口的创建过程。</p> <p><a href=/assets/images/android/binder_service_manager.png><img alt="Service Manager UML图" src=/assets/images/android/binder_service_manager.png></a></p> <p>在2.1节已经解释过这个图了。这里在重述一遍：<code>BpServiceManager</code>类继承了<code>BpInterface&lt;IServiceManager&gt;</code>类，<code>BpInterface</code>是一个模板类，它定义在 <strong>frameworks/base/include/binder/IInterface.h</strong> 文件中：</p> <div class=highlight><pre><span></span><code><span class=n>template</span><span class=o>&lt;</span><span class=n>typename</span> <span class=n>INTERFACE</span><span class=o>&gt;</span>
<span class=n>class</span> <span class=nl>BpInterface</span> <span class=p>:</span> <span class=n>public</span> <span class=n>INTERFACE</span><span class=p>,</span> <span class=n>public</span> <span class=n>BpRefBase</span>
<span class=p>{</span>
<span class=nl>public</span><span class=p>:</span>
    <span class=n>BpInterface</span><span class=p>(</span><span class=k>const</span> <span class=n>sp</span><span class=o>&lt;</span><span class=n>IBinder</span><span class=o>&gt;&amp;</span> <span class=n>remote</span><span class=p>);</span>

<span class=nl>protected</span><span class=p>:</span>
    <span class=n>virtual</span> <span class=n>IBinder</span><span class=o>*</span>            <span class=n>onAsBinder</span><span class=p>();</span>
<span class=p>};</span>
</code></pre></div> <p><code>IServiceManager</code>类继承了<code>IInterface</code>类，而<code>IInterface</code>类和<code>BpRefBase</code>类又分别继承了<code>RefBase</code>类。在<code>BpRefBase</code>类中，有一个成员变量<code>mRemote</code>，它的类型是<code>IBinder*</code>，实现类为<code>BpBinder</code>，它表示一个<code>Binder</code>引用，引用句柄值保存在<code>BpBinder</code>类的<code>mHandle</code>成员变量中。<code>BpBinder</code>类通过<code>IPCThreadState</code>类来和<code>Binder</code>驱动程序并互，而<code>IPCThreadState</code>又通过它的成员变量<code>mProcess</code>来打开<code>/dev/binder</code>设备文件，<code>mProcess</code>成员变量的类型为<code>ProcessState</code>。<code>ProcessState</code>类打开设备<code>/dev/binder</code>之后，将打开文件描述符保存在<code>mDriverFD</code>成员变量中，以供后续使用。</p> <p>我们很早以前就知道了<code>interface_cast&lt;IServiceManager&gt;(ProcessState::self()-&gt;getContextObject(NULL))</code>其实就等价于<code>new BpServiceManager(new BpBinder(0));</code>。 </p> <p>这样，Service Manager远程接口就创建完成了，它本质上是一个<code>BpServiceManager</code>，包含了一个句柄值为0的<code>Binder</code>引用。 </p> <p>在Android系统的Binder机制中，Server和Client拿到这个Service Manager远程接口之后怎么用呢？<br> 对Server来说，就是调用<code>IServiceManager::addService</code>这个接口来和Binder驱动程序交互了，即调用<code>BpServiceManager::addService</code>。而<code>BpServiceManager::addService</code>又会调用通过其基类<code>BpRefBase</code>的成员函数<code>remote</code>获得原先创建的<code>BpBinder</code>实例，接着调用<code>BpBinder::transact</code>成员函数。在<code>BpBinder::transact</code>函数中，又会调用<code>IPCThreadState::transact</code>成员函数，这里就是最终与Binder驱动程序交互的地方了。回忆一下前面的类图，<code>IPCThreadState</code>有一个<code>PorcessState</code>类型的成中变量<code>mProcess</code>，而<code>mProcess</code>有一个成员变量<code>mDriverFD</code>，它是设备文件/dev/binder的打开文件描述符，因此，<code>IPCThreadState</code>就相当于间接在拥有了设备文件/dev/binder的打开文件描述符，于是，便可以与Binder驱动程序交互了。<br> 对Client来说，就是调用<code>IServiceManager::getService</code>这个接口来和Binder驱动程序交互了。具体过程上述Server使用Service Manager的方法是一样的，这里就不再累述了。</p> <h2 id=3-service-managerserverserver>3 <a href=https://blog.csdn.net/luoshengyang/article/details/6629298>Service Manager在Server的启动中是如何为Server提供服务的</a><a class=headerlink href=#3-service-managerserverserver title="Permanent link">&para;</a></h2> <p>还是以MediaPlayerService来分析。首先，看一下MediaPlayerService的类图，以便我们理解下面要描述的内容。</p> <p><a href=/assets/images/android/binder_media_player_service.png><img alt=MediaPlayerService src=/assets/images/android/binder_media_player_service.png></a></p> <p>从前面的分析以及上图中可以看出<code>MediaPlayerService</code>继承至<code>BnMediaPlayerService</code>，这里的Bn是指Binder Native，用来处理Client请求的。 <code>BnMediaPlayerService</code>继承至<code>BnInterface&lt;IServiceManager&gt;</code>，和<code>BpInterface</code>一样，<code>BnInterface</code>也是一个模板类：</p> <p><strong>frameworks/base/include/binder/IInterface.h</strong></p> <div class=highlight><pre><span></span><code><span class=n>template</span><span class=o>&lt;</span><span class=n>typename</span> <span class=n>INTERFACE</span><span class=o>&gt;</span>
<span class=n>class</span> <span class=nl>BpInterface</span> <span class=p>:</span> <span class=n>public</span> <span class=n>INTERFACE</span><span class=p>,</span> <span class=n>public</span> <span class=n>BpRefBase</span>
<span class=p>{</span>
<span class=nl>public</span><span class=p>:</span>
    <span class=n>BpInterface</span><span class=p>(</span><span class=k>const</span> <span class=n>sp</span><span class=o>&lt;</span><span class=n>IBinder</span><span class=o>&gt;&amp;</span> <span class=n>remote</span><span class=p>);</span>

<span class=nl>protected</span><span class=p>:</span>
    <span class=n>virtual</span> <span class=n>IBinder</span><span class=o>*</span>            <span class=n>onAsBinder</span><span class=p>();</span>
<span class=p>};</span>
</code></pre></div> <p>这是一个多继承的类，<code>BnMediaPlayerService</code>实际是继承了<code>IMediaPlayerService</code>和<code>BBinder</code>类。<code>IMediaPlayerService</code>和<code>BBinder</code>类又分别继承了<code>IInterface</code>和<code>IBinder</code>类，<code>IInterface</code>和<code>IBinder</code>类又同时继承了<code>RefBase</code>类。</p> <p>实际上，从2.1节可以知道，<code>BnMediaPlayerService</code>并不是直接接收到Client处发送过来的请求，而是使用了<code>IPCThreadState</code>接收Client处发送过来的请求，而<code>IPCThreadState</code>又借助了<code>ProcessState</code>类来与<code>Binder</code>驱动程序交互。<code>IPCThreadState</code>接收到了Client处的请求后，就会调用<code>BBinder</code>类的<code>transact</code>函数，并传入相关参数，<code>BBinder</code>类的<code>transact</code>函数最终调用<code>BnMediaPlayerService</code>类的<code>onTransact</code>函数，于是，就开始真正地处理Client的请求了。</p> <p>下面正式进入本节主题，看看<code>MediaPlayerService</code>是如何启动的。</p> <p>大部分内容同第2.1节，所以一些代码不再重复贴出。</p> <p>首先看frameworks/base/media/mediaserver/main_mediaserver.cpp的<code>main</code>函数。第一句代码就是</p> <div class=highlight><pre><span></span><code><span class=n>sp</span><span class=o>&lt;</span><span class=n>ProcessState</span><span class=o>&gt;</span> <span class=n>proc</span><span class=p>(</span><span class=n>ProcessState</span><span class=o>::</span><span class=n>self</span><span class=p>());</span>
</code></pre></div> <p><code>ProcessState::self()</code>的作用就是返回一个全局唯一的<code>ProcessState</code>实例<code>gProcess</code>，该变量定义在：</p> <p><strong>frameworks/base/libs/binder/Static.cpp</strong></p> <div class=highlight><pre><span></span><code><span class=n>Mutex</span> <span class=n>gProcessMutex</span><span class=p>;</span>
<span class=n>sp</span><span class=o>&lt;</span><span class=n>ProcessState</span><span class=o>&gt;</span> <span class=n>gProcess</span><span class=p>;</span>
</code></pre></div> <p><code>ProcessState</code>的构造函数有两个关键的地方： 1. 通过<code>open_driver</code>函数打开Binder设备/dev/binder，并在打开设备文件描述符保存在成员变量<code>mDriverFD</code>中 2. 通过<code>mmap</code>来把设备文件/dev/binder映射到内存中</p> <p>在<code>open_driver</code>函数中通过<code>open</code>文件操作函数来打开/dev/binder设备文件，然后再调用<code>ioctl</code>文件控制函数来分别执行<code>BINDER_VERSION</code>和<code>BINDER_SET_MAX_THREADS</code>两个命令来和Binder驱动程序进行交互。前者用于获得当前Binder驱动程序的版本号；后者用于通知Binder驱动程序，MediaPlayerService最多可同时启动15个线程来处理Client端的请求。 </p> <p>先看看<code>open</code>函数，<code>open</code>在Binder驱动程序中的实现，参考前面内容。打开/dev/binder设备文件后，Binder驱动程序就为MediaPlayerService进程创建了一个<code>struct binder_proc</code>结构体实例来维护MediaPlayerService进程上下文相关信息。</p> <p>然后就是<code>ioctl</code>文件操作函数执行<code>BINDER_VERSION</code>命令的过程：</p> <div class=highlight><pre><span></span><code><span class=n>status_t</span> <span class=n>result</span> <span class=o>=</span> <span class=n>ioctl</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>BINDER_VERSION</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>vers</span><span class=p>);</span>
</code></pre></div> <p>该函数最终会进入Binder驱动程序的<code>binder_ioctl</code>函数中，我们只关注<code>BINDER_VERSION</code>相关的部分逻辑：</p> <div class=highlight><pre><span></span><code><span class=k>case</span> <span class=nl>BINDER_VERSION</span><span class=p>:</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>size</span> <span class=o>!=</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_version</span><span class=p>))</span> <span class=p>{</span>
    <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>EINVAL</span><span class=p>;</span>
    <span class=k>goto</span> <span class=n>err</span><span class=p>;</span>
  <span class=p>}</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>put_user</span><span class=p>(</span><span class=n>BINDER_CURRENT_PROTOCOL_VERSION</span><span class=p>,</span> <span class=o>&amp;</span><span class=p>((</span><span class=k>struct</span> <span class=nc>binder_version</span> <span class=o>*</span><span class=p>)</span><span class=n>ubuf</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>protocol_version</span><span class=p>))</span> <span class=p>{</span>
    <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>EINVAL</span><span class=p>;</span>
    <span class=k>goto</span> <span class=n>err</span><span class=p>;</span>
  <span class=p>}</span>
  <span class=k>break</span><span class=p>;</span>
</code></pre></div> <p>很简单，只是将<code>BINDER_CURRENT_PROTOCOL_VERSION</code>写入到传入的参数arg指向的用户缓冲区中去就返回了。<br> BINDER_CURRENT_PROTOCOL_VERSION是一个宏：</p> <div class=highlight><pre><span></span><code><span class=cm>/* This is the current protocol version. */</span>
<span class=cp>#define BINDER_CURRENT_PROTOCOL_VERSION 7</span>
</code></pre></div> <p>这里为什么要把<code>ubuf</code>转换成<code>struct binder_version</code>之后，再通过其<code>protocol_version</code>成员变量再来写入呢，转了一圈，最终内容还是写入到<code>ubuf</code>中。我们看一下<code>struct binder_version</code>的定义就会明白：</p> <div class=highlight><pre><span></span><code><span class=cm>/* Use with BINDER_VERSION, driver fills in fields. */</span>
<span class=k>struct</span> <span class=nc>binder_version</span> <span class=p>{</span>
    <span class=cm>/* driver protocol version -- increment with incompatible change */</span>
    <span class=kt>signed</span> <span class=kt>long</span> <span class=n>protocol_version</span><span class=p>;</span>
<span class=p>};</span>
</code></pre></div> <p>从注释中可以看出来，这里是考虑到兼容性，因为以后很有可能不是用<code>signed long</code>来表示版本号。</p> <p>这里有一个重要的地方要注意的是，由于这里是打开设备文件/dev/binder之后，第一次进入到<code>binder_ioctl</code>函数，因此，这里调用<code>binder_get_thread</code>的时候，就会为当前线程创建一个<code>struct binder_thread</code>结构体变量来维护线程上下文信息。 </p> <p>接下来再看<code>ioctl</code>文件操作函数执行<code>BINDER_SET_MAX_THREADS</code>命令的过程：</p> <div class=highlight><pre><span></span><code><span class=n>result</span> <span class=o>=</span> <span class=n>ioctl</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>BINDER_SET_MAX_THREADS</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>maxThreads</span><span class=p>);</span>
</code></pre></div> <p><code>binder_ioctl</code>里<code>BINDER_SET_MAX_THREADS</code>相关的部分：</p> <div class=highlight><pre><span></span><code><span class=k>case</span> <span class=nl>BINDER_SET_MAX_THREADS</span><span class=p>:</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>copy_from_user</span><span class=p>(</span><span class=o>&amp;</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>max_threads</span><span class=p>,</span> <span class=n>ubuf</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>max_threads</span><span class=p>)))</span> <span class=p>{</span>
    <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>EINVAL</span><span class=p>;</span>
    <span class=k>goto</span> <span class=n>err</span><span class=p>;</span>
  <span class=p>}</span>
  <span class=k>break</span><span class=p>;</span>
</code></pre></div> <p>这里实现也是非常简单，只是简单地把用户传进来的参数保存在<code>proc-&gt;max_threads</code>中就完毕了。 </p> <p>注意，这里再调用<code>binder_get_thread</code>函数的时候，就可以在<code>proc-&gt;threads</code>中找到当前线程对应的<code>struct binder_thread</code>结构了，因为前面已经创建好并保存在<code>proc-&gt;threads</code>红黑树中。</p> <p>回到<code>ProcessState</code>的构造函数中，下面通过<code>mmap</code>函数来把设备文件<code>/dev/binder</code>映射到内存中，宏<code>BINDER_VM_SIZE</code>定义在：</p> <p><strong>frameworks/base/libs/binder/ProcessState.cpp</strong></p> <div class=highlight><pre><span></span><code><span class=cp>#define BINDER_VM_SIZE ((1*1024*1024) - (4096 *2))</span>
</code></pre></div> <p><code>mmap</code>函数调用完成之后，Binder驱动程序就为当前进程预留了<code>BINDER_VM_SIZE</code>大小的内存空间了。 </p> <p>这样，<code>ProcessState</code>全局唯一变量<code>gProcess</code>就创建完毕了，回到main_mediaserver.cpp文件中的main函数，下一步是调用<code>defaultServiceManager</code>函数来获得Service Manager的远程接口，这一步在上一节中有详细描述。 </p> <p>再接下来就进入到<code>MediaPlayerService::instantiate</code>函数把<code>MediaPlayerService</code>添加到Service Manger中去了。 </p> <p><strong>frameworks/base/media/libmediaplayerservice/MediaPlayerService.cpp</strong></p> <div class=highlight><pre><span></span><code><span class=kt>void</span> <span class=n>MediaPlayerService</span><span class=o>::</span><span class=n>instantiate</span><span class=p>()</span> <span class=p>{</span>
    <span class=n>defaultServiceManager</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>addService</span><span class=p>(</span>
                                        <span class=n>String16</span><span class=p>(</span><span class=s>&quot;media.player&quot;</span><span class=p>),</span> <span class=n>new</span> <span class=n>MediaPlayerService</span><span class=p>());</span>
<span class=p>}</span>
</code></pre></div> <p>我们重点看一下<code>IServiceManger::addService</code>的过程，这有助于我们加深对Binder机制的理解。 </p> <p>前面我们提到<code>defaultServiceManager</code>返回的实际上是个<code>BpServiceManager</code>，因此，我们看一下<code>BpServiceManger::addService</code>实现。 </p> <p><strong>frameworks/base/include/binder/IServiceManager.cpp</strong></p> <div class=highlight><pre><span></span><code><span class=n>virtual</span> <span class=n>status_t</span> <span class=n>addService</span><span class=p>(</span><span class=k>const</span> <span class=n>String16</span><span class=o>&amp;</span> <span class=n>name</span><span class=p>,</span> <span class=k>const</span> <span class=n>sp</span><span class=o>&lt;</span><span class=n>IBinder</span><span class=o>&gt;&amp;</span> <span class=n>service</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>Parcel</span> <span class=n>data</span><span class=p>,</span> <span class=n>reply</span><span class=p>;</span>
    <span class=n>data</span><span class=p>.</span><span class=n>writeInterfaceToken</span><span class=p>(</span><span class=n>IServiceManager</span><span class=o>::</span><span class=n>getInterfaceDescriptor</span><span class=p>());</span>
    <span class=n>data</span><span class=p>.</span><span class=n>writeString16</span><span class=p>(</span><span class=n>name</span><span class=p>);</span>
    <span class=n>data</span><span class=p>.</span><span class=n>writeStrongBinder</span><span class=p>(</span><span class=n>service</span><span class=p>);</span>
    <span class=n>status_t</span> <span class=n>err</span> <span class=o>=</span> <span class=n>remote</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>transact</span><span class=p>(</span><span class=n>ADD_SERVICE_TRANSACTION</span><span class=p>,</span> <span class=n>data</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>reply</span><span class=p>);</span>
    <span class=k>return</span> <span class=n>err</span> <span class=o>==</span> <span class=n>NO_ERROR</span> <span class=o>?</span> <span class=n>reply</span><span class=p>.</span><span class=n>readInt32</span><span class=p>()</span> <span class=o>:</span> <span class=n>err</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p><code>Parcel</code>类是用来于序列化进程间通信数据用的。 </p> <p>先看这一句的调用：</p> <div class=highlight><pre><span></span><code><span class=n>data</span><span class=p>.</span><span class=n>writeInterfaceToken</span><span class=p>(</span><span class=n>IServiceManager</span><span class=o>::</span><span class=n>getInterfaceDescriptor</span><span class=p>());</span>
</code></pre></div> <p><code>IServiceManager::getInterfaceDescriptor()</code>返回的是一个字符串，即<code>android.os.IServiceManager</code>。我们看一下<code>Parcel::writeInterfaceToken</code>的实现：</p> <p><strong>frameworks/base/libs/binder/Parcel.cpp</strong> <div class=highlight><pre><span></span><code><span class=c1>// Write RPC headers.  (previously just the interface token)</span>
<span class=n>status_t</span> <span class=n>Parcel</span><span class=o>::</span><span class=n>writeInterfaceToken</span><span class=p>(</span><span class=k>const</span> <span class=n>String16</span><span class=o>&amp;</span> <span class=n>interface</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>writeInt32</span><span class=p>(</span><span class=n>IPCThreadState</span><span class=o>::</span><span class=n>self</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>getStrictModePolicy</span><span class=p>()</span> <span class=o>|</span>
               <span class=n>STRICT_MODE_PENALTY_GATHER</span><span class=p>);</span>
    <span class=c1>// currently the interface identification token is just its name as a string</span>
    <span class=k>return</span> <span class=nf>writeString16</span><span class=p>(</span><span class=n>interface</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div></p> <p>它的作用是写入一个整数和一个字符串到<code>Parcel</code>中去。</p> <p>再来看下面的调用<code>data.writeString16(name);</code>，这里又是写入一个字符串到<code>Parcel</code>中，也就是<code>media.player</code>。<br> 然后<code>data.writeStrongBinder(service);</code>，这里写入一个Binder对象到Parcel去。我们重点看一下这个函数的实现，因为它涉及到进程间传输Binder实体的问题，比较复杂，需要重点关注，同时，也是理解Binder机制的一个重点所在。注意，这里的<code>service</code>参数是一个MediaPlayerService对象。 </p> <div class=highlight><pre><span></span><code><span class=n>status_t</span> <span class=n>Parcel</span><span class=o>::</span><span class=n>writeStrongBinder</span><span class=p>(</span><span class=k>const</span> <span class=n>sp</span><span class=o>&lt;</span><span class=n>IBinder</span><span class=o>&gt;&amp;</span> <span class=n>val</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>return</span> <span class=nf>flatten_binder</span><span class=p>(</span><span class=n>ProcessState</span><span class=o>::</span><span class=n>self</span><span class=p>(),</span> <span class=n>val</span><span class=p>,</span> <span class=n>this</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div> <p>这里的<code>flatten_binder</code>函数，与前面提到Binder驱动程序中表示传输中的一个binder对象的数据结构<code>struct flat_binder_object</code>有一定关系。我们接着看此数据结构以及<code>flatten_binder</code>函数：</p> <div class=highlight><pre><span></span><code><span class=cm>/*</span>
<span class=cm> * This is the flattened representation of a Binder object for transfer</span>
<span class=cm> * between processes.  The &#39;offsets&#39; supplied as part of a binder transaction</span>
<span class=cm> * contains offsets into the data where these structures occur.  The Binder</span>
<span class=cm> * driver takes care of re-writing the structure type and data as it moves</span>
<span class=cm> * between processes.</span>
<span class=cm> */</span>
<span class=k>struct</span> <span class=nc>flat_binder_object</span> <span class=p>{</span>
    <span class=cm>/* 8 bytes for large_flat_header. */</span>
    <span class=kt>unsigned</span> <span class=kt>long</span>       <span class=n>type</span><span class=p>;</span>
    <span class=kt>unsigned</span> <span class=kt>long</span>       <span class=n>flags</span><span class=p>;</span>

    <span class=cm>/* 8 bytes of data. */</span>
    <span class=k>union</span> <span class=p>{</span>
        <span class=kt>void</span>        <span class=o>*</span><span class=n>binder</span><span class=p>;</span>    <span class=cm>/* local object */</span>
        <span class=kt>signed</span> <span class=kt>long</span> <span class=n>handle</span><span class=p>;</span>     <span class=cm>/* remote object */</span>
    <span class=p>};</span>

    <span class=cm>/* extra data associated with local object */</span>
    <span class=kt>void</span>            <span class=o>*</span><span class=n>cookie</span><span class=p>;</span>
<span class=p>};</span>

<span class=k>enum</span> <span class=p>{</span>
    <span class=n>FLAT_BINDER_FLAG_PRIORITY_MASK</span> <span class=o>=</span> <span class=mh>0xff</span><span class=p>,</span>
    <span class=n>FLAT_BINDER_FLAG_ACCEPTS_FDS</span> <span class=o>=</span> <span class=mh>0x100</span><span class=p>,</span>
<span class=p>};</span>

<span class=n>status_t</span> <span class=nf>flatten_binder</span><span class=p>(</span><span class=k>const</span> <span class=n>sp</span><span class=o>&lt;</span><span class=n>ProcessState</span><span class=o>&gt;&amp;</span> <span class=n>proc</span><span class=p>,</span>
    <span class=k>const</span> <span class=n>sp</span><span class=o>&lt;</span><span class=n>IBinder</span><span class=o>&gt;&amp;</span> <span class=n>binder</span><span class=p>,</span> <span class=n>Parcel</span><span class=o>*</span> <span class=n>out</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>flat_binder_object</span> <span class=n>obj</span><span class=p>;</span>

    <span class=n>obj</span><span class=p>.</span><span class=n>flags</span> <span class=o>=</span> <span class=mh>0x7f</span> <span class=o>|</span> <span class=n>FLAT_BINDER_FLAG_ACCEPTS_FDS</span><span class=p>;</span>
    <span class=c1>// binder即为MediaPlayerService实例，因此，不为空</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>binder</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>// MediaPlayerService继承自BBinder类，它是一个本地Binder实体</span>
        <span class=c1>// 因此binder-&gt;localBinder返回一个BBinder指针，所以不为空</span>
        <span class=n>IBinder</span> <span class=o>*</span><span class=n>local</span> <span class=o>=</span> <span class=n>binder</span><span class=o>-&gt;</span><span class=n>localBinder</span><span class=p>();</span>
        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>local</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>BpBinder</span> <span class=o>*</span><span class=n>proxy</span> <span class=o>=</span> <span class=n>binder</span><span class=o>-&gt;</span><span class=n>remoteBinder</span><span class=p>();</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>proxy</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
                <span class=n>LOGE</span><span class=p>(</span><span class=s>&quot;null proxy&quot;</span><span class=p>);</span>
            <span class=p>}</span>
            <span class=k>const</span> <span class=kt>int32_t</span> <span class=n>handle</span> <span class=o>=</span> <span class=n>proxy</span> <span class=o>?</span> <span class=n>proxy</span><span class=o>-&gt;</span><span class=n>handle</span><span class=p>()</span> <span class=o>:</span> <span class=mi>0</span><span class=p>;</span>
            <span class=n>obj</span><span class=p>.</span><span class=n>type</span> <span class=o>=</span> <span class=n>BINDER_TYPE_HANDLE</span><span class=p>;</span>
            <span class=n>obj</span><span class=p>.</span><span class=n>handle</span> <span class=o>=</span> <span class=n>handle</span><span class=p>;</span>
            <span class=n>obj</span><span class=p>.</span><span class=n>cookie</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=n>obj</span><span class=p>.</span><span class=n>type</span> <span class=o>=</span> <span class=n>BINDER_TYPE_BINDER</span><span class=p>;</span>
            <span class=n>obj</span><span class=p>.</span><span class=n>binder</span> <span class=o>=</span> <span class=n>local</span><span class=o>-&gt;</span><span class=n>getWeakRefs</span><span class=p>();</span>
            <span class=n>obj</span><span class=p>.</span><span class=n>cookie</span> <span class=o>=</span> <span class=n>local</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=c1>// 所以走这里</span>
        <span class=n>obj</span><span class=p>.</span><span class=n>type</span> <span class=o>=</span> <span class=n>BINDER_TYPE_BINDER</span><span class=p>;</span>
        <span class=n>obj</span><span class=p>.</span><span class=n>binder</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
        <span class=n>obj</span><span class=p>.</span><span class=n>cookie</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>finish_flatten_binder</span><span class=p>(</span><span class=n>binder</span><span class=p>,</span> <span class=n>obj</span><span class=p>,</span> <span class=n>out</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div> <p>首先是初始化<code>flat_binder_object</code>的<code>flags</code>：<code>obj.flags = 0x7f | FLAT_BINDER_FLAG_ACCEPTS_FDS;</code>。<br> 0x7f表示处理本Binder实体请求数据包的线程的最低优先级，<code>FLAT_BINDER_FLAG_ACCEPTS_FDS</code>表示这个Binder实体可以接受文件描述符，Binder实体在收到文件描述符时，就会在本进程中打开这个文件。</p> <p>传进来的<code>binder</code>即为<code>MediaPlayerService::instantiate</code>函数中new出来的MediaPlayerService实例，因此，不为空。又由于MediaPlayerService继承自BBinder类，它是一个本地Binder实体，因此<code>binder-&gt;localBinder</code>返回一个BBinder指针，而且肯定不为空，于是执行下面语句设置了<code>flat_binder_obj</code>的其他成员变量：</p> <div class=highlight><pre><span></span><code><span class=n>obj</span><span class=p>.</span><span class=n>type</span> <span class=o>=</span> <span class=n>BINDER_TYPE_BINDER</span><span class=p>;</span>
<span class=n>obj</span><span class=p>.</span><span class=n>binder</span> <span class=o>=</span> <span class=n>local</span><span class=o>-&gt;</span><span class=n>getWeakRefs</span><span class=p>();</span>
<span class=n>obj</span><span class=p>.</span><span class=n>cookie</span> <span class=o>=</span> <span class=n>local</span><span class=p>;</span>
</code></pre></div> <p>注意，指向这个Binder实体地址的指针local保存在flat_binder_obj的成员变量<code>cookie</code>中。</p> <p>在函数的最后调用了<code>finish_flatten_binder</code>来将这个flat_binder_obj写入到Parcel中去：</p> <div class=highlight><pre><span></span><code><span class=kr>inline</span> <span class=k>static</span> <span class=n>status_t</span> <span class=n>finish_flatten_binder</span><span class=p>(</span>
    <span class=k>const</span> <span class=n>sp</span><span class=o>&lt;</span><span class=n>IBinder</span><span class=o>&gt;&amp;</span> <span class=n>binder</span><span class=p>,</span> <span class=k>const</span> <span class=n>flat_binder_object</span><span class=o>&amp;</span> <span class=n>flat</span><span class=p>,</span> <span class=n>Parcel</span><span class=o>*</span> <span class=n>out</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>return</span> <span class=n>out</span><span class=o>-&gt;</span><span class=n>writeObject</span><span class=p>(</span><span class=n>flat</span><span class=p>,</span> <span class=nb>false</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div> <p><code>Parcel::writeObject</code>实现如下：</p> <div class=highlight><pre><span></span><code><span class=n>status_t</span> <span class=n>Parcel</span><span class=o>::</span><span class=n>writeObject</span><span class=p>(</span><span class=k>const</span> <span class=n>flat_binder_object</span><span class=o>&amp;</span> <span class=n>val</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>nullMetaData</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>const</span> <span class=kt>bool</span> <span class=n>enoughData</span> <span class=o>=</span> <span class=p>(</span><span class=n>mDataPos</span><span class=o>+</span><span class=k>sizeof</span><span class=p>(</span><span class=n>val</span><span class=p>))</span> <span class=o>&lt;=</span> <span class=n>mDataCapacity</span><span class=p>;</span>
    <span class=k>const</span> <span class=kt>bool</span> <span class=n>enoughObjects</span> <span class=o>=</span> <span class=n>mObjectsSize</span> <span class=o>&lt;</span> <span class=n>mObjectsCapacity</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>enoughData</span> <span class=o>&amp;&amp;</span> <span class=n>enoughObjects</span><span class=p>)</span> <span class=p>{</span>
<span class=nl>restart_write</span><span class=p>:</span>
        <span class=o>*</span><span class=n>reinterpret_cast</span><span class=o>&lt;</span><span class=n>flat_binder_object</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>mData</span><span class=o>+</span><span class=n>mDataPos</span><span class=p>)</span> <span class=o>=</span> <span class=n>val</span><span class=p>;</span>

        <span class=c1>// Need to write meta-data?</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>nullMetaData</span> <span class=o>||</span> <span class=n>val</span><span class=p>.</span><span class=n>binder</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
            <span class=c1>// 记录这个flat_binder_obj在Parcel里面的偏移位置</span>
            <span class=n>mObjects</span><span class=p>[</span><span class=n>mObjectsSize</span><span class=p>]</span> <span class=o>=</span> <span class=n>mDataPos</span><span class=p>;</span>
            <span class=n>acquire_object</span><span class=p>(</span><span class=n>ProcessState</span><span class=o>::</span><span class=n>self</span><span class=p>(),</span> <span class=n>val</span><span class=p>,</span> <span class=n>this</span><span class=p>);</span>
            <span class=n>mObjectsSize</span><span class=o>++</span><span class=p>;</span>
        <span class=p>}</span>

        <span class=c1>// remember if it&#39;s a file descriptor</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>val</span><span class=p>.</span><span class=n>type</span> <span class=o>==</span> <span class=n>BINDER_TYPE_FD</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>mHasFds</span> <span class=o>=</span> <span class=n>mFdsKnown</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
        <span class=p>}</span>

        <span class=k>return</span> <span class=n>finishWrite</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=n>flat_binder_object</span><span class=p>));</span>
    <span class=p>}</span>

    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>enoughData</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>const</span> <span class=n>status_t</span> <span class=n>err</span> <span class=o>=</span> <span class=n>growData</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=n>val</span><span class=p>));</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>err</span> <span class=o>!=</span> <span class=n>NO_ERROR</span><span class=p>)</span> <span class=k>return</span> <span class=n>err</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>enoughObjects</span><span class=p>)</span> <span class=p>{</span>
        <span class=kt>size_t</span> <span class=n>newSize</span> <span class=o>=</span> <span class=p>((</span><span class=n>mObjectsSize</span><span class=o>+</span><span class=mi>2</span><span class=p>)</span><span class=o>*</span><span class=mi>3</span><span class=p>)</span><span class=o>/</span><span class=mi>2</span><span class=p>;</span>
        <span class=kt>size_t</span><span class=o>*</span> <span class=n>objects</span> <span class=o>=</span> <span class=p>(</span><span class=kt>size_t</span><span class=o>*</span><span class=p>)</span><span class=n>realloc</span><span class=p>(</span><span class=n>mObjects</span><span class=p>,</span> <span class=n>newSize</span><span class=o>*</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>size_t</span><span class=p>));</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>objects</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=k>return</span> <span class=n>NO_MEMORY</span><span class=p>;</span>
        <span class=n>mObjects</span> <span class=o>=</span> <span class=n>objects</span><span class=p>;</span>
        <span class=n>mObjectsCapacity</span> <span class=o>=</span> <span class=n>newSize</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>goto</span> <span class=n>restart_write</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>这里除了把flat_binder_obj写到Parcel里面之内，还要记录这个flat_binder_obj在Parcel里面的偏移位置：<code>mObjects[mObjectsSize] = mDataPos;</code>。</p> <p>这里如果进程间传输的数据间带有Binder对象的时候，Binder驱动程序需要作进一步的处理，以维护各个Binder实体的一致性，下面我们将会看到Binder驱动程序是怎么处理这些Binder对象的。</p> <p>回到<code>BpServiceManager::addService</code>函数中，调用下面语句：</p> <div class=highlight><pre><span></span><code><span class=n>status_t</span> <span class=n>err</span> <span class=o>=</span> <span class=n>remote</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>transact</span><span class=p>(</span><span class=n>ADD_SERVICE_TRANSACTION</span><span class=p>,</span> <span class=n>data</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>reply</span><span class=p>);</span>
</code></pre></div> <p><code>remote()</code>返回的就是BpBinder指针。在<code>BpBinder::transact</code>函数中又调用了<code>IPCThreadState::transact</code>进执行实际的操作。<br> 注意，这里的mHandle为0，code为ADD_SERVICE_TRANSACTION。ADD_SERVICE_TRANSACTION是上面以参数形式传进来的，那mHandle为什么是0呢？因为这里表示的是Service Manager远程接口，它的句柄值一定是0。</p> <p>下面接着看<code>IPCThreadState::transact</code>：</p> <div class=highlight><pre><span></span><code><span class=c1>// flags是一个默认值为0的参数，上面没有传相应的实参进来，因此，这里就为0</span>
<span class=n>status_t</span> <span class=n>IPCThreadState</span><span class=o>::</span><span class=n>transact</span><span class=p>(</span><span class=kt>int32_t</span> <span class=n>handle</span><span class=p>,</span>
                                  <span class=kt>uint32_t</span> <span class=n>code</span><span class=p>,</span> <span class=k>const</span> <span class=n>Parcel</span><span class=o>&amp;</span> <span class=n>data</span><span class=p>,</span>
                                  <span class=n>Parcel</span><span class=o>*</span> <span class=n>reply</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>flags</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>status_t</span> <span class=n>err</span> <span class=o>=</span> <span class=n>data</span><span class=p>.</span><span class=n>errorCheck</span><span class=p>();</span>

    <span class=n>flags</span> <span class=o>|=</span> <span class=n>TF_ACCEPT_FDS</span><span class=p>;</span>

    <span class=n>IF_LOG_TRANSACTIONS</span><span class=p>()</span> <span class=p>{</span>
        <span class=n>TextOutput</span><span class=o>::</span><span class=n>Bundle</span> <span class=n>_b</span><span class=p>(</span><span class=n>alog</span><span class=p>);</span>
        <span class=n>alog</span> <span class=o>&lt;&lt;</span> <span class=s>&quot;BC_TRANSACTION thr &quot;</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>pthread_self</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&quot; / hand &quot;</span>
        <span class=o>&lt;&lt;</span> <span class=n>handle</span> <span class=o>&lt;&lt;</span> <span class=s>&quot; / code &quot;</span> <span class=o>&lt;&lt;</span> <span class=n>TypeCode</span><span class=p>(</span><span class=n>code</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=s>&quot;: &quot;</span>
        <span class=o>&lt;&lt;</span> <span class=n>indent</span> <span class=o>&lt;&lt;</span> <span class=n>data</span> <span class=o>&lt;&lt;</span> <span class=n>dedent</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>err</span> <span class=o>==</span> <span class=n>NO_ERROR</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>LOG_ONEWAY</span><span class=p>(</span><span class=s>&quot;&gt;&gt;&gt;&gt; SEND from pid %d uid %d %s&quot;</span><span class=p>,</span> <span class=n>getpid</span><span class=p>(),</span> <span class=n>getuid</span><span class=p>(),</span>
                   <span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>TF_ONE_WAY</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>?</span> <span class=s>&quot;READ REPLY&quot;</span> <span class=o>:</span> <span class=s>&quot;ONE WAY&quot;</span><span class=p>);</span>
        <span class=c1>// 首先调用此函数准备好一个struct binder_transaction_data结构体变量</span>
        <span class=c1>// 这个是后面要传输给Binder驱动程序的</span>
        <span class=n>err</span> <span class=o>=</span> <span class=n>writeTransactionData</span><span class=p>(</span><span class=n>BC_TRANSACTION</span><span class=p>,</span> <span class=n>flags</span><span class=p>,</span> <span class=n>handle</span><span class=p>,</span> <span class=n>code</span><span class=p>,</span> <span class=n>data</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>err</span> <span class=o>!=</span> <span class=n>NO_ERROR</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>reply</span><span class=p>)</span> <span class=n>reply</span><span class=o>-&gt;</span><span class=n>setError</span><span class=p>(</span><span class=n>err</span><span class=p>);</span>
        <span class=k>return</span> <span class=p>(</span><span class=n>mLastError</span> <span class=o>=</span> <span class=n>err</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=c1>// (flags &amp; TF_ONE_WAY) == 0为true</span>
    <span class=k>if</span> <span class=p>((</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>TF_ONE_WAY</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>// 并且reply不为空</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>reply</span><span class=p>)</span> <span class=p>{</span>
            <span class=c1>// 执行这条路径</span>
            <span class=n>err</span> <span class=o>=</span> <span class=n>waitForResponse</span><span class=p>(</span><span class=n>reply</span><span class=p>);</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=n>Parcel</span> <span class=n>fakeReply</span><span class=p>;</span>
            <span class=n>err</span> <span class=o>=</span> <span class=n>waitForResponse</span><span class=p>(</span><span class=o>&amp;</span><span class=n>fakeReply</span><span class=p>);</span>
        <span class=p>}</span>

        <span class=n>IF_LOG_TRANSACTIONS</span><span class=p>()</span> <span class=p>{</span>
            <span class=n>TextOutput</span><span class=o>::</span><span class=n>Bundle</span> <span class=n>_b</span><span class=p>(</span><span class=n>alog</span><span class=p>);</span>
            <span class=n>alog</span> <span class=o>&lt;&lt;</span> <span class=s>&quot;BR_REPLY thr &quot;</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>pthread_self</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&quot; / hand &quot;</span>
            <span class=o>&lt;&lt;</span> <span class=n>handle</span> <span class=o>&lt;&lt;</span> <span class=s>&quot;: &quot;</span><span class=p>;</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>reply</span><span class=p>)</span> <span class=n>alog</span> <span class=o>&lt;&lt;</span> <span class=n>indent</span> <span class=o>&lt;&lt;</span> <span class=o>*</span><span class=n>reply</span> <span class=o>&lt;&lt;</span> <span class=n>dedent</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
            <span class=k>else</span> <span class=n>alog</span> <span class=o>&lt;&lt;</span> <span class=s>&quot;(none requested)&quot;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=n>err</span> <span class=o>=</span> <span class=n>waitForResponse</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>err</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>函数首先调用<code>writeTransactionData</code>函数准备好一个<code>struct binder_transaction_data</code>结构体变量，这个是等一下要传输给Binder驱动程序的。<code>struct binder_transaction_data</code>的定义在本章中有解释。这里为了方便描述，将<code>struct binder_transaction_data</code>的定义再次列出来：</p> <div class=highlight><pre><span></span><code><span class=k>struct</span> <span class=nc>binder_transaction_data</span> <span class=p>{</span>
    <span class=cm>/* The first two are only used for bcTRANSACTION and brTRANSACTION,</span>
<span class=cm>     * identifying the target and contents of the transaction.</span>
<span class=cm>     */</span>
    <span class=k>union</span> <span class=p>{</span>
        <span class=kt>size_t</span>  <span class=n>handle</span><span class=p>;</span> <span class=cm>/* target descriptor of command transaction */</span>
        <span class=kt>void</span>    <span class=o>*</span><span class=n>ptr</span><span class=p>;</span>   <span class=cm>/* target descriptor of return transaction */</span>
    <span class=p>}</span> <span class=n>target</span><span class=p>;</span>
    <span class=kt>void</span>        <span class=o>*</span><span class=n>cookie</span><span class=p>;</span>    <span class=cm>/* target object cookie */</span>
    <span class=kt>unsigned</span> <span class=kt>int</span>    <span class=n>code</span><span class=p>;</span>       <span class=cm>/* transaction command */</span>

    <span class=cm>/* General information about the transaction. */</span>
    <span class=kt>unsigned</span> <span class=kt>int</span>    <span class=n>flags</span><span class=p>;</span>
    <span class=kt>pid_t</span>       <span class=n>sender_pid</span><span class=p>;</span>
    <span class=kt>uid_t</span>       <span class=n>sender_euid</span><span class=p>;</span>
    <span class=kt>size_t</span>      <span class=n>data_size</span><span class=p>;</span>  <span class=cm>/* number of bytes of data */</span>
    <span class=kt>size_t</span>      <span class=n>offsets_size</span><span class=p>;</span>   <span class=cm>/* number of bytes of offsets */</span>

    <span class=cm>/* If this transaction is inline, the data immediately</span>
<span class=cm>     * follows here; otherwise, it ends with a pointer to</span>
<span class=cm>     * the data buffer.</span>
<span class=cm>     */</span>
    <span class=k>union</span> <span class=p>{</span>
        <span class=k>struct</span> <span class=p>{</span>
            <span class=cm>/* transaction data */</span>
            <span class=k>const</span> <span class=kt>void</span>  <span class=o>*</span><span class=n>buffer</span><span class=p>;</span>
            <span class=cm>/* offsets from buffer to flat_binder_object structs */</span>
            <span class=k>const</span> <span class=kt>void</span>  <span class=o>*</span><span class=n>offsets</span><span class=p>;</span>
        <span class=p>}</span> <span class=n>ptr</span><span class=p>;</span>
        <span class=kt>uint8_t</span> <span class=n>buf</span><span class=p>[</span><span class=mi>8</span><span class=p>];</span>
    <span class=p>}</span> <span class=n>data</span><span class=p>;</span>
<span class=p>};</span>
</code></pre></div> <p><code>writeTransactionData</code>函数如下：</p> <div class=highlight><pre><span></span><code><span class=c1>// cmd为BC_TRANSACTION</span>
<span class=n>status_t</span> <span class=n>IPCThreadState</span><span class=o>::</span><span class=n>writeTransactionData</span><span class=p>(</span><span class=kt>int32_t</span> <span class=n>cmd</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>binderFlags</span><span class=p>,</span>
                                              <span class=kt>int32_t</span> <span class=n>handle</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>code</span><span class=p>,</span> <span class=k>const</span> <span class=n>Parcel</span><span class=o>&amp;</span> <span class=n>data</span><span class=p>,</span> <span class=n>status_t</span><span class=o>*</span> <span class=n>statusBuffer</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>binder_transaction_data</span> <span class=n>tr</span><span class=p>;</span>

    <span class=n>tr</span><span class=p>.</span><span class=n>target</span><span class=p>.</span><span class=n>handle</span> <span class=o>=</span> <span class=n>handle</span><span class=p>;</span>
    <span class=n>tr</span><span class=p>.</span><span class=n>code</span> <span class=o>=</span> <span class=n>code</span><span class=p>;</span>
    <span class=n>tr</span><span class=p>.</span><span class=n>flags</span> <span class=o>=</span> <span class=n>binderFlags</span><span class=p>;</span>

    <span class=k>const</span> <span class=n>status_t</span> <span class=n>err</span> <span class=o>=</span> <span class=n>data</span><span class=p>.</span><span class=n>errorCheck</span><span class=p>();</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>err</span> <span class=o>==</span> <span class=n>NO_ERROR</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>// 来初始化本地变量tr</span>
        <span class=n>tr</span><span class=p>.</span><span class=n>data_size</span> <span class=o>=</span> <span class=n>data</span><span class=p>.</span><span class=n>ipcDataSize</span><span class=p>();</span>
        <span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>buffer</span> <span class=o>=</span> <span class=n>data</span><span class=p>.</span><span class=n>ipcData</span><span class=p>();</span>
        <span class=n>tr</span><span class=p>.</span><span class=n>offsets_size</span> <span class=o>=</span> <span class=n>data</span><span class=p>.</span><span class=n>ipcObjectsCount</span><span class=p>()</span><span class=o>*</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>size_t</span><span class=p>);</span>
        <span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>offsets</span> <span class=o>=</span> <span class=n>data</span><span class=p>.</span><span class=n>ipcObjects</span><span class=p>();</span>
    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>statusBuffer</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>tr</span><span class=p>.</span><span class=n>flags</span> <span class=o>|=</span> <span class=n>TF_STATUS_CODE</span><span class=p>;</span>
        <span class=o>*</span><span class=n>statusBuffer</span> <span class=o>=</span> <span class=n>err</span><span class=p>;</span>
        <span class=n>tr</span><span class=p>.</span><span class=n>data_size</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>status_t</span><span class=p>);</span>
        <span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>buffer</span> <span class=o>=</span> <span class=n>statusBuffer</span><span class=p>;</span>
        <span class=n>tr</span><span class=p>.</span><span class=n>offsets_size</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
        <span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>offsets</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=k>return</span> <span class=p>(</span><span class=n>mLastError</span> <span class=o>=</span> <span class=n>err</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=c1>// 将tr的内容保存在IPCThreadState的成员变量mOut中</span>
    <span class=n>mOut</span><span class=p>.</span><span class=n>writeInt32</span><span class=p>(</span><span class=n>cmd</span><span class=p>);</span>
    <span class=n>mOut</span><span class=p>.</span><span class=n>write</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tr</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>tr</span><span class=p>));</span>

    <span class=k>return</span> <span class=n>NO_ERROR</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p><code>tr.data.ptr.buffer</code>里面的内容相当于：</p> <div class=highlight><pre><span></span><code><span class=n>writeInt32</span><span class=p>(</span><span class=n>IPCThreadState</span><span class=o>::</span><span class=n>self</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>getStrictModePolicy</span><span class=p>()</span> <span class=o>|</span>
               <span class=n>STRICT_MODE_PENALTY_GATHER</span><span class=p>);</span>
<span class=n>writeString16</span><span class=p>(</span><span class=s>&quot;android.os.IServiceManager&quot;</span><span class=p>);</span>
<span class=n>writeString16</span><span class=p>(</span><span class=s>&quot;media.player&quot;</span><span class=p>);</span>
<span class=n>writeStrongBinder</span><span class=p>(</span><span class=n>new</span> <span class=n>MediaPlayerService</span><span class=p>());</span>
</code></pre></div> <p>其中包含了一个Binder实体MediaPlayerService，因此需要设置tr.offsets_size就为1，tr.data.ptr.offsets就指向了这个MediaPlayerService的地址在tr.data.ptr.buffer中的偏移量。</p> <p>回到<code>IPCThreadState::transact</code>函数中，接下去看，<code>(flags &amp; TF_ONE_WAY) == 0</code>为true，并且reply不为空，所以最终进入到<code>waitForResponse(reply)</code>这条路径来。<code>waitForResponse</code>函数里面主要调用了<code>talkWithDriver</code>来和Binder驱动程序进行交互。 </p> <div class=highlight><pre><span></span><code><span class=c1>// doReceive默认值为true</span>
<span class=n>status_t</span> <span class=n>IPCThreadState</span><span class=o>::</span><span class=n>talkWithDriver</span><span class=p>(</span><span class=kt>bool</span> <span class=n>doReceive</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>LOG_ASSERT</span><span class=p>(</span><span class=n>mProcess</span><span class=o>-&gt;</span><span class=n>mDriverFD</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>,</span> <span class=s>&quot;Binder driver is not opened&quot;</span><span class=p>);</span>

    <span class=n>binder_write_read</span> <span class=n>bwr</span><span class=p>;</span>

    <span class=c1>// Is the read buffer empty?</span>
    <span class=c1>// 显然needRead也为true</span>
    <span class=k>const</span> <span class=kt>bool</span> <span class=n>needRead</span> <span class=o>=</span> <span class=n>mIn</span><span class=p>.</span><span class=n>dataPosition</span><span class=p>()</span> <span class=o>&gt;=</span> <span class=n>mIn</span><span class=p>.</span><span class=n>dataSize</span><span class=p>();</span>

    <span class=c1>// We don&#39;t want to write anything if we are still reading</span>
    <span class=c1>// from data left in the input buffer and the caller</span>
    <span class=c1>// has requested to read the next data.</span>
    <span class=k>const</span> <span class=kt>size_t</span> <span class=n>outAvail</span> <span class=o>=</span> <span class=p>(</span><span class=o>!</span><span class=n>doReceive</span> <span class=o>||</span> <span class=n>needRead</span><span class=p>)</span> <span class=o>?</span> <span class=n>mOut</span><span class=p>.</span><span class=n>dataSize</span><span class=p>()</span> <span class=o>:</span> <span class=mi>0</span><span class=p>;</span>

    <span class=c1>// 设置bwr的write值，Binder驱动程序会进行write操作</span>
    <span class=n>bwr</span><span class=p>.</span><span class=n>write_size</span> <span class=o>=</span> <span class=n>outAvail</span><span class=p>;</span>
    <span class=n>bwr</span><span class=p>.</span><span class=n>write_buffer</span> <span class=o>=</span> <span class=p>(</span><span class=kt>long</span> <span class=kt>unsigned</span> <span class=kt>int</span><span class=p>)</span><span class=n>mOut</span><span class=p>.</span><span class=n>data</span><span class=p>();</span>

    <span class=c1>// This is what we&#39;ll read.</span>
    <span class=c1>// doReceive和needRead都为true，因此设置了bwr的read相关值</span>
    <span class=c1>// 这样Binder驱动程序就会进行read操作了</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>doReceive</span> <span class=o>&amp;&amp;</span> <span class=n>needRead</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>bwr</span><span class=p>.</span><span class=n>read_size</span> <span class=o>=</span> <span class=n>mIn</span><span class=p>.</span><span class=n>dataCapacity</span><span class=p>();</span>
        <span class=n>bwr</span><span class=p>.</span><span class=n>read_buffer</span> <span class=o>=</span> <span class=p>(</span><span class=kt>long</span> <span class=kt>unsigned</span> <span class=kt>int</span><span class=p>)</span><span class=n>mIn</span><span class=p>.</span><span class=n>data</span><span class=p>();</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=n>bwr</span><span class=p>.</span><span class=n>read_size</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=n>IF_LOG_COMMANDS</span><span class=p>()</span> <span class=p>{</span>
        <span class=n>TextOutput</span><span class=o>::</span><span class=n>Bundle</span> <span class=n>_b</span><span class=p>(</span><span class=n>alog</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>outAvail</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>alog</span> <span class=o>&lt;&lt;</span> <span class=s>&quot;Sending commands to driver: &quot;</span> <span class=o>&lt;&lt;</span> <span class=n>indent</span><span class=p>;</span>
            <span class=k>const</span> <span class=kt>void</span><span class=o>*</span> <span class=n>cmds</span> <span class=o>=</span> <span class=p>(</span><span class=k>const</span> <span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>bwr</span><span class=p>.</span><span class=n>write_buffer</span><span class=p>;</span>
            <span class=k>const</span> <span class=kt>void</span><span class=o>*</span> <span class=n>end</span> <span class=o>=</span> <span class=p>((</span><span class=k>const</span> <span class=kt>uint8_t</span><span class=o>*</span><span class=p>)</span><span class=n>cmds</span><span class=p>)</span><span class=o>+</span><span class=n>bwr</span><span class=p>.</span><span class=n>write_size</span><span class=p>;</span>
            <span class=n>alog</span> <span class=o>&lt;&lt;</span> <span class=n>HexDump</span><span class=p>(</span><span class=n>cmds</span><span class=p>,</span> <span class=n>bwr</span><span class=p>.</span><span class=n>write_size</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
            <span class=k>while</span> <span class=p>(</span><span class=n>cmds</span> <span class=o>&lt;</span> <span class=n>end</span><span class=p>)</span> <span class=n>cmds</span> <span class=o>=</span> <span class=n>printCommand</span><span class=p>(</span><span class=n>alog</span><span class=p>,</span> <span class=n>cmds</span><span class=p>);</span>
            <span class=n>alog</span> <span class=o>&lt;&lt;</span> <span class=n>dedent</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=n>alog</span> <span class=o>&lt;&lt;</span> <span class=s>&quot;Size of receive buffer: &quot;</span> <span class=o>&lt;&lt;</span> <span class=n>bwr</span><span class=p>.</span><span class=n>read_size</span>
        <span class=o>&lt;&lt;</span> <span class=s>&quot;, needRead: &quot;</span> <span class=o>&lt;&lt;</span> <span class=n>needRead</span> <span class=o>&lt;&lt;</span> <span class=s>&quot;, doReceive: &quot;</span> <span class=o>&lt;&lt;</span> <span class=n>doReceive</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=c1>// Return immediately if there is nothing to do.</span>
    <span class=k>if</span> <span class=p>((</span><span class=n>bwr</span><span class=p>.</span><span class=n>write_size</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>bwr</span><span class=p>.</span><span class=n>read_size</span> <span class=o>==</span> <span class=mi>0</span><span class=p>))</span> <span class=k>return</span> <span class=n>NO_ERROR</span><span class=p>;</span>

    <span class=n>bwr</span><span class=p>.</span><span class=n>write_consumed</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>bwr</span><span class=p>.</span><span class=n>read_consumed</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>status_t</span> <span class=n>err</span><span class=p>;</span>
    <span class=k>do</span> <span class=p>{</span>
        <span class=n>IF_LOG_COMMANDS</span><span class=p>()</span> <span class=p>{</span>
            <span class=n>alog</span> <span class=o>&lt;&lt;</span> <span class=s>&quot;About to read/write, write size = &quot;</span> <span class=o>&lt;&lt;</span> <span class=n>mOut</span><span class=p>.</span><span class=n>dataSize</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
        <span class=p>}</span>
<span class=cp>#if defined(HAVE_ANDROID_OS)</span>
        <span class=c1>// 让Binder驱动程序进行BINDER_WRITE_READ操作</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>ioctl</span><span class=p>(</span><span class=n>mProcess</span><span class=o>-&gt;</span><span class=n>mDriverFD</span><span class=p>,</span> <span class=n>BINDER_WRITE_READ</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>bwr</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>)</span>
            <span class=n>err</span> <span class=o>=</span> <span class=n>NO_ERROR</span><span class=p>;</span>
        <span class=k>else</span>
            <span class=n>err</span> <span class=o>=</span> <span class=o>-</span><span class=n>errno</span><span class=p>;</span>
<span class=cp>#else</span>
        <span class=n>err</span> <span class=o>=</span> <span class=n>INVALID_OPERATION</span><span class=p>;</span>
<span class=cp>#endif</span>
        <span class=n>IF_LOG_COMMANDS</span><span class=p>()</span> <span class=p>{</span>
            <span class=n>alog</span> <span class=o>&lt;&lt;</span> <span class=s>&quot;Finished read/write, write size = &quot;</span> <span class=o>&lt;&lt;</span> <span class=n>mOut</span><span class=p>.</span><span class=n>dataSize</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=n>err</span> <span class=o>==</span> <span class=o>-</span><span class=n>EINTR</span><span class=p>);</span>

    <span class=n>IF_LOG_COMMANDS</span><span class=p>()</span> <span class=p>{</span>
        <span class=n>alog</span> <span class=o>&lt;&lt;</span> <span class=s>&quot;Our err: &quot;</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>err</span> <span class=o>&lt;&lt;</span> <span class=s>&quot;, write consumed: &quot;</span>
        <span class=o>&lt;&lt;</span> <span class=n>bwr</span><span class=p>.</span><span class=n>write_consumed</span> <span class=o>&lt;&lt;</span> <span class=s>&quot; (of &quot;</span> <span class=o>&lt;&lt;</span> <span class=n>mOut</span><span class=p>.</span><span class=n>dataSize</span><span class=p>()</span>
        <span class=o>&lt;&lt;</span> <span class=s>&quot;), read consumed: &quot;</span> <span class=o>&lt;&lt;</span> <span class=n>bwr</span><span class=p>.</span><span class=n>read_consumed</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=c1>// Binder驱动程序执行完了BINDER_WRITE_READ操作</span>
    <span class=c1>// 根据读写情况进行清除操作</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>err</span> <span class=o>&gt;=</span> <span class=n>NO_ERROR</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>bwr</span><span class=p>.</span><span class=n>write_consumed</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>bwr</span><span class=p>.</span><span class=n>write_consumed</span> <span class=o>&lt;</span> <span class=p>(</span><span class=kt>ssize_t</span><span class=p>)</span><span class=n>mOut</span><span class=p>.</span><span class=n>dataSize</span><span class=p>())</span>
                <span class=n>mOut</span><span class=p>.</span><span class=n>remove</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>bwr</span><span class=p>.</span><span class=n>write_consumed</span><span class=p>);</span>
            <span class=k>else</span>
                <span class=n>mOut</span><span class=p>.</span><span class=n>setDataSize</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
        <span class=p>}</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>bwr</span><span class=p>.</span><span class=n>read_consumed</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>mIn</span><span class=p>.</span><span class=n>setDataSize</span><span class=p>(</span><span class=n>bwr</span><span class=p>.</span><span class=n>read_consumed</span><span class=p>);</span>
            <span class=n>mIn</span><span class=p>.</span><span class=n>setDataPosition</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
        <span class=p>}</span>
        <span class=n>IF_LOG_COMMANDS</span><span class=p>()</span> <span class=p>{</span>
            <span class=n>TextOutput</span><span class=o>::</span><span class=n>Bundle</span> <span class=n>_b</span><span class=p>(</span><span class=n>alog</span><span class=p>);</span>
            <span class=n>alog</span> <span class=o>&lt;&lt;</span> <span class=s>&quot;Remaining data size: &quot;</span> <span class=o>&lt;&lt;</span> <span class=n>mOut</span><span class=p>.</span><span class=n>dataSize</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
            <span class=n>alog</span> <span class=o>&lt;&lt;</span> <span class=s>&quot;Received commands from driver: &quot;</span> <span class=o>&lt;&lt;</span> <span class=n>indent</span><span class=p>;</span>
            <span class=k>const</span> <span class=kt>void</span><span class=o>*</span> <span class=n>cmds</span> <span class=o>=</span> <span class=n>mIn</span><span class=p>.</span><span class=n>data</span><span class=p>();</span>
            <span class=k>const</span> <span class=kt>void</span><span class=o>*</span> <span class=n>end</span> <span class=o>=</span> <span class=n>mIn</span><span class=p>.</span><span class=n>data</span><span class=p>()</span> <span class=o>+</span> <span class=n>mIn</span><span class=p>.</span><span class=n>dataSize</span><span class=p>();</span>
            <span class=n>alog</span> <span class=o>&lt;&lt;</span> <span class=n>HexDump</span><span class=p>(</span><span class=n>cmds</span><span class=p>,</span> <span class=n>mIn</span><span class=p>.</span><span class=n>dataSize</span><span class=p>())</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
            <span class=k>while</span> <span class=p>(</span><span class=n>cmds</span> <span class=o>&lt;</span> <span class=n>end</span><span class=p>)</span> <span class=n>cmds</span> <span class=o>=</span> <span class=n>printReturnCommand</span><span class=p>(</span><span class=n>alog</span><span class=p>,</span> <span class=n>cmds</span><span class=p>);</span>
            <span class=n>alog</span> <span class=o>&lt;&lt;</span> <span class=n>dedent</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=k>return</span> <span class=n>NO_ERROR</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>err</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>这里doReceive和needRead均为1，因此，这里告诉Binder驱动程序，先执行write操作，再执行read操作，下面我们将会看到。 </p> <p>最后，通过<code>ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr)</code>进行到Binder驱动程序的binder_ioctl函数，BINDER_WRITE_READ部分代码在2.2节中出现过，这里不在累述。</p> <p><code>binder_ioctl</code>函数首先是将用户传进来的参数拷贝到本地变量<code>struct binder_write_read bwr</code>中去。这里<code>bwr.write_size &gt; 0</code>为true，因此，进入到binder_thread_write函数中，我们只关注BC_TRANSACTION部分的逻辑：</p> <div class=highlight><pre><span></span><code><span class=kt>int</span>
<span class=nf>binder_thread_write</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_proc</span> <span class=o>*</span><span class=n>proc</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>binder_thread</span> <span class=o>*</span><span class=kr>thread</span><span class=p>,</span>
            <span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=n>buffer</span><span class=p>,</span> <span class=kt>int</span> <span class=n>size</span><span class=p>,</span> <span class=kt>signed</span> <span class=kt>long</span> <span class=o>*</span><span class=n>consumed</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>uint32_t</span> <span class=n>cmd</span><span class=p>;</span>
    <span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=n>ptr</span> <span class=o>=</span> <span class=n>buffer</span> <span class=o>+</span> <span class=o>*</span><span class=n>consumed</span><span class=p>;</span>
    <span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=n>end</span> <span class=o>=</span> <span class=n>buffer</span> <span class=o>+</span> <span class=n>size</span><span class=p>;</span>

    <span class=k>while</span> <span class=p>(</span><span class=n>ptr</span> <span class=o>&lt;</span> <span class=n>end</span> <span class=o>&amp;&amp;</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>return_error</span> <span class=o>==</span> <span class=n>BR_OK</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>get_user</span><span class=p>(</span><span class=n>cmd</span><span class=p>,</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>__user</span> <span class=o>*</span><span class=p>)</span><span class=n>ptr</span><span class=p>))</span>
            <span class=k>return</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
        <span class=n>ptr</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>_IOC_NR</span><span class=p>(</span><span class=n>cmd</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>ARRAY_SIZE</span><span class=p>(</span><span class=n>binder_stats</span><span class=p>.</span><span class=n>bc</span><span class=p>))</span> <span class=p>{</span>
            <span class=n>binder_stats</span><span class=p>.</span><span class=n>bc</span><span class=p>[</span><span class=n>_IOC_NR</span><span class=p>(</span><span class=n>cmd</span><span class=p>)]</span><span class=o>++</span><span class=p>;</span>
            <span class=n>proc</span><span class=o>-&gt;</span><span class=n>stats</span><span class=p>.</span><span class=n>bc</span><span class=p>[</span><span class=n>_IOC_NR</span><span class=p>(</span><span class=n>cmd</span><span class=p>)]</span><span class=o>++</span><span class=p>;</span>
            <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>stats</span><span class=p>.</span><span class=n>bc</span><span class=p>[</span><span class=n>_IOC_NR</span><span class=p>(</span><span class=n>cmd</span><span class=p>)]</span><span class=o>++</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=k>switch</span> <span class=p>(</span><span class=n>cmd</span><span class=p>)</span> <span class=p>{</span>
        <span class=p>...</span>
        <span class=k>case</span> <span class=nl>BC_TRANSACTION</span><span class=p>:</span>
        <span class=k>case</span> <span class=nl>BC_REPLY</span><span class=p>:</span> <span class=p>{</span>
            <span class=k>struct</span> <span class=nc>binder_transaction_data</span> <span class=n>tr</span><span class=p>;</span>
            <span class=c1>// 将参数拷贝在本地变量tr中</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>copy_from_user</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tr</span><span class=p>,</span> <span class=n>ptr</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>tr</span><span class=p>)))</span>
                <span class=k>return</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
            <span class=n>ptr</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>tr</span><span class=p>);</span>
            <span class=c1>// 调用此函数进一步处理</span>
            <span class=n>binder_transaction</span><span class=p>(</span><span class=n>proc</span><span class=p>,</span> <span class=kr>thread</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>tr</span><span class=p>,</span> <span class=n>cmd</span> <span class=o>==</span> <span class=n>BC_REPLY</span><span class=p>);</span>
            <span class=k>break</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=p>...</span>
        <span class=k>default</span><span class=o>:</span>
            <span class=n>printk</span><span class=p>(</span><span class=n>KERN_ERR</span> <span class=s>&quot;binder: %d:%d unknown command %d</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span> <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=n>cmd</span><span class=p>);</span>
            <span class=k>return</span> <span class=o>-</span><span class=n>EINVAL</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=o>*</span><span class=n>consumed</span> <span class=o>=</span> <span class=n>ptr</span> <span class=o>-</span> <span class=n>buffer</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>首先将用户传进来的参数（主要是<code>bwr.write_buffer</code>）拷贝在本地变量<code>struct binder_transaction_data tr</code>中去，接着调用<code>binder_transaction</code>函数进一步处理：</p> <div class=highlight><pre><span></span><code><span class=k>static</span> <span class=kt>void</span>
<span class=n>binder_transaction</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_proc</span> <span class=o>*</span><span class=n>proc</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>binder_thread</span> <span class=o>*</span><span class=kr>thread</span><span class=p>,</span>
<span class=k>struct</span> <span class=nc>binder_transaction_data</span> <span class=o>*</span><span class=n>tr</span><span class=p>,</span> <span class=kt>int</span> <span class=n>reply</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>struct</span> <span class=nc>binder_transaction</span> <span class=o>*</span><span class=n>t</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>binder_work</span> <span class=o>*</span><span class=n>tcomplete</span><span class=p>;</span>
    <span class=kt>size_t</span> <span class=o>*</span><span class=n>offp</span><span class=p>,</span> <span class=o>*</span><span class=n>off_end</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>binder_proc</span> <span class=o>*</span><span class=n>target_proc</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>binder_thread</span> <span class=o>*</span><span class=n>target_thread</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>binder_node</span> <span class=o>*</span><span class=n>target_node</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>list_head</span> <span class=o>*</span><span class=n>target_list</span><span class=p>;</span>
    <span class=n>wait_queue_head_t</span> <span class=o>*</span><span class=n>target_wait</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>binder_transaction</span> <span class=o>*</span><span class=n>in_reply_to</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>binder_transaction_log_entry</span> <span class=o>*</span><span class=n>e</span><span class=p>;</span>
    <span class=kt>uint32_t</span> <span class=n>return_error</span><span class=p>;</span>

    <span class=p>......</span>
    <span class=c1>// reply为0，因为cmd=BC_TRANSACTION，不等于BC_REPLY</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>reply</span><span class=p>)</span> <span class=p>{</span>
        <span class=p>......</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=c1>// tr-&gt;target.handle也为0</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>tr</span><span class=o>-&gt;</span><span class=n>target</span><span class=p>.</span><span class=n>handle</span><span class=p>)</span> <span class=p>{</span>
            <span class=p>......</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=c1>// 初始化</span>
            <span class=n>target_node</span> <span class=o>=</span> <span class=n>binder_context_mgr_node</span><span class=p>;</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>target_node</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
                <span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_DEAD_REPLY</span><span class=p>;</span>
                <span class=k>goto</span> <span class=n>err_no_context_mgr_node</span><span class=p>;</span>
            <span class=p>}</span>
        <span class=p>}</span>
        <span class=p>......</span>
        <span class=c1>// 初始化</span>
        <span class=n>target_proc</span> <span class=o>=</span> <span class=n>target_node</span><span class=o>-&gt;</span><span class=n>proc</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>target_proc</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_DEAD_REPLY</span><span class=p>;</span>
            <span class=k>goto</span> <span class=n>err_dead_binder</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=p>......</span>
    <span class=p>}</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>target_thread</span><span class=p>)</span> <span class=p>{</span>
        <span class=p>......</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=c1>// 初始化</span>
        <span class=n>target_list</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>target_proc</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>;</span>
        <span class=n>target_wait</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>target_proc</span><span class=o>-&gt;</span><span class=n>wait</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=p>......</span>
    <span class=c1>// 分配了一个待处理事务t和一个待完成工作项tcomplete，并执行初始化工作</span>
    <span class=cm>/* TODO: reuse incoming transaction for reply */</span>
    <span class=n>t</span> <span class=o>=</span> <span class=n>kzalloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=n>t</span><span class=p>),</span> <span class=n>GFP_KERNEL</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>t</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_FAILED_REPLY</span><span class=p>;</span>
        <span class=k>goto</span> <span class=n>err_alloc_t_failed</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=p>......</span>

    <span class=n>tcomplete</span> <span class=o>=</span> <span class=n>kzalloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=n>tcomplete</span><span class=p>),</span> <span class=n>GFP_KERNEL</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>tcomplete</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_FAILED_REPLY</span><span class=p>;</span>
        <span class=k>goto</span> <span class=n>err_alloc_tcomplete_failed</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=p>......</span>

    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>reply</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=p>(</span><span class=n>tr</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>TF_ONE_WAY</span><span class=p>))</span>
        <span class=n>t</span><span class=o>-&gt;</span><span class=n>from</span> <span class=o>=</span> <span class=kr>thread</span><span class=p>;</span>
    <span class=k>else</span>
        <span class=n>t</span><span class=o>-&gt;</span><span class=n>from</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>sender_euid</span> <span class=o>=</span> <span class=n>proc</span><span class=o>-&gt;</span><span class=n>tsk</span><span class=o>-&gt;</span><span class=n>cred</span><span class=o>-&gt;</span><span class=n>euid</span><span class=p>;</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>to_proc</span> <span class=o>=</span> <span class=n>target_proc</span><span class=p>;</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>to_thread</span> <span class=o>=</span> <span class=n>target_thread</span><span class=p>;</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>code</span> <span class=o>=</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>code</span><span class=p>;</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>=</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>flags</span><span class=p>;</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>priority</span> <span class=o>=</span> <span class=n>task_nice</span><span class=p>(</span><span class=n>current</span><span class=p>);</span>
    <span class=c1>// 在Service Manager的进程空间中分配一块内存保存用户传入的参数</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span> <span class=o>=</span> <span class=n>binder_alloc_buf</span><span class=p>(</span><span class=n>target_proc</span><span class=p>,</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>data_size</span><span class=p>,</span>
        <span class=n>tr</span><span class=o>-&gt;</span><span class=n>offsets_size</span><span class=p>,</span> <span class=o>!</span><span class=n>reply</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>TF_ONE_WAY</span><span class=p>));</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_FAILED_REPLY</span><span class=p>;</span>
        <span class=k>goto</span> <span class=n>err_binder_alloc_buf_failed</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>allow_user_free</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>debug_id</span> <span class=o>=</span> <span class=n>t</span><span class=o>-&gt;</span><span class=n>debug_id</span><span class=p>;</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>transaction</span> <span class=o>=</span> <span class=n>t</span><span class=p>;</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>target_node</span> <span class=o>=</span> <span class=n>target_node</span><span class=p>;</span>
    <span class=c1>// 由于现在target_node要被使用了，增加它的引用计数</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>target_node</span><span class=p>)</span>
        <span class=n>binder_inc_node</span><span class=p>(</span><span class=n>target_node</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>

    <span class=n>offp</span> <span class=o>=</span> <span class=p>(</span><span class=kt>size_t</span> <span class=o>*</span><span class=p>)(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>+</span> <span class=n>ALIGN</span><span class=p>(</span><span class=n>tr</span><span class=o>-&gt;</span><span class=n>data_size</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)));</span>
    <span class=c1>// 保存参数到Service Manager的进程空间中</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>copy_from_user</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>,</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>buffer</span><span class=p>,</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>data_size</span><span class=p>))</span> <span class=p>{</span>
        <span class=p>......</span>
        <span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_FAILED_REPLY</span><span class=p>;</span>
        <span class=k>goto</span> <span class=n>err_copy_data_failed</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>copy_from_user</span><span class=p>(</span><span class=n>offp</span><span class=p>,</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>offsets</span><span class=p>,</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>offsets_size</span><span class=p>))</span> <span class=p>{</span>
        <span class=p>......</span>
        <span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_FAILED_REPLY</span><span class=p>;</span>
        <span class=k>goto</span> <span class=n>err_copy_data_failed</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=p>......</span>

    <span class=c1>// 用来处理传输数据中的Binder对象了</span>
    <span class=c1>// 此处type为BINDER_TYPE_BINDER类型</span>
    <span class=n>off_end</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>offp</span> <span class=o>+</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>offsets_size</span><span class=p>;</span>
    <span class=k>for</span> <span class=p>(;</span> <span class=n>offp</span> <span class=o>&lt;</span> <span class=n>off_end</span><span class=p>;</span> <span class=n>offp</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>struct</span> <span class=nc>flat_binder_object</span> <span class=o>*</span><span class=n>fp</span><span class=p>;</span>
        <span class=p>......</span>
        <span class=n>fp</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=nc>flat_binder_object</span> <span class=o>*</span><span class=p>)(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>+</span> <span class=o>*</span><span class=n>offp</span><span class=p>);</span>
        <span class=k>switch</span> <span class=p>(</span><span class=n>fp</span><span class=o>-&gt;</span><span class=n>type</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>case</span> <span class=nl>BINDER_TYPE_BINDER</span><span class=p>:</span>
        <span class=k>case</span> <span class=nl>BINDER_TYPE_WEAK_BINDER</span><span class=p>:</span> <span class=p>{</span>
            <span class=k>struct</span> <span class=nc>binder_ref</span> <span class=o>*</span><span class=n>ref</span><span class=p>;</span>
            <span class=c1>// 由于是第一次在Binder驱动程序中传输这个MediaPlayerService，</span>
            <span class=c1>// 调用binder_get_node函数查询这个Binder实体时，会返回空</span>
            <span class=c1>// 于是binder_new_node在proc中新建一个，下次就可以直接使用了。</span>
            <span class=k>struct</span> <span class=nc>binder_node</span> <span class=o>*</span><span class=n>node</span> <span class=o>=</span> <span class=n>binder_get_node</span><span class=p>(</span><span class=n>proc</span><span class=p>,</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>binder</span><span class=p>);</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>node</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
                <span class=n>node</span> <span class=o>=</span> <span class=n>binder_new_node</span><span class=p>(</span><span class=n>proc</span><span class=p>,</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>binder</span><span class=p>,</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>cookie</span><span class=p>);</span>
                <span class=k>if</span> <span class=p>(</span><span class=n>node</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
                    <span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_FAILED_REPLY</span><span class=p>;</span>
                    <span class=k>goto</span> <span class=n>err_binder_new_node_failed</span><span class=p>;</span>
                <span class=p>}</span>
                <span class=n>node</span><span class=o>-&gt;</span><span class=n>min_priority</span> <span class=o>=</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>FLAT_BINDER_FLAG_PRIORITY_MASK</span><span class=p>;</span>
                <span class=n>node</span><span class=o>-&gt;</span><span class=n>accept_fds</span> <span class=o>=</span> <span class=o>!!</span><span class=p>(</span><span class=n>fp</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>FLAT_BINDER_FLAG_ACCEPTS_FDS</span><span class=p>);</span>
            <span class=p>}</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>fp</span><span class=o>-&gt;</span><span class=n>cookie</span> <span class=o>!=</span> <span class=n>node</span><span class=o>-&gt;</span><span class=n>cookie</span><span class=p>)</span> <span class=p>{</span>
                <span class=p>......</span>
                <span class=k>goto</span> <span class=n>err_binder_get_ref_for_node_failed</span><span class=p>;</span>
            <span class=p>}</span>
            <span class=c1>// 为MediaPlayerService创建一个引用</span>
            <span class=n>ref</span> <span class=o>=</span> <span class=n>binder_get_ref_for_node</span><span class=p>(</span><span class=n>target_proc</span><span class=p>,</span> <span class=n>node</span><span class=p>);</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>ref</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
                <span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_FAILED_REPLY</span><span class=p>;</span>
                <span class=k>goto</span> <span class=n>err_binder_get_ref_for_node_failed</span><span class=p>;</span>
            <span class=p>}</span>
            <span class=c1>// 注意此时type变成了xxx_HANDLE，handle改为了ref-&gt;desc</span>
            <span class=c1>// 因为fp最终要传给Service Manager，而SM只能通过句柄值来引用这个Binder实体</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>fp</span><span class=o>-&gt;</span><span class=n>type</span> <span class=o>==</span> <span class=n>BINDER_TYPE_BINDER</span><span class=p>)</span>
                <span class=n>fp</span><span class=o>-&gt;</span><span class=n>type</span> <span class=o>=</span> <span class=n>BINDER_TYPE_HANDLE</span><span class=p>;</span>
            <span class=k>else</span>
                <span class=n>fp</span><span class=o>-&gt;</span><span class=n>type</span> <span class=o>=</span> <span class=n>BINDER_TYPE_WEAK_HANDLE</span><span class=p>;</span>
            <span class=n>fp</span><span class=o>-&gt;</span><span class=n>handle</span> <span class=o>=</span> <span class=n>ref</span><span class=o>-&gt;</span><span class=n>desc</span><span class=p>;</span>
            <span class=c1>// 通过此方法增加引用计数，防止这个引用还在使用过程当中就被销毁</span>
            <span class=n>binder_inc_ref</span><span class=p>(</span><span class=n>ref</span><span class=p>,</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>type</span> <span class=o>==</span> <span class=n>BINDER_TYPE_HANDLE</span><span class=p>,</span> <span class=o>&amp;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>);</span>
            <span class=p>......</span>

        <span class=p>}</span> <span class=k>break</span><span class=p>;</span>
        <span class=p>......</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>reply</span><span class=p>)</span> <span class=p>{</span>
        <span class=p>......</span>
    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>TF_ONE_WAY</span><span class=p>))</span> <span class=p>{</span>
        <span class=n>BUG_ON</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>async_transaction</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>);</span>
        <span class=c1>// 这些值后面会用到</span>
        <span class=n>t</span><span class=o>-&gt;</span><span class=n>need_reply</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
        <span class=n>t</span><span class=o>-&gt;</span><span class=n>from_parent</span> <span class=o>=</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>transaction_stack</span><span class=p>;</span>
        <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>transaction_stack</span> <span class=o>=</span> <span class=n>t</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=p>......</span>
    <span class=p>}</span>
    <span class=c1>// 待处理事务加入到target_list列表中去</span>
    <span class=c1>// 然后把待完成工作项加入到本线程的todo等待执行列表之中</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>work</span><span class=p>.</span><span class=n>type</span> <span class=o>=</span> <span class=n>BINDER_WORK_TRANSACTION</span><span class=p>;</span>
    <span class=n>list_add_tail</span><span class=p>(</span><span class=o>&amp;</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>work</span><span class=p>.</span><span class=n>entry</span><span class=p>,</span> <span class=n>target_list</span><span class=p>);</span>
    <span class=n>tcomplete</span><span class=o>-&gt;</span><span class=n>type</span> <span class=o>=</span> <span class=n>BINDER_WORK_TRANSACTION_COMPLETE</span><span class=p>;</span>
    <span class=n>list_add_tail</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tcomplete</span><span class=o>-&gt;</span><span class=n>entry</span><span class=p>,</span> <span class=o>&amp;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>);</span>
    <span class=c1>// 目标进程有待处理任务了，于是唤醒它</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>target_wait</span><span class=p>)</span>
        <span class=n>wake_up_interruptible</span><span class=p>(</span><span class=n>target_wait</span><span class=p>);</span>
    <span class=k>return</span><span class=p>;</span>
    <span class=p>......</span>
<span class=p>}</span>
</code></pre></div> <p>这里传进来的参数reply为0，tr-&gt;target.handle也为0。因此，target_proc、target_thread、target_node、target_list和target_wait的值分别为：</p> <div class=highlight><pre><span></span><code><span class=n>target_node</span> <span class=o>=</span> <span class=n>binder_context_mgr_node</span><span class=p>;</span>
<span class=n>target_proc</span> <span class=o>=</span> <span class=n>target_node</span><span class=o>-&gt;</span><span class=n>proc</span><span class=p>;</span>
<span class=n>target_list</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>target_proc</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>;</span>
<span class=n>target_wait</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>target_proc</span><span class=o>-&gt;</span><span class=n>wait</span><span class=p>;</span>
</code></pre></div> <p>接着，分配了一个待处理事务t和一个待完成工作项tcomplete，并执行初始化工作：</p> <div class=highlight><pre><span></span><code><span class=cm>/* TODO: reuse incoming transaction for reply */</span>
<span class=n>t</span> <span class=o>=</span> <span class=n>kzalloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=n>t</span><span class=p>),</span> <span class=n>GFP_KERNEL</span><span class=p>);</span>
<span class=k>if</span> <span class=p>(</span><span class=n>t</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_FAILED_REPLY</span><span class=p>;</span>
  <span class=k>goto</span> <span class=n>err_alloc_t_failed</span><span class=p>;</span>
<span class=p>}</span>
<span class=p>......</span>

<span class=n>tcomplete</span> <span class=o>=</span> <span class=n>kzalloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=n>tcomplete</span><span class=p>),</span> <span class=n>GFP_KERNEL</span><span class=p>);</span>
<span class=k>if</span> <span class=p>(</span><span class=n>tcomplete</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_FAILED_REPLY</span><span class=p>;</span>
  <span class=k>goto</span> <span class=n>err_alloc_tcomplete_failed</span><span class=p>;</span>
<span class=p>}</span>

<span class=p>......</span>

<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>reply</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=p>(</span><span class=n>tr</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>TF_ONE_WAY</span><span class=p>))</span>
  <span class=n>t</span><span class=o>-&gt;</span><span class=n>from</span> <span class=o>=</span> <span class=kr>thread</span><span class=p>;</span>
<span class=k>else</span>
  <span class=n>t</span><span class=o>-&gt;</span><span class=n>from</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
<span class=n>t</span><span class=o>-&gt;</span><span class=n>sender_euid</span> <span class=o>=</span> <span class=n>proc</span><span class=o>-&gt;</span><span class=n>tsk</span><span class=o>-&gt;</span><span class=n>cred</span><span class=o>-&gt;</span><span class=n>euid</span><span class=p>;</span>
<span class=n>t</span><span class=o>-&gt;</span><span class=n>to_proc</span> <span class=o>=</span> <span class=n>target_proc</span><span class=p>;</span>
<span class=n>t</span><span class=o>-&gt;</span><span class=n>to_thread</span> <span class=o>=</span> <span class=n>target_thread</span><span class=p>;</span>
<span class=n>t</span><span class=o>-&gt;</span><span class=n>code</span> <span class=o>=</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>code</span><span class=p>;</span>
<span class=n>t</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>=</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>flags</span><span class=p>;</span>
<span class=n>t</span><span class=o>-&gt;</span><span class=n>priority</span> <span class=o>=</span> <span class=n>task_nice</span><span class=p>(</span><span class=n>current</span><span class=p>);</span>
<span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span> <span class=o>=</span> <span class=n>binder_alloc_buf</span><span class=p>(</span><span class=n>target_proc</span><span class=p>,</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>data_size</span><span class=p>,</span>
  <span class=n>tr</span><span class=o>-&gt;</span><span class=n>offsets_size</span><span class=p>,</span> <span class=o>!</span><span class=n>reply</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>TF_ONE_WAY</span><span class=p>));</span>
<span class=k>if</span> <span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_FAILED_REPLY</span><span class=p>;</span>
  <span class=k>goto</span> <span class=n>err_binder_alloc_buf_failed</span><span class=p>;</span>
<span class=p>}</span>
<span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>allow_user_free</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
<span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>debug_id</span> <span class=o>=</span> <span class=n>t</span><span class=o>-&gt;</span><span class=n>debug_id</span><span class=p>;</span>
<span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>transaction</span> <span class=o>=</span> <span class=n>t</span><span class=p>;</span>
<span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>target_node</span> <span class=o>=</span> <span class=n>target_node</span><span class=p>;</span>
<span class=k>if</span> <span class=p>(</span><span class=n>target_node</span><span class=p>)</span>
  <span class=n>binder_inc_node</span><span class=p>(</span><span class=n>target_node</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>

<span class=n>offp</span> <span class=o>=</span> <span class=p>(</span><span class=kt>size_t</span> <span class=o>*</span><span class=p>)(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>+</span> <span class=n>ALIGN</span><span class=p>(</span><span class=n>tr</span><span class=o>-&gt;</span><span class=n>data_size</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)));</span>

<span class=k>if</span> <span class=p>(</span><span class=n>copy_from_user</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>,</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>buffer</span><span class=p>,</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>data_size</span><span class=p>))</span> <span class=p>{</span>
  <span class=p>......</span>
  <span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_FAILED_REPLY</span><span class=p>;</span>
  <span class=k>goto</span> <span class=n>err_copy_data_failed</span><span class=p>;</span>
<span class=p>}</span>
<span class=k>if</span> <span class=p>(</span><span class=n>copy_from_user</span><span class=p>(</span><span class=n>offp</span><span class=p>,</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>offsets</span><span class=p>,</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>offsets_size</span><span class=p>))</span> <span class=p>{</span>
  <span class=p>......</span>
  <span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_FAILED_REPLY</span><span class=p>;</span>
  <span class=k>goto</span> <span class=n>err_copy_data_failed</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>注意，这里的事务t是要交给target_proc处理的，在这个场景之下，就是Service Manager了。因此，下面的语句就是Service Manager的进程空间中分配一块内存来保存用户传进入的参数了。</p> <div class=highlight><pre><span></span><code><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span> <span class=o>=</span> <span class=n>binder_alloc_buf</span><span class=p>(</span><span class=n>target_proc</span><span class=p>,</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>data_size</span><span class=p>,</span>
  <span class=n>tr</span><span class=o>-&gt;</span><span class=n>offsets_size</span><span class=p>,</span> <span class=o>!</span><span class=n>reply</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>TF_ONE_WAY</span><span class=p>));</span>

<span class=k>if</span> <span class=p>(</span><span class=n>copy_from_user</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>,</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>buffer</span><span class=p>,</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>data_size</span><span class=p>))</span> <span class=p>{</span>
  <span class=p>......</span>
  <span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_FAILED_REPLY</span><span class=p>;</span>
  <span class=k>goto</span> <span class=n>err_copy_data_failed</span><span class=p>;</span>
<span class=p>}</span>
<span class=k>if</span> <span class=p>(</span><span class=n>copy_from_user</span><span class=p>(</span><span class=n>offp</span><span class=p>,</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>offsets</span><span class=p>,</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>offsets_size</span><span class=p>))</span> <span class=p>{</span>
  <span class=p>......</span>
  <span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_FAILED_REPLY</span><span class=p>;</span>
  <span class=k>goto</span> <span class=n>err_copy_data_failed</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>由于现在target_node要被使用了，增加它的引用计数：</p> <div class=highlight><pre><span></span><code><span class=k>if</span> <span class=p>(</span><span class=n>target_node</span><span class=p>)</span>
  <span class=n>binder_inc_node</span><span class=p>(</span><span class=n>target_node</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</code></pre></div> <p>接下去的for循环，就是用来处理传输数据中的Binder对象了。在我们的场景中，有一个类型为BINDER_TYPE_BINDER的Binder实体MediaPlayerService：</p> <div class=highlight><pre><span></span><code><span class=k>struct</span> <span class=nc>flat_binder_object</span> <span class=o>*</span><span class=n>fp</span><span class=p>;</span>
<span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=n>offp</span> <span class=o>&gt;</span> <span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>data_size</span> <span class=o>-</span> <span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=n>fp</span><span class=p>)</span> <span class=o>||</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>data_size</span> <span class=o>&lt;</span> <span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=n>fp</span><span class=p>)</span> <span class=o>||</span>
    <span class=o>!</span><span class=n>IS_ALIGNED</span><span class=p>(</span><span class=o>*</span><span class=n>offp</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)))</span> <span class=p>{</span>
  <span class=n>binder_user_error</span><span class=p>(</span><span class=s>&quot;binder: %d:%d got transaction with &quot;</span>
    <span class=s>&quot;invalid offset, %zd</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span>
    <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=o>*</span><span class=n>offp</span><span class=p>);</span>
  <span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_FAILED_REPLY</span><span class=p>;</span>
  <span class=k>goto</span> <span class=n>err_bad_offset</span><span class=p>;</span>
<span class=p>}</span>
<span class=n>fp</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=nc>flat_binder_object</span> <span class=o>*</span><span class=p>)(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>+</span> <span class=o>*</span><span class=n>offp</span><span class=p>);</span>
<span class=k>switch</span> <span class=p>(</span><span class=n>fp</span><span class=o>-&gt;</span><span class=n>type</span><span class=p>)</span> <span class=p>{</span>
<span class=k>case</span> <span class=nl>BINDER_TYPE_BINDER</span><span class=p>:</span>
<span class=k>case</span> <span class=nl>BINDER_TYPE_WEAK_BINDER</span><span class=p>:</span> <span class=p>{</span>
  <span class=k>struct</span> <span class=nc>binder_ref</span> <span class=o>*</span><span class=n>ref</span><span class=p>;</span>
  <span class=k>struct</span> <span class=nc>binder_node</span> <span class=o>*</span><span class=n>node</span> <span class=o>=</span> <span class=n>binder_get_node</span><span class=p>(</span><span class=n>proc</span><span class=p>,</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>binder</span><span class=p>);</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>node</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>node</span> <span class=o>=</span> <span class=n>binder_new_node</span><span class=p>(</span><span class=n>proc</span><span class=p>,</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>binder</span><span class=p>,</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>cookie</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>node</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_FAILED_REPLY</span><span class=p>;</span>
      <span class=k>goto</span> <span class=n>err_binder_new_node_failed</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>node</span><span class=o>-&gt;</span><span class=n>min_priority</span> <span class=o>=</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>FLAT_BINDER_FLAG_PRIORITY_MASK</span><span class=p>;</span>
    <span class=n>node</span><span class=o>-&gt;</span><span class=n>accept_fds</span> <span class=o>=</span> <span class=o>!!</span><span class=p>(</span><span class=n>fp</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>FLAT_BINDER_FLAG_ACCEPTS_FDS</span><span class=p>);</span>
  <span class=p>}</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>fp</span><span class=o>-&gt;</span><span class=n>cookie</span> <span class=o>!=</span> <span class=n>node</span><span class=o>-&gt;</span><span class=n>cookie</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>binder_user_error</span><span class=p>(</span><span class=s>&quot;binder: %d:%d sending u%p &quot;</span>
      <span class=s>&quot;node %d, cookie mismatch %p != %p</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span>
      <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span>
      <span class=n>fp</span><span class=o>-&gt;</span><span class=n>binder</span><span class=p>,</span> <span class=n>node</span><span class=o>-&gt;</span><span class=n>debug_id</span><span class=p>,</span>
      <span class=n>fp</span><span class=o>-&gt;</span><span class=n>cookie</span><span class=p>,</span> <span class=n>node</span><span class=o>-&gt;</span><span class=n>cookie</span><span class=p>);</span>
    <span class=k>goto</span> <span class=n>err_binder_get_ref_for_node_failed</span><span class=p>;</span>
  <span class=p>}</span>
  <span class=n>ref</span> <span class=o>=</span> <span class=n>binder_get_ref_for_node</span><span class=p>(</span><span class=n>target_proc</span><span class=p>,</span> <span class=n>node</span><span class=p>);</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>ref</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_FAILED_REPLY</span><span class=p>;</span>
    <span class=k>goto</span> <span class=n>err_binder_get_ref_for_node_failed</span><span class=p>;</span>
  <span class=p>}</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>fp</span><span class=o>-&gt;</span><span class=n>type</span> <span class=o>==</span> <span class=n>BINDER_TYPE_BINDER</span><span class=p>)</span>
    <span class=n>fp</span><span class=o>-&gt;</span><span class=n>type</span> <span class=o>=</span> <span class=n>BINDER_TYPE_HANDLE</span><span class=p>;</span>
  <span class=k>else</span>
    <span class=n>fp</span><span class=o>-&gt;</span><span class=n>type</span> <span class=o>=</span> <span class=n>BINDER_TYPE_WEAK_HANDLE</span><span class=p>;</span>
  <span class=n>fp</span><span class=o>-&gt;</span><span class=n>handle</span> <span class=o>=</span> <span class=n>ref</span><span class=o>-&gt;</span><span class=n>desc</span><span class=p>;</span>
  <span class=n>binder_inc_ref</span><span class=p>(</span><span class=n>ref</span><span class=p>,</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>type</span> <span class=o>==</span> <span class=n>BINDER_TYPE_HANDLE</span><span class=p>,</span> <span class=o>&amp;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>);</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>binder_debug_mask</span> <span class=o>&amp;</span> <span class=n>BINDER_DEBUG_TRANSACTION</span><span class=p>)</span>
    <span class=n>printk</span><span class=p>(</span><span class=n>KERN_INFO</span> <span class=s>&quot;        node %d u%p -&gt; ref %d desc %d</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span>
           <span class=n>node</span><span class=o>-&gt;</span><span class=n>debug_id</span><span class=p>,</span> <span class=n>node</span><span class=o>-&gt;</span><span class=n>ptr</span><span class=p>,</span> <span class=n>ref</span><span class=o>-&gt;</span><span class=n>debug_id</span><span class=p>,</span> <span class=n>ref</span><span class=o>-&gt;</span><span class=n>desc</span><span class=p>);</span>
<span class=p>}</span> <span class=k>break</span><span class=p>;</span>
</code></pre></div> <p>由于是第一次在Binder驱动程序中传输这个MediaPlayerService，调用<code>binder_get_node</code>函数查询这个Binder实体时，会返回空，于是<code>binder_new_node</code>在proc中新建一个，下次就可以直接使用了。<br> 现在，由于要把这个Binder实体MediaPlayerService交给target_proc，也就是Service Manager来管理，也就是说Service Manager要引用这个MediaPlayerService了，于是通过<code>binder_get_ref_for_node</code>为MediaPlayerService创建一个引用，并且通过<code>binder_inc_ref</code>来增加这个引用计数，防止这个引用还在使用过程当中就被销毁。注意，到了这里的时候，t-&gt;buffer中的flat_binder_obj的type已经改为BINDER_TYPE_HANDLE，handle已经改为ref-&gt;desc，跟原来不一样了，因为这个flat_binder_obj是最终是要传给Service Manager的，而Service Manager只能够通过句柄值来引用这个Binder实体。</p> <p>最后，在for循环结束后，把待处理事务加入到target_list列表中去，然后把待完成工作项加入到本线程的todo等待执行列表之中：</p> <div class=highlight><pre><span></span><code><span class=n>list_add_tail</span><span class=p>(</span><span class=o>&amp;</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>work</span><span class=p>.</span><span class=n>entry</span><span class=p>,</span> <span class=n>target_list</span><span class=p>);</span>
<span class=p>...</span>
<span class=n>list_add_tail</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tcomplete</span><span class=o>-&gt;</span><span class=n>entry</span><span class=p>,</span> <span class=o>&amp;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>);</span>
</code></pre></div> <p>这样目标进程有待处理的任务了，于是唤醒它：</p> <div class=highlight><pre><span></span><code><span class=k>if</span> <span class=p>(</span><span class=n>target_wait</span><span class=p>)</span>
    <span class=n>wake_up_interruptible</span><span class=p>(</span><span class=n>target_wait</span><span class=p>);</span>
</code></pre></div> <p>这里就是要唤醒Service Manager进程了。回忆一下前面2.2节最后的内容。Service Manager在<code>binder_thread_read</code>函数中用<code>wait_event_interruptible</code>进入休眠状态。 </p> <p>这里我们先忽略一下Service Manager被唤醒之后的场景，继续MedaPlayerService的启动过程，然后再回来。</p> <p>回到binder_ioctl函数，<code>bwr.read_size &gt; 0</code>为true，于是进入binder_thread_read函数：</p> <div class=highlight><pre><span></span><code><span class=k>static</span> <span class=kt>int</span>
<span class=n>binder_thread_read</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_proc</span> <span class=o>*</span><span class=n>proc</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>binder_thread</span> <span class=o>*</span><span class=kr>thread</span><span class=p>,</span>
    <span class=kt>void</span>  <span class=n>__user</span> <span class=o>*</span><span class=n>buffer</span><span class=p>,</span> <span class=kt>int</span> <span class=n>size</span><span class=p>,</span> <span class=kt>signed</span> <span class=kt>long</span> <span class=o>*</span><span class=n>consumed</span><span class=p>,</span> <span class=kt>int</span> <span class=n>non_block</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=n>ptr</span> <span class=o>=</span> <span class=n>buffer</span> <span class=o>+</span> <span class=o>*</span><span class=n>consumed</span><span class=p>;</span>
    <span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=n>end</span> <span class=o>=</span> <span class=n>buffer</span> <span class=o>+</span> <span class=n>size</span><span class=p>;</span>

    <span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>wait_for_proc_work</span><span class=p>;</span>

    <span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=n>consumed</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>put_user</span><span class=p>(</span><span class=n>BR_NOOP</span><span class=p>,</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>__user</span> <span class=o>*</span><span class=p>)</span><span class=n>ptr</span><span class=p>))</span>
            <span class=k>return</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
        <span class=n>ptr</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>);</span>
    <span class=p>}</span>

<span class=nl>retry</span><span class=p>:</span>
    <span class=c1>// 在前面的binder_transaction函数中我们看到了下面俩都不为空，所以wait_for_proc_work=false</span>
    <span class=n>wait_for_proc_work</span> <span class=o>=</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>transaction_stack</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=o>&amp;&amp;</span> <span class=n>list_empty</span><span class=p>(</span><span class=o>&amp;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>);</span>
    <span class=p>...</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>wait_for_proc_work</span><span class=p>)</span>
        <span class=n>proc</span><span class=o>-&gt;</span><span class=n>ready_threads</span><span class=o>++</span><span class=p>;</span>
    <span class=n>mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>binder_lock</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>wait_for_proc_work</span><span class=p>)</span> <span class=p>{</span>
    <span class=p>...</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>non_block</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>binder_has_thread_work</span><span class=p>(</span><span class=kr>thread</span><span class=p>))</span>
                <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>EAGAIN</span><span class=p>;</span>
        <span class=p>}</span> <span class=k>else</span>
            <span class=c1>// 由于todo不为空，因此binder_has_thread_work为true</span>
            <span class=c1>// 所以不会进入睡眠，继续往下面执行</span>
            <span class=n>ret</span> <span class=o>=</span> <span class=n>wait_event_interruptible</span><span class=p>(</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>wait</span><span class=p>,</span> <span class=n>binder_has_thread_work</span><span class=p>(</span><span class=kr>thread</span><span class=p>));</span>
    <span class=p>}</span>
    <span class=n>mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>binder_lock</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>wait_for_proc_work</span><span class=p>)</span>
        <span class=n>proc</span><span class=o>-&gt;</span><span class=n>ready_threads</span><span class=o>--</span><span class=p>;</span>
    <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>looper</span> <span class=o>&amp;=</span> <span class=o>~</span><span class=n>BINDER_LOOPER_STATE_WAITING</span><span class=p>;</span>

    <span class=p>...</span>

    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
        <span class=kt>uint32_t</span> <span class=n>cmd</span><span class=p>;</span>
        <span class=k>struct</span> <span class=nc>binder_transaction_data</span> <span class=n>tr</span><span class=p>;</span>
        <span class=k>struct</span> <span class=nc>binder_work</span> <span class=o>*</span><span class=n>w</span><span class=p>;</span>
        <span class=k>struct</span> <span class=nc>binder_transaction</span> <span class=o>*</span><span class=n>t</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>

        <span class=c1>// thread-&gt;todo不为空</span>
        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>list_empty</span><span class=p>(</span><span class=o>&amp;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>))</span>
            <span class=c1>// 进入这里，w的type在binder_transaction函数中进行了设置</span>
            <span class=c1>// 为BINDER_WORK_TRANSACTION_COMPLETE</span>
            <span class=n>w</span> <span class=o>=</span> <span class=n>list_first_entry</span><span class=p>(</span><span class=o>&amp;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>binder_work</span><span class=p>,</span> <span class=n>entry</span><span class=p>);</span>
        <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=o>!</span><span class=n>list_empty</span><span class=p>(</span><span class=o>&amp;</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>wait_for_proc_work</span><span class=p>)</span>
            <span class=n>w</span> <span class=o>=</span> <span class=n>list_first_entry</span><span class=p>(</span><span class=o>&amp;</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>binder_work</span><span class=p>,</span> <span class=n>entry</span><span class=p>);</span>
        <span class=k>else</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>ptr</span> <span class=o>-</span> <span class=n>buffer</span> <span class=o>==</span> <span class=mi>4</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=p>(</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>looper</span> <span class=o>&amp;</span> <span class=n>BINDER_LOOPER_STATE_NEED_RETURN</span><span class=p>))</span> <span class=cm>/* no data added */</span>
                <span class=k>goto</span> <span class=n>retry</span><span class=p>;</span>
            <span class=k>break</span><span class=p>;</span>
        <span class=p>}</span>

        <span class=k>if</span> <span class=p>(</span><span class=n>end</span> <span class=o>-</span> <span class=n>ptr</span> <span class=o>&lt;</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>tr</span><span class=p>)</span> <span class=o>+</span> <span class=mi>4</span><span class=p>)</span>
            <span class=k>break</span><span class=p>;</span>

        <span class=k>switch</span> <span class=p>(</span><span class=n>w</span><span class=o>-&gt;</span><span class=n>type</span><span class=p>)</span> <span class=p>{</span>
        <span class=p>...</span>
        <span class=k>case</span> <span class=nl>BINDER_WORK_TRANSACTION_COMPLETE</span><span class=p>:</span> <span class=p>{</span>
            <span class=n>cmd</span> <span class=o>=</span> <span class=n>BR_TRANSACTION_COMPLETE</span><span class=p>;</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>put_user</span><span class=p>(</span><span class=n>cmd</span><span class=p>,</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>__user</span> <span class=o>*</span><span class=p>)</span><span class=n>ptr</span><span class=p>))</span>
                <span class=k>return</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
            <span class=n>ptr</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>);</span>

            <span class=n>binder_stat_br</span><span class=p>(</span><span class=n>proc</span><span class=p>,</span> <span class=kr>thread</span><span class=p>,</span> <span class=n>cmd</span><span class=p>);</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>binder_debug_mask</span> <span class=o>&amp;</span> <span class=n>BINDER_DEBUG_TRANSACTION_COMPLETE</span><span class=p>)</span>
                <span class=n>printk</span><span class=p>(</span><span class=n>KERN_INFO</span> <span class=s>&quot;binder: %d:%d BR_TRANSACTION_COMPLETE</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span>
                       <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>);</span>
            <span class=c1>// 将w从thread-&gt;todo中删除</span>
            <span class=n>list_del</span><span class=p>(</span><span class=o>&amp;</span><span class=n>w</span><span class=o>-&gt;</span><span class=n>entry</span><span class=p>);</span>
            <span class=n>kfree</span><span class=p>(</span><span class=n>w</span><span class=p>);</span>
            <span class=n>binder_stats</span><span class=p>.</span><span class=n>obj_deleted</span><span class=p>[</span><span class=n>BINDER_STAT_TRANSACTION_COMPLETE</span><span class=p>]</span><span class=o>++</span><span class=p>;</span>
        <span class=p>}</span> <span class=k>break</span><span class=p>;</span>
        <span class=p>...</span>
        <span class=p>}</span>

        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>t</span><span class=p>)</span>
            <span class=k>continue</span><span class=p>;</span>

        <span class=p>...</span>

<span class=nl>done</span><span class=p>:</span>
    <span class=p>...</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>这里，<code>thread-&gt;transaction_stack</code>和<code>thread-&gt;todo</code>均不为空，于是<code>wait_for_proc_work</code>为false，由于<code>binder_has_thread_work</code>的时候，返回true，这里因为thread-&gt;todo不为空，因此，线程虽然调用了<code>wait_event_interruptible</code>，但是不会睡眠，于是继续往下执行。</p> <p>由于thread-&gt;todo不为空，执行下列语句：</p> <div class=highlight><pre><span></span><code><span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>list_empty</span><span class=p>(</span><span class=o>&amp;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>))</span>
  <span class=n>w</span> <span class=o>=</span> <span class=n>list_first_entry</span><span class=p>(</span><span class=o>&amp;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>binder_work</span><span class=p>,</span> <span class=n>entry</span><span class=p>);</span>
</code></pre></div> <p>w-&gt;type为BINDER_WORK_TRANSACTION_COMPLETE，这是在上面的binder_transaction函数设置的，于是执行：</p> <div class=highlight><pre><span></span><code><span class=k>switch</span> <span class=p>(</span><span class=n>w</span><span class=o>-&gt;</span><span class=n>type</span><span class=p>)</span> <span class=p>{</span>
<span class=p>...</span>
<span class=k>case</span> <span class=nl>BINDER_WORK_TRANSACTION_COMPLETE</span><span class=p>:</span> <span class=p>{</span>
  <span class=n>cmd</span> <span class=o>=</span> <span class=n>BR_TRANSACTION_COMPLETE</span><span class=p>;</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>put_user</span><span class=p>(</span><span class=n>cmd</span><span class=p>,</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>__user</span> <span class=o>*</span><span class=p>)</span><span class=n>ptr</span><span class=p>))</span>
    <span class=k>return</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
  <span class=n>ptr</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>);</span>

  <span class=n>binder_stat_br</span><span class=p>(</span><span class=n>proc</span><span class=p>,</span> <span class=kr>thread</span><span class=p>,</span> <span class=n>cmd</span><span class=p>);</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>binder_debug_mask</span> <span class=o>&amp;</span> <span class=n>BINDER_DEBUG_TRANSACTION_COMPLETE</span><span class=p>)</span>
    <span class=n>printk</span><span class=p>(</span><span class=n>KERN_INFO</span> <span class=s>&quot;binder: %d:%d BR_TRANSACTION_COMPLETE</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span>
           <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>);</span>

  <span class=n>list_del</span><span class=p>(</span><span class=o>&amp;</span><span class=n>w</span><span class=o>-&gt;</span><span class=n>entry</span><span class=p>);</span>
  <span class=n>kfree</span><span class=p>(</span><span class=n>w</span><span class=p>);</span>
  <span class=n>binder_stats</span><span class=p>.</span><span class=n>obj_deleted</span><span class=p>[</span><span class=n>BINDER_STAT_TRANSACTION_COMPLETE</span><span class=p>]</span><span class=o>++</span><span class=p>;</span>
<span class=p>}</span> <span class=k>break</span><span class=p>;</span>
</code></pre></div> <p>这里就将w从thread-&gt;todo删除了。由于这里t为空，重新执行while循环，这时由于已经没有事情可做了，最后就返回到binder_ioctl函数中。注意，在<code>binder_thread_read</code>中一共往用户传进来的缓冲区buffer写入了两个整数，分别是BR_NOOP和BR_TRANSACTION_COMPLETE。 </p> <p><code>binder_ioctl</code>函数返回到用户空间之前，把数据消耗情况拷贝回用户空间中：</p> <div class=highlight><pre><span></span><code><span class=k>if</span> <span class=p>(</span><span class=n>copy_to_user</span><span class=p>(</span><span class=n>ubuf</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>bwr</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>bwr</span><span class=p>)))</span> <span class=p>{</span>
    <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
    <span class=k>goto</span> <span class=n>err</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>最后返回到<code>IPCThreadState::talkWithDriver</code>函数中，执行下面语句：</p> <div class=highlight><pre><span></span><code><span class=k>if</span> <span class=p>(</span><span class=n>err</span> <span class=o>&gt;=</span> <span class=n>NO_ERROR</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>bwr</span><span class=p>.</span><span class=n>write_consumed</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>bwr</span><span class=p>.</span><span class=n>write_consumed</span> <span class=o>&lt;</span> <span class=p>(</span><span class=kt>ssize_t</span><span class=p>)</span><span class=n>mOut</span><span class=p>.</span><span class=n>dataSize</span><span class=p>())</span>
            <span class=n>mOut</span><span class=p>.</span><span class=n>remove</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>bwr</span><span class=p>.</span><span class=n>write_consumed</span><span class=p>);</span>
        <span class=k>else</span>
            <span class=n>mOut</span><span class=p>.</span><span class=n>setDataSize</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>bwr</span><span class=p>.</span><span class=n>read_consumed</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>mIn</span><span class=p>.</span><span class=n>setDataSize</span><span class=p>(</span><span class=n>bwr</span><span class=p>.</span><span class=n>read_consumed</span><span class=p>);</span>
        <span class=n>mIn</span><span class=p>.</span><span class=n>setDataPosition</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=p>...</span>
    <span class=k>return</span> <span class=n>NO_ERROR</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>首先是把<code>mOut</code>清空：<code>mOut.setDataSize(0)</code>，然后设置已经读取的内容的大小：<code>mIn.setDataSize(bwr.read_consumed); mIn.setDataPosition(0);</code>。<br> 然后返回到<code>IPCThreadState::waitForResponse</code>函数中。在<code>IPCThreadState::waitForResponse</code>函数，先是从mIn读出一个整数，这个便是BR_NOOP了，这是一个空操作，什么也不做。然后继续进入<code>IPCThreadState::talkWithDriver</code>函数中。</p> <p>这时候，下面语句执行后：</p> <div class=highlight><pre><span></span><code><span class=k>const</span> <span class=kt>bool</span> <span class=n>needRead</span> <span class=o>=</span> <span class=n>mIn</span><span class=p>.</span><span class=n>dataPosition</span><span class=p>()</span> <span class=o>&gt;=</span> <span class=n>mIn</span><span class=p>.</span><span class=n>dataSize</span><span class=p>();</span>
</code></pre></div> <p>needRead为false，因为在mIn中，尚有一个整数BR_TRANSACTION_COMPLETE未读出。 </p> <p>然后执行下面这句：</p> <div class=highlight><pre><span></span><code><span class=k>const</span> <span class=kt>size_t</span> <span class=n>outAvail</span> <span class=o>=</span> <span class=p>(</span><span class=o>!</span><span class=n>doReceive</span> <span class=o>||</span> <span class=n>needRead</span><span class=p>)</span> <span class=o>?</span> <span class=n>mOut</span><span class=p>.</span><span class=n>dataSize</span><span class=p>()</span> <span class=o>:</span> <span class=mi>0</span><span class=p>;</span>
</code></pre></div> <p>outAvail等于0。因此，最后bwr.write_size和bwr.read_size均被赋值为0，<code>IPCThreadState::talkWithDriver</code>函数什么也不做，直接返回到<code>IPCThreadState::waitForResponse</code>函数中。在<code>IPCThreadState::waitForResponse</code>函数，又继续从mIn读出一个整数，这个便是BR_TRANSACTION_COMPLETE：</p> <div class=highlight><pre><span></span><code><span class=k>switch</span> <span class=p>(</span><span class=n>cmd</span><span class=p>)</span> <span class=p>{</span>
<span class=k>case</span> <span class=nl>BR_TRANSACTION_COMPLETE</span><span class=p>:</span>
       <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>reply</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>acquireResult</span><span class=p>)</span> <span class=k>goto</span> <span class=n>finish</span><span class=p>;</span>
       <span class=k>break</span><span class=p>;</span>
<span class=p>......</span>
<span class=p>}</span>
</code></pre></div> <p>reply不为NULL，因此，IPCThreadState::waitForResponse的循环没有结束，继续执行，又进入到IPCThreadState::talkWithDrive中。<br> 这次，needRead就为true了，而outAvail仍为0，所以bwr.read_size不为0，bwr.write_size为0。于是通过<code>ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr)</code>进入到Binder驱动程序中的binder_ioctl函数中。由于bwr.write_size为0，bwr.read_size不为0，这次直接就进入到<code>binder_thread_read</code>函数中。这时候，<code>thread-&gt;transaction_stack</code>不等于0，但是<code>thread-&gt;todo</code>为空，所以<code>binder_has_thread_work(thread)</code>为false，于是线程就通过<code>wait_event_interruptible(thread-&gt;wait, binder_has_thread_work(thread))</code>来唤醒。 </p> <p>现在，我们可以回到Service Manager被唤醒的过程了。我们接着2.2节的后面继续描述。此时，Service Manager正在<code>binder_thread_read</code>函数中调用<code>wait_event_interruptible_exclusive</code>进入休眠状态。上面被MediaPlayerService启动后进程唤醒后，继续执行<code>binder_thread_read</code>函数：</p> <div class=highlight><pre><span></span><code><span class=k>static</span> <span class=kt>int</span>
<span class=n>binder_thread_read</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_proc</span> <span class=o>*</span><span class=n>proc</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>binder_thread</span> <span class=o>*</span><span class=kr>thread</span><span class=p>,</span>
                   <span class=kt>void</span>  <span class=n>__user</span> <span class=o>*</span><span class=n>buffer</span><span class=p>,</span> <span class=kt>int</span> <span class=n>size</span><span class=p>,</span> <span class=kt>signed</span> <span class=kt>long</span> <span class=o>*</span><span class=n>consumed</span><span class=p>,</span> <span class=kt>int</span> <span class=n>non_block</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=n>ptr</span> <span class=o>=</span> <span class=n>buffer</span> <span class=o>+</span> <span class=o>*</span><span class=n>consumed</span><span class=p>;</span>
    <span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=n>end</span> <span class=o>=</span> <span class=n>buffer</span> <span class=o>+</span> <span class=n>size</span><span class=p>;</span>

    <span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>wait_for_proc_work</span><span class=p>;</span>

    <span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=n>consumed</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>put_user</span><span class=p>(</span><span class=n>BR_NOOP</span><span class=p>,</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>__user</span> <span class=o>*</span><span class=p>)</span><span class=n>ptr</span><span class=p>))</span>
            <span class=k>return</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
        <span class=n>ptr</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>);</span>
    <span class=p>}</span>

<span class=nl>retry</span><span class=p>:</span>
    <span class=n>wait_for_proc_work</span> <span class=o>=</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>transaction_stack</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=o>&amp;&amp;</span> <span class=n>list_empty</span><span class=p>(</span><span class=o>&amp;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>);</span>

    <span class=p>......</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>wait_for_proc_work</span><span class=p>)</span> <span class=p>{</span>
        <span class=p>......</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>non_block</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>binder_has_proc_work</span><span class=p>(</span><span class=n>proc</span><span class=p>,</span> <span class=kr>thread</span><span class=p>))</span>
                <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>EAGAIN</span><span class=p>;</span>
        <span class=p>}</span> <span class=k>else</span>
            <span class=n>ret</span> <span class=o>=</span> <span class=n>wait_event_interruptible_exclusive</span><span class=p>(</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>wait</span><span class=p>,</span> <span class=n>binder_has_proc_work</span><span class=p>(</span><span class=n>proc</span><span class=p>,</span> <span class=kr>thread</span><span class=p>));</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=p>......</span>
    <span class=p>}</span>

    <span class=p>......</span>
    <span class=c1>// 被唤醒后进入while循环开始处理事务</span>
    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
        <span class=kt>uint32_t</span> <span class=n>cmd</span><span class=p>;</span>
        <span class=k>struct</span> <span class=nc>binder_transaction_data</span> <span class=n>tr</span><span class=p>;</span>
        <span class=k>struct</span> <span class=nc>binder_work</span> <span class=o>*</span><span class=n>w</span><span class=p>;</span>
        <span class=k>struct</span> <span class=nc>binder_transaction</span> <span class=o>*</span><span class=n>t</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>

        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>list_empty</span><span class=p>(</span><span class=o>&amp;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>))</span>
            <span class=n>w</span> <span class=o>=</span> <span class=n>list_first_entry</span><span class=p>(</span><span class=o>&amp;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>binder_work</span><span class=p>,</span> <span class=n>entry</span><span class=p>);</span>
        <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=o>!</span><span class=n>list_empty</span><span class=p>(</span><span class=o>&amp;</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>wait_for_proc_work</span><span class=p>)</span>
            <span class=c1>// 来到了这里:wait_for_proc_work=1 &amp; proc-&gt;todo不为空</span>
            <span class=n>w</span> <span class=o>=</span> <span class=n>list_first_entry</span><span class=p>(</span><span class=o>&amp;</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>binder_work</span><span class=p>,</span> <span class=n>entry</span><span class=p>);</span>
        <span class=k>else</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>ptr</span> <span class=o>-</span> <span class=n>buffer</span> <span class=o>==</span> <span class=mi>4</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=p>(</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>looper</span> <span class=o>&amp;</span> <span class=n>BINDER_LOOPER_STATE_NEED_RETURN</span><span class=p>))</span> <span class=cm>/* no data added */</span>
                <span class=k>goto</span> <span class=n>retry</span><span class=p>;</span>
            <span class=k>break</span><span class=p>;</span>
        <span class=p>}</span>

        <span class=k>if</span> <span class=p>(</span><span class=n>end</span> <span class=o>-</span> <span class=n>ptr</span> <span class=o>&lt;</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>tr</span><span class=p>)</span> <span class=o>+</span> <span class=mi>4</span><span class=p>)</span>
            <span class=k>break</span><span class=p>;</span>

        <span class=k>switch</span> <span class=p>(</span><span class=n>w</span><span class=o>-&gt;</span><span class=n>type</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>case</span> <span class=nl>BINDER_WORK_TRANSACTION</span><span class=p>:</span> <span class=p>{</span>
            <span class=c1>// 获得事务项</span>
            <span class=n>t</span> <span class=o>=</span> <span class=n>container_of</span><span class=p>(</span><span class=n>w</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>binder_transaction</span><span class=p>,</span> <span class=n>work</span><span class=p>);</span>
                                      <span class=p>}</span> <span class=k>break</span><span class=p>;</span>
        <span class=p>......</span>
        <span class=p>}</span>

        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>t</span><span class=p>)</span>
            <span class=k>continue</span><span class=p>;</span>

        <span class=n>BUG_ON</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>);</span>
        <span class=c1>// 将事务项t中的数据拷贝到本地局部变量tr中去了</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>target_node</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>struct</span> <span class=nc>binder_node</span> <span class=o>*</span><span class=n>target_node</span> <span class=o>=</span> <span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>target_node</span><span class=p>;</span>
            <span class=n>tr</span><span class=p>.</span><span class=n>target</span><span class=p>.</span><span class=n>ptr</span> <span class=o>=</span> <span class=n>target_node</span><span class=o>-&gt;</span><span class=n>ptr</span><span class=p>;</span>
            <span class=n>tr</span><span class=p>.</span><span class=n>cookie</span> <span class=o>=</span>  <span class=n>target_node</span><span class=o>-&gt;</span><span class=n>cookie</span><span class=p>;</span>
            <span class=p>......</span>
            <span class=n>cmd</span> <span class=o>=</span> <span class=n>BR_TRANSACTION</span><span class=p>;</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=p>......</span>
        <span class=p>}</span>
        <span class=n>tr</span><span class=p>.</span><span class=n>code</span> <span class=o>=</span> <span class=n>t</span><span class=o>-&gt;</span><span class=n>code</span><span class=p>;</span>
        <span class=n>tr</span><span class=p>.</span><span class=n>flags</span> <span class=o>=</span> <span class=n>t</span><span class=o>-&gt;</span><span class=n>flags</span><span class=p>;</span>
        <span class=n>tr</span><span class=p>.</span><span class=n>sender_euid</span> <span class=o>=</span> <span class=n>t</span><span class=o>-&gt;</span><span class=n>sender_euid</span><span class=p>;</span>

        <span class=k>if</span> <span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>from</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>struct</span> <span class=nc>task_struct</span> <span class=o>*</span><span class=n>sender</span> <span class=o>=</span> <span class=n>t</span><span class=o>-&gt;</span><span class=n>from</span><span class=o>-&gt;</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>tsk</span><span class=p>;</span>
            <span class=n>tr</span><span class=p>.</span><span class=n>sender_pid</span> <span class=o>=</span> <span class=n>task_tgid_nr_ns</span><span class=p>(</span><span class=n>sender</span><span class=p>,</span> <span class=n>current</span><span class=o>-&gt;</span><span class=n>nsproxy</span><span class=o>-&gt;</span><span class=n>pid_ns</span><span class=p>);</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=n>tr</span><span class=p>.</span><span class=n>sender_pid</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
        <span class=p>}</span>

        <span class=n>tr</span><span class=p>.</span><span class=n>data_size</span> <span class=o>=</span> <span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>data_size</span><span class=p>;</span>
        <span class=n>tr</span><span class=p>.</span><span class=n>offsets_size</span> <span class=o>=</span> <span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>offsets_size</span><span class=p>;</span>
        <span class=c1>// Binder进程间通信机制的精髓</span>
        <span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>buffer</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>+</span> <span class=n>proc</span><span class=o>-&gt;</span><span class=n>user_buffer_offset</span><span class=p>;</span>
        <span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>offsets</span> <span class=o>=</span> <span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>buffer</span> <span class=o>+</span> <span class=n>ALIGN</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>data_size</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>));</span>

        <span class=c1>// tr的内容拷贝到用户传进来的缓冲区去了，指针ptr指向这个用户缓冲区的地址</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>put_user</span><span class=p>(</span><span class=n>cmd</span><span class=p>,</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>__user</span> <span class=o>*</span><span class=p>)</span><span class=n>ptr</span><span class=p>))</span>
            <span class=k>return</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
        <span class=n>ptr</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>copy_to_user</span><span class=p>(</span><span class=n>ptr</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>tr</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>tr</span><span class=p>)))</span>
            <span class=k>return</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
        <span class=n>ptr</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>tr</span><span class=p>);</span>

        <span class=p>......</span>
        <span class=c1>// 由于已经处理了这个事务，要把它从todo列表中删除</span>
        <span class=n>list_del</span><span class=p>(</span><span class=o>&amp;</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>work</span><span class=p>.</span><span class=n>entry</span><span class=p>);</span>
        <span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>allow_user_free</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>cmd</span> <span class=o>==</span> <span class=n>BR_TRANSACTION</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>TF_ONE_WAY</span><span class=p>))</span> <span class=p>{</span>
            <span class=n>t</span><span class=o>-&gt;</span><span class=n>to_parent</span> <span class=o>=</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>transaction_stack</span><span class=p>;</span>
            <span class=n>t</span><span class=o>-&gt;</span><span class=n>to_thread</span> <span class=o>=</span> <span class=kr>thread</span><span class=p>;</span>
            <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>transaction_stack</span> <span class=o>=</span> <span class=n>t</span><span class=p>;</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>transaction</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
            <span class=n>kfree</span><span class=p>(</span><span class=n>t</span><span class=p>);</span>
            <span class=n>binder_stats</span><span class=p>.</span><span class=n>obj_deleted</span><span class=p>[</span><span class=n>BINDER_STAT_TRANSACTION</span><span class=p>]</span><span class=o>++</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=k>break</span><span class=p>;</span>
    <span class=p>}</span>

<span class=nl>done</span><span class=p>:</span>

    <span class=p>......</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>Service Manager被唤醒之后，就进入while循环开始处理事务了。这里<code>wait_for_proc_work</code>等于1，并且<code>proc-&gt;todo</code>不为空，所以从<code>proc-&gt;todo</code>列表中得到第一个工作项：<code>w = list_first_entry(&amp;proc-&gt;todo, struct binder_work, entry);</code>。 </p> <p>从上面的描述中，我们知道，这个工作项的类型为BINDER_WORK_TRANSACTION，于是通过下面语句得到事务项：<code>t = container_of(w, struct binder_transaction, work);</code>。 </p> <p>接着就是把事务项t中的数据拷贝到本地局部变量<code>struct binder_transaction_data tr</code>中去了：</p> <div class=highlight><pre><span></span><code><span class=k>if</span> <span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>target_node</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>struct</span> <span class=nc>binder_node</span> <span class=o>*</span><span class=n>target_node</span> <span class=o>=</span> <span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>target_node</span><span class=p>;</span>
    <span class=n>tr</span><span class=p>.</span><span class=n>target</span><span class=p>.</span><span class=n>ptr</span> <span class=o>=</span> <span class=n>target_node</span><span class=o>-&gt;</span><span class=n>ptr</span><span class=p>;</span>
    <span class=n>tr</span><span class=p>.</span><span class=n>cookie</span> <span class=o>=</span>  <span class=n>target_node</span><span class=o>-&gt;</span><span class=n>cookie</span><span class=p>;</span>
    <span class=p>......</span>
    <span class=n>cmd</span> <span class=o>=</span> <span class=n>BR_TRANSACTION</span><span class=p>;</span>
<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
    <span class=p>......</span>
<span class=p>}</span>
<span class=n>tr</span><span class=p>.</span><span class=n>code</span> <span class=o>=</span> <span class=n>t</span><span class=o>-&gt;</span><span class=n>code</span><span class=p>;</span>
<span class=n>tr</span><span class=p>.</span><span class=n>flags</span> <span class=o>=</span> <span class=n>t</span><span class=o>-&gt;</span><span class=n>flags</span><span class=p>;</span>
<span class=n>tr</span><span class=p>.</span><span class=n>sender_euid</span> <span class=o>=</span> <span class=n>t</span><span class=o>-&gt;</span><span class=n>sender_euid</span><span class=p>;</span>

<span class=k>if</span> <span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>from</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>struct</span> <span class=nc>task_struct</span> <span class=o>*</span><span class=n>sender</span> <span class=o>=</span> <span class=n>t</span><span class=o>-&gt;</span><span class=n>from</span><span class=o>-&gt;</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>tsk</span><span class=p>;</span>
    <span class=n>tr</span><span class=p>.</span><span class=n>sender_pid</span> <span class=o>=</span> <span class=n>task_tgid_nr_ns</span><span class=p>(</span><span class=n>sender</span><span class=p>,</span> <span class=n>current</span><span class=o>-&gt;</span><span class=n>nsproxy</span><span class=o>-&gt;</span><span class=n>pid_ns</span><span class=p>);</span>
<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
    <span class=n>tr</span><span class=p>.</span><span class=n>sender_pid</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>

<span class=n>tr</span><span class=p>.</span><span class=n>data_size</span> <span class=o>=</span> <span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>data_size</span><span class=p>;</span>
<span class=n>tr</span><span class=p>.</span><span class=n>offsets_size</span> <span class=o>=</span> <span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>offsets_size</span><span class=p>;</span>
<span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>buffer</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>+</span> <span class=n>proc</span><span class=o>-&gt;</span><span class=n>user_buffer_offset</span><span class=p>;</span>
<span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>offsets</span> <span class=o>=</span> <span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>buffer</span> <span class=o>+</span> <span class=n>ALIGN</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>data_size</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>));</span>
</code></pre></div> <p><strong>这里有一个非常重要的地方，是Binder进程间通信机制的精髓所在：</strong></p> <div class=highlight><pre><span></span><code><span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>buffer</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>+</span> <span class=n>proc</span><span class=o>-&gt;</span><span class=n>user_buffer_offset</span><span class=p>;</span>
<span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>offsets</span> <span class=o>=</span> <span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>buffer</span> <span class=o>+</span> <span class=n>ALIGN</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>data_size</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>));</span>
</code></pre></div> <p>t-&gt;buffer-&gt;data所指向的地址是内核空间的，现在要把数据返回给Service Manager进程的用户空间，而Service Manager进程的用户空间是不能访问内核空间的数据的，所以这里要作一下处理。怎么处理呢？我们在学面向对象语言的时候，对象的拷贝有深拷贝和浅拷贝之分，深拷贝是把另外分配一块新内存，然后把原始对象的内容搬过去，浅拷贝是并没有为新对象分配一块新空间，而只是分配一个引用，而个引用指向原始对象。 <strong>Binder机制用的是类似浅拷贝的方法，通过在用户空间分配一个虚拟地址，然后让这个用户空间虚拟地址与t-&gt;buffer-&gt;data这个内核空间虚拟地址指向同一个物理地址，这样就可以实现浅拷贝了。</strong> 怎么样用户空间和内核空间的虚拟地址同时指向同一个物理地址呢？请参考2.2节，那里有详细描述。这里只要将t-&gt;buffer-&gt;data加上一个偏移值proc-&gt;user_buffer_offset就可以得到t-&gt;buffer-&gt;data对应的用户空间虚拟地址了。调整了tr.data.ptr.buffer的值之后，不要忘记也要一起调整tr.data.ptr.offsets的值。</p> <p>接着就是把tr的内容拷贝到用户传进来的缓冲区去了，指针ptr指向这个用户缓冲区的地址：</p> <div class=highlight><pre><span></span><code><span class=k>if</span> <span class=p>(</span><span class=n>put_user</span><span class=p>(</span><span class=n>cmd</span><span class=p>,</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>__user</span> <span class=o>*</span><span class=p>)</span><span class=n>ptr</span><span class=p>))</span>
    <span class=k>return</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
<span class=n>ptr</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>);</span>
<span class=k>if</span> <span class=p>(</span><span class=n>copy_to_user</span><span class=p>(</span><span class=n>ptr</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>tr</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>tr</span><span class=p>)))</span>
    <span class=k>return</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
<span class=n>ptr</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>tr</span><span class=p>);</span>
</code></pre></div> <p>这里可以看出，这里只是对作<code>tr.data.ptr.buffer</code>和<code>tr.data.ptr.offsets</code>的内容作了浅拷贝。<br> 最后，由于已经处理了这个事务，要把它从todo列表中删除：</p> <div class=highlight><pre><span></span><code><span class=n>list_del</span><span class=p>(</span><span class=o>&amp;</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>work</span><span class=p>.</span><span class=n>entry</span><span class=p>);</span>
<span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>allow_user_free</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
<span class=k>if</span> <span class=p>(</span><span class=n>cmd</span> <span class=o>==</span> <span class=n>BR_TRANSACTION</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>TF_ONE_WAY</span><span class=p>))</span> <span class=p>{</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>to_parent</span> <span class=o>=</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>transaction_stack</span><span class=p>;</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>to_thread</span> <span class=o>=</span> <span class=kr>thread</span><span class=p>;</span>
    <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>transaction_stack</span> <span class=o>=</span> <span class=n>t</span><span class=p>;</span>
<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>transaction</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=n>kfree</span><span class=p>(</span><span class=n>t</span><span class=p>);</span>
    <span class=n>binder_stats</span><span class=p>.</span><span class=n>obj_deleted</span><span class=p>[</span><span class=n>BINDER_STAT_TRANSACTION</span><span class=p>]</span><span class=o>++</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>注意，这里的<code>cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)</code>为true，表明这个事务虽然在驱动程序中已经处理完了，但是它仍然要等待Service Manager完成之后，给驱动程序一个确认，也就是需要等待回复，于是把当前事务t放在<code>thread-&gt;transaction_stack</code>队列的头部；如果<code>cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)</code>为false，那就不需要等待回复了，直接把事务t删掉。</p> <p>这个while最后通过一个break跳了出来，最后返回到<code>binder_ioctl</code>函数中：</p> <div class=highlight><pre><span></span><code><span class=k>if</span> <span class=p>(</span><span class=n>bwr</span><span class=p>.</span><span class=n>read_size</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>ret</span> <span class=o>=</span> <span class=n>binder_thread_read</span><span class=p>(</span><span class=n>proc</span><span class=p>,</span> <span class=kr>thread</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=p>)</span><span class=n>bwr</span><span class=p>.</span><span class=n>read_buffer</span><span class=p>,</span> <span class=n>bwr</span><span class=p>.</span><span class=n>read_size</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>bwr</span><span class=p>.</span><span class=n>read_consumed</span><span class=p>,</span> <span class=n>filp</span><span class=o>-&gt;</span><span class=n>f_flags</span> <span class=o>&amp;</span> <span class=n>O_NONBLOCK</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>list_empty</span><span class=p>(</span><span class=o>&amp;</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>))</span>
        <span class=n>wake_up_interruptible</span><span class=p>(</span><span class=o>&amp;</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>wait</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>copy_to_user</span><span class=p>(</span><span class=n>ubuf</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>bwr</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>bwr</span><span class=p>)))</span>
            <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
        <span class=k>goto</span> <span class=n>err</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div> <p>从<code>binder_thread_read</code>返回来后，再看看<code>proc-&gt;todo</code>是否还有事务等待处理，如果是，就把睡眠在<code>proc-&gt;wait</code>队列的线程唤醒来处理。最后，把本地变量<code>struct binder_write_read bwr</code>的内容拷贝回到用户传进来的缓冲区中，就返回了。</p> <p>然后就回到用户空间中的<code>binder.c</code>中的<code>binder_loop</code>了：</p> <div class=highlight><pre><span></span><code><span class=kt>void</span> <span class=nf>binder_loop</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_state</span> <span class=o>*</span><span class=n>bs</span><span class=p>,</span> <span class=n>binder_handler</span> <span class=n>func</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>int</span> <span class=n>res</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>binder_write_read</span> <span class=n>bwr</span><span class=p>;</span>
    <span class=kt>unsigned</span> <span class=n>readbuf</span><span class=p>[</span><span class=mi>32</span><span class=p>];</span>

    <span class=n>bwr</span><span class=p>.</span><span class=n>write_size</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>bwr</span><span class=p>.</span><span class=n>write_consumed</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>bwr</span><span class=p>.</span><span class=n>write_buffer</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>

    <span class=n>readbuf</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>BC_ENTER_LOOPER</span><span class=p>;</span>
    <span class=n>binder_write</span><span class=p>(</span><span class=n>bs</span><span class=p>,</span> <span class=n>readbuf</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>unsigned</span><span class=p>));</span>

    <span class=k>for</span> <span class=p>(;;)</span> <span class=p>{</span>
        <span class=n>bwr</span><span class=p>.</span><span class=n>read_size</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>readbuf</span><span class=p>);</span>
        <span class=n>bwr</span><span class=p>.</span><span class=n>read_consumed</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
        <span class=n>bwr</span><span class=p>.</span><span class=n>read_buffer</span> <span class=o>=</span> <span class=p>(</span><span class=kt>unsigned</span><span class=p>)</span> <span class=n>readbuf</span><span class=p>;</span>

        <span class=n>res</span> <span class=o>=</span> <span class=n>ioctl</span><span class=p>(</span><span class=n>bs</span><span class=o>-&gt;</span><span class=n>fd</span><span class=p>,</span> <span class=n>BINDER_WRITE_READ</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>bwr</span><span class=p>);</span>

        <span class=k>if</span> <span class=p>(</span><span class=n>res</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>LOGE</span><span class=p>(</span><span class=s>&quot;binder_loop: ioctl failed (%s)</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span> <span class=n>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
            <span class=k>break</span><span class=p>;</span>
        <span class=p>}</span>

        <span class=n>res</span> <span class=o>=</span> <span class=n>binder_parse</span><span class=p>(</span><span class=n>bs</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>readbuf</span><span class=p>,</span> <span class=n>bwr</span><span class=p>.</span><span class=n>read_consumed</span><span class=p>,</span> <span class=n>func</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>res</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>LOGE</span><span class=p>(</span><span class=s>&quot;binder_loop: unexpected reply?!</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>);</span>
            <span class=k>break</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>res</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>LOGE</span><span class=p>(</span><span class=s>&quot;binder_loop: io error %d %s</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span> <span class=n>res</span><span class=p>,</span> <span class=n>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
            <span class=k>break</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div> <p>返回来的数据都放在readbuf中，接着调用binder_parse进行解析：</p> <div class=highlight><pre><span></span><code><span class=kt>int</span> <span class=nf>binder_parse</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_state</span> <span class=o>*</span><span class=n>bs</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>binder_io</span> <span class=o>*</span><span class=n>bio</span><span class=p>,</span>
                 <span class=kt>uint32_t</span> <span class=o>*</span><span class=n>ptr</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>size</span><span class=p>,</span> <span class=n>binder_handler</span> <span class=n>func</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>int</span> <span class=n>r</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
    <span class=kt>uint32_t</span> <span class=o>*</span><span class=n>end</span> <span class=o>=</span> <span class=n>ptr</span> <span class=o>+</span> <span class=p>(</span><span class=n>size</span> <span class=o>/</span> <span class=mi>4</span><span class=p>);</span>

    <span class=k>while</span> <span class=p>(</span><span class=n>ptr</span> <span class=o>&lt;</span> <span class=n>end</span><span class=p>)</span> <span class=p>{</span>
        <span class=kt>uint32_t</span> <span class=n>cmd</span> <span class=o>=</span> <span class=o>*</span><span class=n>ptr</span><span class=o>++</span><span class=p>;</span>
        <span class=p>...</span>
        <span class=k>switch</span><span class=p>(</span><span class=n>cmd</span><span class=p>)</span> <span class=p>{</span>
        <span class=p>...</span>
        <span class=k>case</span> <span class=nl>BR_TRANSACTION</span><span class=p>:</span> <span class=p>{</span>
            <span class=c1>// 首先把从Binder驱动程序读出来的数据保存在txn中</span>
            <span class=k>struct</span> <span class=nc>binder_txn</span> <span class=o>*</span><span class=n>txn</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=n>ptr</span><span class=p>;</span>
            <span class=k>if</span> <span class=p>((</span><span class=n>end</span> <span class=o>-</span> <span class=n>ptr</span><span class=p>)</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>)</span> <span class=o>&lt;</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_txn</span><span class=p>))</span> <span class=p>{</span>
                <span class=n>LOGE</span><span class=p>(</span><span class=s>&quot;parse: txn too small!</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>);</span>
                <span class=k>return</span> <span class=mi>-1</span><span class=p>;</span>
            <span class=p>}</span>
            <span class=n>binder_dump_txn</span><span class=p>(</span><span class=n>txn</span><span class=p>);</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>func</span><span class=p>)</span> <span class=p>{</span>
                <span class=kt>unsigned</span> <span class=n>rdata</span><span class=p>[</span><span class=mi>256</span><span class=o>/</span><span class=mi>4</span><span class=p>];</span>
                <span class=k>struct</span> <span class=nc>binder_io</span> <span class=n>msg</span><span class=p>;</span>
                <span class=k>struct</span> <span class=nc>binder_io</span> <span class=n>reply</span><span class=p>;</span>
                <span class=kt>int</span> <span class=n>res</span><span class=p>;</span>
                <span class=c1>// 调用bio_init来初始化reply变量</span>
                <span class=n>bio_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>reply</span><span class=p>,</span> <span class=n>rdata</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>rdata</span><span class=p>),</span> <span class=mi>4</span><span class=p>);</span>
                <span class=c1>// 调用bio_init_from_txn来初始化msg变量</span>
                <span class=n>bio_init_from_txn</span><span class=p>(</span><span class=o>&amp;</span><span class=n>msg</span><span class=p>,</span> <span class=n>txn</span><span class=p>);</span>
                <span class=c1>// 调用func进行处理，对应svcmgr_handler函数</span>
                <span class=n>res</span> <span class=o>=</span> <span class=n>func</span><span class=p>(</span><span class=n>bs</span><span class=p>,</span> <span class=n>txn</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>msg</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>reply</span><span class=p>);</span>
                <span class=c1>// 告诉Binder驱动完成了任务</span>
                <span class=n>binder_send_reply</span><span class=p>(</span><span class=n>bs</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>reply</span><span class=p>,</span> <span class=n>txn</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>,</span> <span class=n>res</span><span class=p>);</span>
            <span class=p>}</span>
            <span class=n>ptr</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=n>txn</span><span class=p>)</span> <span class=o>/</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>);</span>
            <span class=k>break</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=p>...</span>
        <span class=k>default</span><span class=o>:</span>
            <span class=n>LOGE</span><span class=p>(</span><span class=s>&quot;parse: OOPS %d</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span> <span class=n>cmd</span><span class=p>);</span>
            <span class=k>return</span> <span class=mi>-1</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>r</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>首先把从Binder驱动程序读出来的数据转换为一个<code>struct binder_txn</code>结构体，保存在txn本地变量中，<code>struct binder_txn</code>定义在frameworks/base/cmds/servicemanager/binder.h文件中，此外函数中还用到了另外一个数据结构<code>struct binder_io</code>，也定义在其中：</p> <div class=highlight><pre><span></span><code><span class=k>struct</span> <span class=nc>binder_txn</span>
<span class=p>{</span>
    <span class=kt>void</span> <span class=o>*</span><span class=n>target</span><span class=p>;</span>
    <span class=kt>void</span> <span class=o>*</span><span class=n>cookie</span><span class=p>;</span>
    <span class=kt>uint32_t</span> <span class=n>code</span><span class=p>;</span>
    <span class=kt>uint32_t</span> <span class=n>flags</span><span class=p>;</span>

    <span class=kt>uint32_t</span> <span class=n>sender_pid</span><span class=p>;</span>
    <span class=kt>uint32_t</span> <span class=n>sender_euid</span><span class=p>;</span>

    <span class=kt>uint32_t</span> <span class=n>data_size</span><span class=p>;</span>
    <span class=kt>uint32_t</span> <span class=n>offs_size</span><span class=p>;</span>
    <span class=kt>void</span> <span class=o>*</span><span class=n>data</span><span class=p>;</span>
    <span class=kt>void</span> <span class=o>*</span><span class=n>offs</span><span class=p>;</span>
<span class=p>};</span>

<span class=k>struct</span> <span class=nc>binder_io</span>
<span class=p>{</span>
    <span class=kt>char</span> <span class=o>*</span><span class=n>data</span><span class=p>;</span>            <span class=cm>/* pointer to read/write from */</span>
    <span class=kt>uint32_t</span> <span class=o>*</span><span class=n>offs</span><span class=p>;</span>        <span class=cm>/* array of offsets */</span>
    <span class=kt>uint32_t</span> <span class=n>data_avail</span><span class=p>;</span>   <span class=cm>/* bytes available in data buffer */</span>
    <span class=kt>uint32_t</span> <span class=n>offs_avail</span><span class=p>;</span>   <span class=cm>/* entries available in offsets array */</span>

    <span class=kt>char</span> <span class=o>*</span><span class=n>data0</span><span class=p>;</span>           <span class=cm>/* start of data buffer */</span>
    <span class=kt>uint32_t</span> <span class=o>*</span><span class=n>offs0</span><span class=p>;</span>       <span class=cm>/* start of offsets buffer */</span>
    <span class=kt>uint32_t</span> <span class=n>flags</span><span class=p>;</span>
    <span class=kt>uint32_t</span> <span class=n>unused</span><span class=p>;</span>
<span class=p>};</span>
</code></pre></div> <p>接下来，调用<code>bio_init</code>来初始化reply变量：</p> <div class=highlight><pre><span></span><code><span class=kt>void</span> <span class=nf>bio_init</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_io</span> <span class=o>*</span><span class=n>bio</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>data</span><span class=p>,</span>
              <span class=kt>uint32_t</span> <span class=n>maxdata</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>maxoffs</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>uint32_t</span> <span class=n>n</span> <span class=o>=</span> <span class=n>maxoffs</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>);</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>&gt;</span> <span class=n>maxdata</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>bio</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>=</span> <span class=n>BIO_F_OVERFLOW</span><span class=p>;</span>
        <span class=n>bio</span><span class=o>-&gt;</span><span class=n>data_avail</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
        <span class=n>bio</span><span class=o>-&gt;</span><span class=n>offs_avail</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
        <span class=k>return</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=n>bio</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>=</span> <span class=n>bio</span><span class=o>-&gt;</span><span class=n>data0</span> <span class=o>=</span> <span class=n>data</span> <span class=o>+</span> <span class=n>n</span><span class=p>;</span>
    <span class=n>bio</span><span class=o>-&gt;</span><span class=n>offs</span> <span class=o>=</span> <span class=n>bio</span><span class=o>-&gt;</span><span class=n>offs0</span> <span class=o>=</span> <span class=n>data</span><span class=p>;</span>
    <span class=n>bio</span><span class=o>-&gt;</span><span class=n>data_avail</span> <span class=o>=</span> <span class=n>maxdata</span> <span class=o>-</span> <span class=n>n</span><span class=p>;</span>
    <span class=n>bio</span><span class=o>-&gt;</span><span class=n>offs_avail</span> <span class=o>=</span> <span class=n>maxoffs</span><span class=p>;</span>
    <span class=n>bio</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>接着又调用<code>bio_init_from_txn</code>来初始化msg变量：</p> <div class=highlight><pre><span></span><code><span class=kt>void</span> <span class=nf>bio_init_from_txn</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_io</span> <span class=o>*</span><span class=n>bio</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>binder_txn</span> <span class=o>*</span><span class=n>txn</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>bio</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>=</span> <span class=n>bio</span><span class=o>-&gt;</span><span class=n>data0</span> <span class=o>=</span> <span class=n>txn</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>;</span>
    <span class=n>bio</span><span class=o>-&gt;</span><span class=n>offs</span> <span class=o>=</span> <span class=n>bio</span><span class=o>-&gt;</span><span class=n>offs0</span> <span class=o>=</span> <span class=n>txn</span><span class=o>-&gt;</span><span class=n>offs</span><span class=p>;</span>
    <span class=n>bio</span><span class=o>-&gt;</span><span class=n>data_avail</span> <span class=o>=</span> <span class=n>txn</span><span class=o>-&gt;</span><span class=n>data_size</span><span class=p>;</span>
    <span class=n>bio</span><span class=o>-&gt;</span><span class=n>offs_avail</span> <span class=o>=</span> <span class=n>txn</span><span class=o>-&gt;</span><span class=n>offs_size</span> <span class=o>/</span> <span class=mi>4</span><span class=p>;</span>
    <span class=n>bio</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>=</span> <span class=n>BIO_F_SHARED</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>最后，真正进行处理的函数是从参数中传进来的函数指针<code>func</code>，这里就是定义在frameworks/base/cmds/servicemanager/service_manager.c文件中的<code>svcmgr_handler</code>函数：</p> <div class=highlight><pre><span></span><code><span class=kt>int</span> <span class=nf>svcmgr_handler</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_state</span> <span class=o>*</span><span class=n>bs</span><span class=p>,</span>
                   <span class=k>struct</span> <span class=nc>binder_txn</span> <span class=o>*</span><span class=n>txn</span><span class=p>,</span>
                   <span class=k>struct</span> <span class=nc>binder_io</span> <span class=o>*</span><span class=n>msg</span><span class=p>,</span>
                   <span class=k>struct</span> <span class=nc>binder_io</span> <span class=o>*</span><span class=n>reply</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>struct</span> <span class=nc>svcinfo</span> <span class=o>*</span><span class=n>si</span><span class=p>;</span>
    <span class=kt>uint16_t</span> <span class=o>*</span><span class=n>s</span><span class=p>;</span>
    <span class=kt>unsigned</span> <span class=n>len</span><span class=p>;</span>
    <span class=kt>void</span> <span class=o>*</span><span class=n>ptr</span><span class=p>;</span>
    <span class=kt>uint32_t</span> <span class=n>strict_policy</span><span class=p>;</span>

<span class=c1>//    LOGI(&quot;target=%p code=%d pid=%d uid=%d\n&quot;,</span>
<span class=c1>//         txn-&gt;target, txn-&gt;code, txn-&gt;sender_pid, txn-&gt;sender_euid);</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>txn</span><span class=o>-&gt;</span><span class=n>target</span> <span class=o>!=</span> <span class=n>svcmgr_handle</span><span class=p>)</span>
        <span class=k>return</span> <span class=mi>-1</span><span class=p>;</span>

    <span class=c1>// Equivalent to Parcel::enforceInterface(), reading the RPC</span>
    <span class=c1>// header with the strict mode policy mask and the interface name.</span>
    <span class=c1>// Note that we ignore the strict_policy and don&#39;t propagate it</span>
    <span class=c1>// further (since we do no outbound RPCs anyway).</span>
    <span class=n>strict_policy</span> <span class=o>=</span> <span class=n>bio_get_uint32</span><span class=p>(</span><span class=n>msg</span><span class=p>);</span>
    <span class=n>s</span> <span class=o>=</span> <span class=n>bio_get_string16</span><span class=p>(</span><span class=n>msg</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>len</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>((</span><span class=n>len</span> <span class=o>!=</span> <span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=n>svcmgr_id</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>))</span> <span class=o>||</span>
        <span class=n>memcmp</span><span class=p>(</span><span class=n>svcmgr_id</span><span class=p>,</span> <span class=n>s</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>svcmgr_id</span><span class=p>)))</span> <span class=p>{</span>
        <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&quot;invalid id %s</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span> <span class=n>str8</span><span class=p>(</span><span class=n>s</span><span class=p>));</span>
        <span class=k>return</span> <span class=mi>-1</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>switch</span><span class=p>(</span><span class=n>txn</span><span class=o>-&gt;</span><span class=n>code</span><span class=p>)</span> <span class=p>{</span>
    <span class=p>...</span>
    <span class=k>case</span> <span class=nl>SVC_MGR_ADD_SERVICE</span><span class=p>:</span>
        <span class=n>s</span> <span class=o>=</span> <span class=n>bio_get_string16</span><span class=p>(</span><span class=n>msg</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>len</span><span class=p>);</span>
        <span class=n>ptr</span> <span class=o>=</span> <span class=n>bio_get_ref</span><span class=p>(</span><span class=n>msg</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>do_add_service</span><span class=p>(</span><span class=n>bs</span><span class=p>,</span> <span class=n>s</span><span class=p>,</span> <span class=n>len</span><span class=p>,</span> <span class=n>ptr</span><span class=p>,</span> <span class=n>txn</span><span class=o>-&gt;</span><span class=n>sender_euid</span><span class=p>))</span>
            <span class=k>return</span> <span class=mi>-1</span><span class=p>;</span>
        <span class=k>break</span><span class=p>;</span>
    <span class=p>...</span>
    <span class=p>}</span>

    <span class=n>bio_put_uint32</span><span class=p>(</span><span class=n>reply</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>回忆一下，在<code>BpServiceManager::addService</code>时，传给Binder驱动程序的参数为：</p> <div class=highlight><pre><span></span><code><span class=n>writeInt32</span><span class=p>(</span><span class=n>IPCThreadState</span><span class=o>::</span><span class=n>self</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>getStrictModePolicy</span><span class=p>()</span> <span class=o>|</span>
               <span class=n>STRICT_MODE_PENALTY_GATHER</span><span class=p>);</span>
<span class=n>writeString16</span><span class=p>(</span><span class=s>&quot;android.os.IServiceManager&quot;</span><span class=p>);</span>
<span class=n>writeString16</span><span class=p>(</span><span class=s>&quot;media.player&quot;</span><span class=p>);</span>
<span class=n>writeStrongBinder</span><span class=p>(</span><span class=n>new</span> <span class=n>MediaPlayerService</span><span class=p>());</span>
</code></pre></div> <p>这里的语句：</p> <div class=highlight><pre><span></span><code><span class=n>strict_policy</span> <span class=o>=</span> <span class=n>bio_get_uint32</span><span class=p>(</span><span class=n>msg</span><span class=p>);</span>
<span class=n>s</span> <span class=o>=</span> <span class=n>bio_get_string16</span><span class=p>(</span><span class=n>msg</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>len</span><span class=p>);</span>
<span class=n>s</span> <span class=o>=</span> <span class=n>bio_get_string16</span><span class=p>(</span><span class=n>msg</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>len</span><span class=p>);</span>
<span class=n>ptr</span> <span class=o>=</span> <span class=n>bio_get_ref</span><span class=p>(</span><span class=n>msg</span><span class=p>);</span>
</code></pre></div> <p>就是依次把它们读取出来了，这里，我们只要看一下bio_get_ref的实现。先看一个数据结构<code>struct binder_obj</code>的定义：</p> <div class=highlight><pre><span></span><code><span class=k>struct</span> <span class=nc>binder_object</span>
<span class=p>{</span>
    <span class=kt>uint32_t</span> <span class=n>type</span><span class=p>;</span>
    <span class=kt>uint32_t</span> <span class=n>flags</span><span class=p>;</span>
    <span class=kt>void</span> <span class=o>*</span><span class=n>pointer</span><span class=p>;</span>
    <span class=kt>void</span> <span class=o>*</span><span class=n>cookie</span><span class=p>;</span>
<span class=p>};</span>
</code></pre></div> <p>这个结构体就是对应<code>struct flat_binder_obj</code>的。</p> <p>接着看<code>bio_get_ref</code>实现：</p> <div class=highlight><pre><span></span><code><span class=kt>void</span> <span class=o>*</span><span class=nf>bio_get_ref</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_io</span> <span class=o>*</span><span class=n>bio</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>struct</span> <span class=nc>binder_object</span> <span class=o>*</span><span class=n>obj</span><span class=p>;</span>

    <span class=n>obj</span> <span class=o>=</span> <span class=n>_bio_get_obj</span><span class=p>(</span><span class=n>bio</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>obj</span><span class=p>)</span>
        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>obj</span><span class=o>-&gt;</span><span class=n>type</span> <span class=o>==</span> <span class=n>BINDER_TYPE_HANDLE</span><span class=p>)</span>
        <span class=k>return</span> <span class=n>obj</span><span class=o>-&gt;</span><span class=n>pointer</span><span class=p>;</span>

    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p><code>_bio_get_obj</code>这个函数就不跟进去看了，它的作用就是从binder_io中取得第一个还没取获取过的binder_object。在这个场景下，就是我们最开始传过来代表MediaPlayerService的flat_binder_obj了，这个原始的flat_binder_obj的type为BINDER_TYPE_BINDER，binder为指向MediaPlayerService的弱引用的地址。<br> 在前面我们说过，在Binder驱动驱动程序里面，会把这个flat_binder_obj的type改为BINDER_TYPE_HANDLE，handle改为一个句柄值。这里的handle值就等于obj-&gt;pointer的值。</p> <p>回到<code>svcmgr_handler</code>函数，调用<code>do_add_service</code>进一步处理：</p> <div class=highlight><pre><span></span><code><span class=kt>int</span> <span class=nf>do_add_service</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_state</span> <span class=o>*</span><span class=n>bs</span><span class=p>,</span>
                   <span class=kt>uint16_t</span> <span class=o>*</span><span class=n>s</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=n>len</span><span class=p>,</span>
                   <span class=kt>void</span> <span class=o>*</span><span class=n>ptr</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=n>uid</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>struct</span> <span class=nc>svcinfo</span> <span class=o>*</span><span class=n>si</span><span class=p>;</span>
<span class=c1>//    LOGI(&quot;add_service(&#39;%s&#39;,%p) uid=%d\n&quot;, str8(s), ptr, uid);</span>

    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>ptr</span> <span class=o>||</span> <span class=p>(</span><span class=n>len</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=o>||</span> <span class=p>(</span><span class=n>len</span> <span class=o>&gt;</span> <span class=mi>127</span><span class=p>))</span>
        <span class=k>return</span> <span class=mi>-1</span><span class=p>;</span>

    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>svc_can_register</span><span class=p>(</span><span class=n>uid</span><span class=p>,</span> <span class=n>s</span><span class=p>))</span> <span class=p>{</span>
        <span class=n>LOGE</span><span class=p>(</span><span class=s>&quot;add_service(&#39;%s&#39;,%p) uid=%d - PERMISSION DENIED</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span>
             <span class=n>str8</span><span class=p>(</span><span class=n>s</span><span class=p>),</span> <span class=n>ptr</span><span class=p>,</span> <span class=n>uid</span><span class=p>);</span>
        <span class=k>return</span> <span class=mi>-1</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=n>si</span> <span class=o>=</span> <span class=n>find_svc</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>len</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>si</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>si</span><span class=o>-&gt;</span><span class=n>ptr</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>LOGE</span><span class=p>(</span><span class=s>&quot;add_service(&#39;%s&#39;,%p) uid=%d - ALREADY REGISTERED</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span>
                 <span class=n>str8</span><span class=p>(</span><span class=n>s</span><span class=p>),</span> <span class=n>ptr</span><span class=p>,</span> <span class=n>uid</span><span class=p>);</span>
            <span class=k>return</span> <span class=mi>-1</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=n>si</span><span class=o>-&gt;</span><span class=n>ptr</span> <span class=o>=</span> <span class=n>ptr</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=c1>// 将Binder实体的引用保存早struct svcinfo中，然后插入到链表svclist的头部</span>
        <span class=n>si</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=n>si</span><span class=p>)</span> <span class=o>+</span> <span class=p>(</span><span class=n>len</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint16_t</span><span class=p>));</span>
        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>si</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>LOGE</span><span class=p>(</span><span class=s>&quot;add_service(&#39;%s&#39;,%p) uid=%d - OUT OF MEMORY</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span>
                 <span class=n>str8</span><span class=p>(</span><span class=n>s</span><span class=p>),</span> <span class=n>ptr</span><span class=p>,</span> <span class=n>uid</span><span class=p>);</span>
            <span class=k>return</span> <span class=mi>-1</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=n>si</span><span class=o>-&gt;</span><span class=n>ptr</span> <span class=o>=</span> <span class=n>ptr</span><span class=p>;</span>
        <span class=n>si</span><span class=o>-&gt;</span><span class=n>len</span> <span class=o>=</span> <span class=n>len</span><span class=p>;</span>
        <span class=n>memcpy</span><span class=p>(</span><span class=n>si</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>,</span> <span class=n>s</span><span class=p>,</span> <span class=p>(</span><span class=n>len</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint16_t</span><span class=p>));</span>
        <span class=n>si</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>[</span><span class=n>len</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;\0&#39;</span><span class=p>;</span>
        <span class=n>si</span><span class=o>-&gt;</span><span class=n>death</span><span class=p>.</span><span class=n>func</span> <span class=o>=</span> <span class=n>svcinfo_death</span><span class=p>;</span>
        <span class=n>si</span><span class=o>-&gt;</span><span class=n>death</span><span class=p>.</span><span class=n>ptr</span> <span class=o>=</span> <span class=n>si</span><span class=p>;</span>
        <span class=n>si</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>svclist</span><span class=p>;</span>
        <span class=n>svclist</span> <span class=o>=</span> <span class=n>si</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=n>binder_acquire</span><span class=p>(</span><span class=n>bs</span><span class=p>,</span> <span class=n>ptr</span><span class=p>);</span>
    <span class=n>binder_link_to_death</span><span class=p>(</span><span class=n>bs</span><span class=p>,</span> <span class=n>ptr</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>si</span><span class=o>-&gt;</span><span class=n>death</span><span class=p>);</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>这个函数的实现很简单，就是把MediaPlayerService这个Binder实体的引用写到一个<code>struct svcinfo</code>结构体中，主要是它的名称和句柄值，然后插入到链接svclist的头部去。这样，Client来向Service Manager查询服务接口时，只要给定服务名称，Service Manger就可以返回相应的句柄值了。</p> <p>这个函数执行完成后，返回到svcmgr_handler函数，函数的最后，将一个错误码0写到reply变量中去，表示一切正常：<code>bio_put_uint32(reply, 0);</code>。 </p> <p><code>svcmgr_handler</code>函数执行完成后，返回到<code>binder_parse</code>函数中，执行下面语句：</p> <div class=highlight><pre><span></span><code><span class=n>binder_send_reply</span><span class=p>(</span><span class=n>bs</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>reply</span><span class=p>,</span> <span class=n>txn</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>,</span> <span class=n>res</span><span class=p>);</span>
</code></pre></div> <p>该函数从名字就可以看出来，它将告诉Binder驱动程序，已经完成了任务：</p> <div class=highlight><pre><span></span><code><span class=kt>void</span> <span class=nf>binder_send_reply</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_state</span> <span class=o>*</span><span class=n>bs</span><span class=p>,</span>
                       <span class=k>struct</span> <span class=nc>binder_io</span> <span class=o>*</span><span class=n>reply</span><span class=p>,</span>
                       <span class=kt>void</span> <span class=o>*</span><span class=n>buffer_to_free</span><span class=p>,</span>
                       <span class=kt>int</span> <span class=n>status</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>struct</span> <span class=p>{</span>
        <span class=kt>uint32_t</span> <span class=n>cmd_free</span><span class=p>;</span>
        <span class=kt>void</span> <span class=o>*</span><span class=n>buffer</span><span class=p>;</span>
        <span class=kt>uint32_t</span> <span class=n>cmd_reply</span><span class=p>;</span>
        <span class=k>struct</span> <span class=nc>binder_txn</span> <span class=n>txn</span><span class=p>;</span>
    <span class=p>}</span> <span class=n>__attribute__</span><span class=p>((</span><span class=n>packed</span><span class=p>))</span> <span class=n>data</span><span class=p>;</span>

    <span class=n>data</span><span class=p>.</span><span class=n>cmd_free</span> <span class=o>=</span> <span class=n>BC_FREE_BUFFER</span><span class=p>;</span>
    <span class=n>data</span><span class=p>.</span><span class=n>buffer</span> <span class=o>=</span> <span class=n>buffer_to_free</span><span class=p>;</span>
    <span class=n>data</span><span class=p>.</span><span class=n>cmd_reply</span> <span class=o>=</span> <span class=n>BC_REPLY</span><span class=p>;</span>
    <span class=n>data</span><span class=p>.</span><span class=n>txn</span><span class=p>.</span><span class=n>target</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>data</span><span class=p>.</span><span class=n>txn</span><span class=p>.</span><span class=n>cookie</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>data</span><span class=p>.</span><span class=n>txn</span><span class=p>.</span><span class=n>code</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>status</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>data</span><span class=p>.</span><span class=n>txn</span><span class=p>.</span><span class=n>flags</span> <span class=o>=</span> <span class=n>TF_STATUS_CODE</span><span class=p>;</span>
        <span class=n>data</span><span class=p>.</span><span class=n>txn</span><span class=p>.</span><span class=n>data_size</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
        <span class=n>data</span><span class=p>.</span><span class=n>txn</span><span class=p>.</span><span class=n>offs_size</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
        <span class=n>data</span><span class=p>.</span><span class=n>txn</span><span class=p>.</span><span class=n>data</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>status</span><span class=p>;</span>
        <span class=n>data</span><span class=p>.</span><span class=n>txn</span><span class=p>.</span><span class=n>offs</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=n>data</span><span class=p>.</span><span class=n>txn</span><span class=p>.</span><span class=n>flags</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
        <span class=n>data</span><span class=p>.</span><span class=n>txn</span><span class=p>.</span><span class=n>data_size</span> <span class=o>=</span> <span class=n>reply</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>-</span> <span class=n>reply</span><span class=o>-&gt;</span><span class=n>data0</span><span class=p>;</span>
        <span class=n>data</span><span class=p>.</span><span class=n>txn</span><span class=p>.</span><span class=n>offs_size</span> <span class=o>=</span> <span class=p>((</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span> <span class=n>reply</span><span class=o>-&gt;</span><span class=n>offs</span><span class=p>)</span> <span class=o>-</span> <span class=p>((</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span> <span class=n>reply</span><span class=o>-&gt;</span><span class=n>offs0</span><span class=p>);</span>
        <span class=n>data</span><span class=p>.</span><span class=n>txn</span><span class=p>.</span><span class=n>data</span> <span class=o>=</span> <span class=n>reply</span><span class=o>-&gt;</span><span class=n>data0</span><span class=p>;</span>
        <span class=n>data</span><span class=p>.</span><span class=n>txn</span><span class=p>.</span><span class=n>offs</span> <span class=o>=</span> <span class=n>reply</span><span class=o>-&gt;</span><span class=n>offs0</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>binder_write</span><span class=p>(</span><span class=n>bs</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>data</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>data</span><span class=p>));</span>
<span class=p>}</span>
</code></pre></div> <p>从这里可以看出，<code>binder_send_reply</code>告诉Binder驱动程序执行<code>BC_FREE_BUFFER</code>和<code>BC_REPLY</code>命令，前者释放之前在<code>binder_transaction</code>分配的空间，地址为<code>buffer_to_free</code>，<code>buffer_to_free</code>这个地址是Binder驱动程序把自己在内核空间用的地址转换成用户空间地址再传给Service Manager的，所以Binder驱动程序拿到这个地址后，知道怎么样释放这个空间；后者告诉MediaPlayerService，它的addService操作已经完成了，错误码是0，保存在<code>data.txn.data</code>中。</p> <p>再来看上面函数最后调用的<code>binder_write</code>函数：</p> <div class=highlight><pre><span></span><code><span class=kt>int</span> <span class=nf>binder_write</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_state</span> <span class=o>*</span><span class=n>bs</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>data</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=n>len</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>struct</span> <span class=nc>binder_write_read</span> <span class=n>bwr</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>res</span><span class=p>;</span>
    <span class=n>bwr</span><span class=p>.</span><span class=n>write_size</span> <span class=o>=</span> <span class=n>len</span><span class=p>;</span>
    <span class=n>bwr</span><span class=p>.</span><span class=n>write_consumed</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>bwr</span><span class=p>.</span><span class=n>write_buffer</span> <span class=o>=</span> <span class=p>(</span><span class=kt>unsigned</span><span class=p>)</span> <span class=n>data</span><span class=p>;</span>
    <span class=n>bwr</span><span class=p>.</span><span class=n>read_size</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>bwr</span><span class=p>.</span><span class=n>read_consumed</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>bwr</span><span class=p>.</span><span class=n>read_buffer</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>res</span> <span class=o>=</span> <span class=n>ioctl</span><span class=p>(</span><span class=n>bs</span><span class=o>-&gt;</span><span class=n>fd</span><span class=p>,</span> <span class=n>BINDER_WRITE_READ</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>bwr</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>res</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&quot;binder_write: ioctl failed (%s)</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span>
                <span class=n>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=n>res</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>这里可以看出，只有写操作，没有读操作，即read_size为0。 </p> <p>这里又是一个<code>ioctl</code>的BINDER_WRITE_READ操作。直入到驱动程序的<code>binder_ioctl</code>函数后，执行BINDER_WRITE_READ命令，这里就不累述了。<br> 最后，从<code>binder_ioctl</code>执行到<code>binder_thread_write</code>函数，我们首先看第一个命令<code>BC_FREE_BUFFER</code>：</p> <div class=highlight><pre><span></span><code><span class=kt>int</span>
<span class=nf>binder_thread_write</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_proc</span> <span class=o>*</span><span class=n>proc</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>binder_thread</span> <span class=o>*</span><span class=kr>thread</span><span class=p>,</span>
                    <span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=n>buffer</span><span class=p>,</span> <span class=kt>int</span> <span class=n>size</span><span class=p>,</span> <span class=kt>signed</span> <span class=kt>long</span> <span class=o>*</span><span class=n>consumed</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>uint32_t</span> <span class=n>cmd</span><span class=p>;</span>
    <span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=n>ptr</span> <span class=o>=</span> <span class=n>buffer</span> <span class=o>+</span> <span class=o>*</span><span class=n>consumed</span><span class=p>;</span>
    <span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=n>end</span> <span class=o>=</span> <span class=n>buffer</span> <span class=o>+</span> <span class=n>size</span><span class=p>;</span>

    <span class=k>while</span> <span class=p>(</span><span class=n>ptr</span> <span class=o>&lt;</span> <span class=n>end</span> <span class=o>&amp;&amp;</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>return_error</span> <span class=o>==</span> <span class=n>BR_OK</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>get_user</span><span class=p>(</span><span class=n>cmd</span><span class=p>,</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>__user</span> <span class=o>*</span><span class=p>)</span><span class=n>ptr</span><span class=p>))</span>
            <span class=k>return</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
        <span class=n>ptr</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>_IOC_NR</span><span class=p>(</span><span class=n>cmd</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>ARRAY_SIZE</span><span class=p>(</span><span class=n>binder_stats</span><span class=p>.</span><span class=n>bc</span><span class=p>))</span> <span class=p>{</span>
            <span class=n>binder_stats</span><span class=p>.</span><span class=n>bc</span><span class=p>[</span><span class=n>_IOC_NR</span><span class=p>(</span><span class=n>cmd</span><span class=p>)]</span><span class=o>++</span><span class=p>;</span>
            <span class=n>proc</span><span class=o>-&gt;</span><span class=n>stats</span><span class=p>.</span><span class=n>bc</span><span class=p>[</span><span class=n>_IOC_NR</span><span class=p>(</span><span class=n>cmd</span><span class=p>)]</span><span class=o>++</span><span class=p>;</span>
            <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>stats</span><span class=p>.</span><span class=n>bc</span><span class=p>[</span><span class=n>_IOC_NR</span><span class=p>(</span><span class=n>cmd</span><span class=p>)]</span><span class=o>++</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=k>switch</span> <span class=p>(</span><span class=n>cmd</span><span class=p>)</span> <span class=p>{</span>
        <span class=p>......</span>
        <span class=k>case</span> <span class=nl>BC_FREE_BUFFER</span><span class=p>:</span> <span class=p>{</span>
            <span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=n>data_ptr</span><span class=p>;</span>
            <span class=k>struct</span> <span class=nc>binder_buffer</span> <span class=o>*</span><span class=n>buffer</span><span class=p>;</span>
            <span class=c1>// 获得要删除的Buffer的用户空间地址</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>get_user</span><span class=p>(</span><span class=n>data_ptr</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span> <span class=n>__user</span> <span class=o>*</span><span class=p>)</span><span class=n>ptr</span><span class=p>))</span>
                <span class=k>return</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
            <span class=n>ptr</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>);</span>
            <span class=c1>// 找到data_ptr地址对应的struct binder_buffer信息</span>
            <span class=n>buffer</span> <span class=o>=</span> <span class=n>binder_buffer_lookup</span><span class=p>(</span><span class=n>proc</span><span class=p>,</span> <span class=n>data_ptr</span><span class=p>);</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>buffer</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
                <span class=n>binder_user_error</span><span class=p>(</span><span class=s>&quot;binder: %d:%d &quot;</span>
                    <span class=s>&quot;BC_FREE_BUFFER u%p no match</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span>
                    <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=n>data_ptr</span><span class=p>);</span>
                <span class=k>break</span><span class=p>;</span>
            <span class=p>}</span>
            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>allow_user_free</span><span class=p>)</span> <span class=p>{</span>
                <span class=n>binder_user_error</span><span class=p>(</span><span class=s>&quot;binder: %d:%d &quot;</span>
                    <span class=s>&quot;BC_FREE_BUFFER u%p matched &quot;</span>
                    <span class=s>&quot;unreturned buffer</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span>
                    <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=n>data_ptr</span><span class=p>);</span>
                <span class=k>break</span><span class=p>;</span>
            <span class=p>}</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>binder_debug_mask</span> <span class=o>&amp;</span> <span class=n>BINDER_DEBUG_FREE_BUFFER</span><span class=p>)</span>
                <span class=n>printk</span><span class=p>(</span><span class=n>KERN_INFO</span> <span class=s>&quot;binder: %d:%d BC_FREE_BUFFER u%p found buffer %d for %s transaction</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span>
                <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=n>data_ptr</span><span class=p>,</span> <span class=n>buffer</span><span class=o>-&gt;</span><span class=n>debug_id</span><span class=p>,</span>
                <span class=n>buffer</span><span class=o>-&gt;</span><span class=n>transaction</span> <span class=o>?</span> <span class=s>&quot;active&quot;</span> <span class=o>:</span> <span class=s>&quot;finished&quot;</span><span class=p>);</span>

            <span class=k>if</span> <span class=p>(</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>transaction</span><span class=p>)</span> <span class=p>{</span>
                <span class=n>buffer</span><span class=o>-&gt;</span><span class=n>transaction</span><span class=o>-&gt;</span><span class=n>buffer</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
                <span class=n>buffer</span><span class=o>-&gt;</span><span class=n>transaction</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
            <span class=p>}</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>async_transaction</span> <span class=o>&amp;&amp;</span> <span class=n>buffer</span><span class=o>-&gt;</span><span class=n>target_node</span><span class=p>)</span> <span class=p>{</span>
                <span class=n>BUG_ON</span><span class=p>(</span><span class=o>!</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>target_node</span><span class=o>-&gt;</span><span class=n>has_async_transaction</span><span class=p>);</span>
                <span class=k>if</span> <span class=p>(</span><span class=n>list_empty</span><span class=p>(</span><span class=o>&amp;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>target_node</span><span class=o>-&gt;</span><span class=n>async_todo</span><span class=p>))</span>
                    <span class=n>buffer</span><span class=o>-&gt;</span><span class=n>target_node</span><span class=o>-&gt;</span><span class=n>has_async_transaction</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
                <span class=k>else</span>
                    <span class=n>list_move_tail</span><span class=p>(</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>target_node</span><span class=o>-&gt;</span><span class=n>async_todo</span><span class=p>.</span><span class=n>next</span><span class=p>,</span> <span class=o>&amp;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>);</span>
            <span class=p>}</span>
            <span class=c1>// 释放这块内存</span>
            <span class=n>binder_transaction_buffer_release</span><span class=p>(</span><span class=n>proc</span><span class=p>,</span> <span class=n>buffer</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
            <span class=n>binder_free_buf</span><span class=p>(</span><span class=n>proc</span><span class=p>,</span> <span class=n>buffer</span><span class=p>);</span>
            <span class=k>break</span><span class=p>;</span>
                             <span class=p>}</span>

        <span class=p>......</span>
        <span class=o>*</span><span class=n>consumed</span> <span class=o>=</span> <span class=n>ptr</span> <span class=o>-</span> <span class=n>buffer</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>首先通过看这个语句：<code>get_user(data_ptr, (void * __user *)ptr)</code>，这个是获得要删除的Buffer的用户空间地址，接着通过下面这个语句来找到这个地址对应的<code>struct binder_buffer</code>信息：</p> <div class=highlight><pre><span></span><code><span class=n>buffer</span> <span class=o>=</span> <span class=n>binder_buffer_lookup</span><span class=p>(</span><span class=n>proc</span><span class=p>,</span> <span class=n>data_ptr</span><span class=p>);</span>
</code></pre></div> <p>因为这个空间是前面在<code>binder_transaction</code>里面分配的，所以这里一定能找到。最后，就可以释放这块内存了：</p> <div class=highlight><pre><span></span><code><span class=n>binder_transaction_buffer_release</span><span class=p>(</span><span class=n>proc</span><span class=p>,</span> <span class=n>buffer</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
<span class=n>binder_free_buf</span><span class=p>(</span><span class=n>proc</span><span class=p>,</span> <span class=n>buffer</span><span class=p>);</span>
</code></pre></div> <p>再来看另外一个命令BC_REPLY：</p> <div class=highlight><pre><span></span><code><span class=k>case</span> <span class=nl>BC_TRANSACTION</span><span class=p>:</span>
<span class=k>case</span> <span class=nl>BC_REPLY</span><span class=p>:</span> <span class=p>{</span>
    <span class=k>struct</span> <span class=nc>binder_transaction_data</span> <span class=n>tr</span><span class=p>;</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>copy_from_user</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tr</span><span class=p>,</span> <span class=n>ptr</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>tr</span><span class=p>)))</span>
        <span class=k>return</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
    <span class=n>ptr</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>tr</span><span class=p>);</span>
    <span class=n>binder_transaction</span><span class=p>(</span><span class=n>proc</span><span class=p>,</span> <span class=kr>thread</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>tr</span><span class=p>,</span> <span class=n>cmd</span> <span class=o>==</span> <span class=n>BC_REPLY</span><span class=p>);</span>
    <span class=k>break</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>又再次进入到<code>binder_transaction</code>函数：</p> <div class=highlight><pre><span></span><code><span class=c1>// 此处reply=1</span>
<span class=k>static</span> <span class=kt>void</span>
<span class=n>binder_transaction</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_proc</span> <span class=o>*</span><span class=n>proc</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>binder_thread</span> <span class=o>*</span><span class=kr>thread</span><span class=p>,</span>
<span class=k>struct</span> <span class=nc>binder_transaction_data</span> <span class=o>*</span><span class=n>tr</span><span class=p>,</span> <span class=kt>int</span> <span class=n>reply</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>struct</span> <span class=nc>binder_transaction</span> <span class=o>*</span><span class=n>t</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>binder_work</span> <span class=o>*</span><span class=n>tcomplete</span><span class=p>;</span>
    <span class=kt>size_t</span> <span class=o>*</span><span class=n>offp</span><span class=p>,</span> <span class=o>*</span><span class=n>off_end</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>binder_proc</span> <span class=o>*</span><span class=n>target_proc</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>binder_thread</span> <span class=o>*</span><span class=n>target_thread</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>binder_node</span> <span class=o>*</span><span class=n>target_node</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>list_head</span> <span class=o>*</span><span class=n>target_list</span><span class=p>;</span>
    <span class=n>wait_queue_head_t</span> <span class=o>*</span><span class=n>target_wait</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>binder_transaction</span> <span class=o>*</span><span class=n>in_reply_to</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>binder_transaction_log_entry</span> <span class=o>*</span><span class=n>e</span><span class=p>;</span>
    <span class=kt>uint32_t</span> <span class=n>return_error</span><span class=p>;</span>

    <span class=p>......</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>reply</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>// 把处理完的事务取回来，存放在本地变量中</span>
        <span class=n>in_reply_to</span> <span class=o>=</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>transaction_stack</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>in_reply_to</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
            <span class=p>......</span>
            <span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_FAILED_REPLY</span><span class=p>;</span>
            <span class=k>goto</span> <span class=n>err_empty_call_stack</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=n>binder_set_nice</span><span class=p>(</span><span class=n>in_reply_to</span><span class=o>-&gt;</span><span class=n>saved_priority</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>in_reply_to</span><span class=o>-&gt;</span><span class=n>to_thread</span> <span class=o>!=</span> <span class=kr>thread</span><span class=p>)</span> <span class=p>{</span>
            <span class=p>.......</span>
            <span class=k>goto</span> <span class=n>err_bad_call_stack</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>transaction_stack</span> <span class=o>=</span> <span class=n>in_reply_to</span><span class=o>-&gt;</span><span class=n>to_parent</span><span class=p>;</span>
        <span class=c1>// 可以通过in_reply_to得到最终发出这个事务请求的线程</span>
        <span class=n>target_thread</span> <span class=o>=</span> <span class=n>in_reply_to</span><span class=o>-&gt;</span><span class=n>from</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>target_thread</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_DEAD_REPLY</span><span class=p>;</span>
            <span class=k>goto</span> <span class=n>err_dead_binder</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>target_thread</span><span class=o>-&gt;</span><span class=n>transaction_stack</span> <span class=o>!=</span> <span class=n>in_reply_to</span><span class=p>)</span> <span class=p>{</span>
            <span class=p>......</span>
            <span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_FAILED_REPLY</span><span class=p>;</span>
            <span class=n>in_reply_to</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
            <span class=n>target_thread</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
            <span class=k>goto</span> <span class=n>err_dead_binder</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=c1>// 可以通过in_reply_to得到最终发出这个事务请求的进程</span>
        <span class=n>target_proc</span> <span class=o>=</span> <span class=n>target_thread</span><span class=o>-&gt;</span><span class=n>proc</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=p>......</span>
    <span class=p>}</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>target_thread</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>e</span><span class=o>-&gt;</span><span class=n>to_thread</span> <span class=o>=</span> <span class=n>target_thread</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>;</span>
        <span class=c1>// 得到target_list和target_wait</span>
        <span class=n>target_list</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>target_thread</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>;</span>
        <span class=n>target_wait</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>target_thread</span><span class=o>-&gt;</span><span class=n>wait</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=p>......</span>
    <span class=p>}</span>

    <span class=cm>/* TODO: reuse incoming transaction for reply */</span>
    <span class=n>t</span> <span class=o>=</span> <span class=n>kzalloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=n>t</span><span class=p>),</span> <span class=n>GFP_KERNEL</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>t</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_FAILED_REPLY</span><span class=p>;</span>
        <span class=k>goto</span> <span class=n>err_alloc_t_failed</span><span class=p>;</span>
    <span class=p>}</span>


    <span class=n>tcomplete</span> <span class=o>=</span> <span class=n>kzalloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=n>tcomplete</span><span class=p>),</span> <span class=n>GFP_KERNEL</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>tcomplete</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_FAILED_REPLY</span><span class=p>;</span>
        <span class=k>goto</span> <span class=n>err_alloc_tcomplete_failed</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>reply</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=p>(</span><span class=n>tr</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>TF_ONE_WAY</span><span class=p>))</span>
        <span class=n>t</span><span class=o>-&gt;</span><span class=n>from</span> <span class=o>=</span> <span class=kr>thread</span><span class=p>;</span>
    <span class=k>else</span>
        <span class=n>t</span><span class=o>-&gt;</span><span class=n>from</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>sender_euid</span> <span class=o>=</span> <span class=n>proc</span><span class=o>-&gt;</span><span class=n>tsk</span><span class=o>-&gt;</span><span class=n>cred</span><span class=o>-&gt;</span><span class=n>euid</span><span class=p>;</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>to_proc</span> <span class=o>=</span> <span class=n>target_proc</span><span class=p>;</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>to_thread</span> <span class=o>=</span> <span class=n>target_thread</span><span class=p>;</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>code</span> <span class=o>=</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>code</span><span class=p>;</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>=</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>flags</span><span class=p>;</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>priority</span> <span class=o>=</span> <span class=n>task_nice</span><span class=p>(</span><span class=n>current</span><span class=p>);</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span> <span class=o>=</span> <span class=n>binder_alloc_buf</span><span class=p>(</span><span class=n>target_proc</span><span class=p>,</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>data_size</span><span class=p>,</span>
        <span class=n>tr</span><span class=o>-&gt;</span><span class=n>offsets_size</span><span class=p>,</span> <span class=o>!</span><span class=n>reply</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>TF_ONE_WAY</span><span class=p>));</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_FAILED_REPLY</span><span class=p>;</span>
        <span class=k>goto</span> <span class=n>err_binder_alloc_buf_failed</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>allow_user_free</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>debug_id</span> <span class=o>=</span> <span class=n>t</span><span class=o>-&gt;</span><span class=n>debug_id</span><span class=p>;</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>transaction</span> <span class=o>=</span> <span class=n>t</span><span class=p>;</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>target_node</span> <span class=o>=</span> <span class=n>target_node</span><span class=p>;</span>       <span class=c1>// NULL</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>target_node</span><span class=p>)</span>
        <span class=n>binder_inc_node</span><span class=p>(</span><span class=n>target_node</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>

    <span class=n>offp</span> <span class=o>=</span> <span class=p>(</span><span class=kt>size_t</span> <span class=o>*</span><span class=p>)(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>+</span> <span class=n>ALIGN</span><span class=p>(</span><span class=n>tr</span><span class=o>-&gt;</span><span class=n>data_size</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)));</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>copy_from_user</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>,</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>buffer</span><span class=p>,</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>data_size</span><span class=p>))</span> <span class=p>{</span>
        <span class=n>binder_user_error</span><span class=p>(</span><span class=s>&quot;binder: %d:%d got transaction with invalid &quot;</span>
            <span class=s>&quot;data ptr</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span> <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>);</span>
        <span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_FAILED_REPLY</span><span class=p>;</span>
        <span class=k>goto</span> <span class=n>err_copy_data_failed</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>copy_from_user</span><span class=p>(</span><span class=n>offp</span><span class=p>,</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>offsets</span><span class=p>,</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>offsets_size</span><span class=p>))</span> <span class=p>{</span>
        <span class=n>binder_user_error</span><span class=p>(</span><span class=s>&quot;binder: %d:%d got transaction with invalid &quot;</span>
            <span class=s>&quot;offsets ptr</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span> <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>);</span>
        <span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_FAILED_REPLY</span><span class=p>;</span>
        <span class=k>goto</span> <span class=n>err_copy_data_failed</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=p>......</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>reply</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>BUG_ON</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>async_transaction</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>);</span>
        <span class=c1>// pop传入的transaction</span>
        <span class=n>binder_pop_transaction</span><span class=p>(</span><span class=n>target_thread</span><span class=p>,</span> <span class=n>in_reply_to</span><span class=p>);</span>
    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>TF_ONE_WAY</span><span class=p>))</span> <span class=p>{</span>
        <span class=p>......</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=p>......</span>
    <span class=p>}</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>work</span><span class=p>.</span><span class=n>type</span> <span class=o>=</span> <span class=n>BINDER_WORK_TRANSACTION</span><span class=p>;</span>
    <span class=c1>// target_list就是MPS主线程的thread-&gt;todo队列</span>
    <span class=n>list_add_tail</span><span class=p>(</span><span class=o>&amp;</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>work</span><span class=p>.</span><span class=n>entry</span><span class=p>,</span> <span class=n>target_list</span><span class=p>);</span>
    <span class=n>tcomplete</span><span class=o>-&gt;</span><span class=n>type</span> <span class=o>=</span> <span class=n>BINDER_WORK_TRANSACTION_COMPLETE</span><span class=p>;</span>
    <span class=c1>// thread-&gt;todo是指SM中用来回复IServiceManager::addService请求的线程</span>
    <span class=n>list_add_tail</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tcomplete</span><span class=o>-&gt;</span><span class=n>entry</span><span class=p>,</span> <span class=o>&amp;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>);</span>
    <span class=c1>// 唤醒MPS的主线程</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>target_wait</span><span class=p>)</span>
        <span class=n>wake_up_interruptible</span><span class=p>(</span><span class=n>target_wait</span><span class=p>);</span>
    <span class=k>return</span><span class=p>;</span>
    <span class=p>......</span>
<span class=p>}</span>
</code></pre></div> <p>注意，这里的入参reply为1，我们忽略掉其它无关代码。</p> <p>在前面Service Manager正在<code>binder_thread_read</code>函数中被MediaPlayerService启动后进程唤醒后，在最后会把当前处理完的事务放在<code>thread-&gt;transaction_stack</code>中：</p> <div class=highlight><pre><span></span><code><span class=k>if</span> <span class=p>(</span><span class=n>cmd</span> <span class=o>==</span> <span class=n>BR_TRANSACTION</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>TF_ONE_WAY</span><span class=p>))</span> <span class=p>{</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>to_parent</span> <span class=o>=</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>transaction_stack</span><span class=p>;</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>to_thread</span> <span class=o>=</span> <span class=kr>thread</span><span class=p>;</span>
    <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>transaction_stack</span> <span class=o>=</span> <span class=n>t</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>所以这里首先是把它这个binder_transaction取回来，并且放在本地变量in_reply_to中：<code>in_reply_to = thread-&gt;transaction_stack;</code></p> <p>接着就可以通过in_reply_to得到最终发出这个事务请求的线程和进程：</p> <div class=highlight><pre><span></span><code><span class=n>target_thread</span> <span class=o>=</span> <span class=n>in_reply_to</span><span class=o>-&gt;</span><span class=n>from</span><span class=p>;</span>
<span class=n>target_proc</span> <span class=o>=</span> <span class=n>target_thread</span><span class=o>-&gt;</span><span class=n>proc</span><span class=p>;</span>
</code></pre></div> <p>然后得到target_list和target_wait：</p> <div class=highlight><pre><span></span><code><span class=n>target_list</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>target_thread</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>;</span>
<span class=n>target_wait</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>target_thread</span><span class=o>-&gt;</span><span class=n>wait</span><span class=p>;</span>
</code></pre></div> <p>接下来到for循环前面的代码之前已经分析过了，但是需要注意的是：这里target_node为NULL，因此，t-&gt;buffer-&gt;target_node也为NULL。</p> <p>函数本来有一个for循环，用来处理数据中的Binder对象，这里由于没有Binder对象，所以就略过了。到了下面这句代码：</p> <div class=highlight><pre><span></span><code><span class=n>binder_pop_transaction</span><span class=p>(</span><span class=n>target_thread</span><span class=p>,</span> <span class=n>in_reply_to</span><span class=p>);</span>
</code></pre></div> <p>看看这个方法做了什么：</p> <div class=highlight><pre><span></span><code><span class=k>static</span> <span class=kt>void</span>
<span class=n>binder_pop_transaction</span><span class=p>(</span>
    <span class=k>struct</span> <span class=nc>binder_thread</span> <span class=o>*</span><span class=n>target_thread</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>binder_transaction</span> <span class=o>*</span><span class=n>t</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>target_thread</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>BUG_ON</span><span class=p>(</span><span class=n>target_thread</span><span class=o>-&gt;</span><span class=n>transaction_stack</span> <span class=o>!=</span> <span class=n>t</span><span class=p>);</span>
        <span class=n>BUG_ON</span><span class=p>(</span><span class=n>target_thread</span><span class=o>-&gt;</span><span class=n>transaction_stack</span><span class=o>-&gt;</span><span class=n>from</span> <span class=o>!=</span> <span class=n>target_thread</span><span class=p>);</span>
        <span class=n>target_thread</span><span class=o>-&gt;</span><span class=n>transaction_stack</span> <span class=o>=</span>
            <span class=n>target_thread</span><span class=o>-&gt;</span><span class=n>transaction_stack</span><span class=o>-&gt;</span><span class=n>from_parent</span><span class=p>;</span>
        <span class=n>t</span><span class=o>-&gt;</span><span class=n>from</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>need_reply</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=p>)</span>
        <span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>transaction</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=n>kfree</span><span class=p>(</span><span class=n>t</span><span class=p>);</span>
    <span class=n>binder_stats</span><span class=p>.</span><span class=n>obj_deleted</span><span class=p>[</span><span class=n>BINDER_STAT_TRANSACTION</span><span class=p>]</span><span class=o>++</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>上面这个方法最终删掉了<code>t</code>也就是传入的<code>in_reply_to</code>。 </p> <p>回到<code>binder_transaction</code>函数：</p> <div class=highlight><pre><span></span><code><span class=n>t</span><span class=o>-&gt;</span><span class=n>work</span><span class=p>.</span><span class=n>type</span> <span class=o>=</span> <span class=n>BINDER_WORK_TRANSACTION</span><span class=p>;</span>
<span class=n>list_add_tail</span><span class=p>(</span><span class=o>&amp;</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>work</span><span class=p>.</span><span class=n>entry</span><span class=p>,</span> <span class=n>target_list</span><span class=p>);</span>
<span class=n>tcomplete</span><span class=o>-&gt;</span><span class=n>type</span> <span class=o>=</span> <span class=n>BINDER_WORK_TRANSACTION_COMPLETE</span><span class=p>;</span>
<span class=n>list_add_tail</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tcomplete</span><span class=o>-&gt;</span><span class=n>entry</span><span class=p>,</span> <span class=o>&amp;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>);</span>
</code></pre></div> <p>前面一样，分别把t和tcomplete分别放在target_list和thread-&gt;todo队列中，这里的target_list指的就是最初调用<code>IServiceManager::addService</code>的MediaPlayerService的Server主线程的的thread-&gt;todo队列了，而thread-&gt;todo指的是Service Manager中用来回复<code>IServiceManager::addService</code>请求的线程。 </p> <p>最后，唤醒等待在<code>target_wait</code>队列上的线程了，就是最初调用<code>IServiceManager::addService</code>的<code>MediaPlayerService</code>的Server主线程了，它最后在<code>binder_thread_read</code>函数中睡眠在<code>thread-&gt;wait</code>上，就是这里的<code>target_wait</code>了：</p> <div class=highlight><pre><span></span><code><span class=k>if</span> <span class=p>(</span><span class=n>target_wait</span><span class=p>)</span>
    <span class=n>wake_up_interruptible</span><span class=p>(</span><span class=n>target_wait</span><span class=p>);</span>
</code></pre></div> <p>这样，Service Manger回复调用<code>IServiceManager::addService</code>请求就算完成了，重新回到<code>frameworks/base/cmds/servicemanager/binder.c</code>文件中的<code>binder_loop</code>函数等待下一个Client请求的到来。事实上，Service Manger回到<code>binder_loop</code>函数再次执行ioctl函数时候，又会再次进入到<code>binder_thread_read</code>函数。这时个会发现<code>thread-&gt;todo</code>不为空，这是因为刚才我们调用了<code>list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);</code>。 </p> <p>把一个工作项<code>tcompelete</code>放在了在<code>thread-&gt;todo</code>中，这个<code>tcompelete</code>的type为<code>BINDER_WORK_TRANSACTION_COMPLETE</code>，因此，Binder驱动程序会执行下面操作：</p> <div class=highlight><pre><span></span><code><span class=k>case</span> <span class=nl>BINDER_WORK_TRANSACTION_COMPLETE</span><span class=p>:</span> <span class=p>{</span>
            <span class=n>cmd</span> <span class=o>=</span> <span class=n>BR_TRANSACTION_COMPLETE</span><span class=p>;</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>put_user</span><span class=p>(</span><span class=n>cmd</span><span class=p>,</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>__user</span> <span class=o>*</span><span class=p>)</span><span class=n>ptr</span><span class=p>))</span>
                <span class=k>return</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
            <span class=n>ptr</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>);</span>

            <span class=n>binder_stat_br</span><span class=p>(</span><span class=n>proc</span><span class=p>,</span> <span class=kr>thread</span><span class=p>,</span> <span class=n>cmd</span><span class=p>);</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>binder_debug_mask</span> <span class=o>&amp;</span> <span class=n>BINDER_DEBUG_TRANSACTION_COMPLETE</span><span class=p>)</span>
                <span class=n>printk</span><span class=p>(</span><span class=n>KERN_INFO</span> <span class=s>&quot;binder: %d:%d BR_TRANSACTION_COMPLETE</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span>
                       <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>);</span>

            <span class=n>list_del</span><span class=p>(</span><span class=o>&amp;</span><span class=n>w</span><span class=o>-&gt;</span><span class=n>entry</span><span class=p>);</span>
            <span class=n>kfree</span><span class=p>(</span><span class=n>w</span><span class=p>);</span>
            <span class=n>binder_stats</span><span class=p>.</span><span class=n>obj_deleted</span><span class=p>[</span><span class=n>BINDER_STAT_TRANSACTION_COMPLETE</span><span class=p>]</span><span class=o>++</span><span class=p>;</span>
        <span class=p>}</span> <span class=k>break</span><span class=p>;</span>
</code></pre></div> <p><code>binder_loop</code>函数执行完这个ioctl调用后，才会在下一次调用ioctl进入到Binder驱动程序进入休眠状态，等待下一次Client的请求。</p> <p>上面讲到调用<code>IServiceManager::addService</code>的MediaPlayerService的Server主线程被唤醒了，于是，重新执行<code>binder_thread_read</code>函数。 </p> <div class=highlight><pre><span></span><code><span class=k>static</span> <span class=kt>int</span>
<span class=n>binder_thread_read</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_proc</span> <span class=o>*</span><span class=n>proc</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>binder_thread</span> <span class=o>*</span><span class=kr>thread</span><span class=p>,</span>
                   <span class=kt>void</span>  <span class=n>__user</span> <span class=o>*</span><span class=n>buffer</span><span class=p>,</span> <span class=kt>int</span> <span class=n>size</span><span class=p>,</span> <span class=kt>signed</span> <span class=kt>long</span> <span class=o>*</span><span class=n>consumed</span><span class=p>,</span> <span class=kt>int</span> <span class=n>non_block</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=n>ptr</span> <span class=o>=</span> <span class=n>buffer</span> <span class=o>+</span> <span class=o>*</span><span class=n>consumed</span><span class=p>;</span>
    <span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=n>end</span> <span class=o>=</span> <span class=n>buffer</span> <span class=o>+</span> <span class=n>size</span><span class=p>;</span>

    <span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>wait_for_proc_work</span><span class=p>;</span>

    <span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=n>consumed</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>put_user</span><span class=p>(</span><span class=n>BR_NOOP</span><span class=p>,</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>__user</span> <span class=o>*</span><span class=p>)</span><span class=n>ptr</span><span class=p>))</span>
            <span class=k>return</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
        <span class=n>ptr</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>);</span>
    <span class=p>}</span>

<span class=nl>retry</span><span class=p>:</span>
    <span class=n>wait_for_proc_work</span> <span class=o>=</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>transaction_stack</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=o>&amp;&amp;</span> <span class=n>list_empty</span><span class=p>(</span><span class=o>&amp;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>);</span>

    <span class=p>......</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>wait_for_proc_work</span><span class=p>)</span> <span class=p>{</span>
        <span class=p>......</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>non_block</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>binder_has_thread_work</span><span class=p>(</span><span class=kr>thread</span><span class=p>))</span>
                <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>EAGAIN</span><span class=p>;</span>
        <span class=p>}</span> <span class=k>else</span>
            <span class=n>ret</span> <span class=o>=</span> <span class=n>wait_event_interruptible</span><span class=p>(</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>wait</span><span class=p>,</span> <span class=n>binder_has_thread_work</span><span class=p>(</span><span class=kr>thread</span><span class=p>));</span>
    <span class=p>}</span>

    <span class=p>......</span>

    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
        <span class=kt>uint32_t</span> <span class=n>cmd</span><span class=p>;</span>
        <span class=k>struct</span> <span class=nc>binder_transaction_data</span> <span class=n>tr</span><span class=p>;</span>
        <span class=k>struct</span> <span class=nc>binder_work</span> <span class=o>*</span><span class=n>w</span><span class=p>;</span>
        <span class=k>struct</span> <span class=nc>binder_transaction</span> <span class=o>*</span><span class=n>t</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>

        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>list_empty</span><span class=p>(</span><span class=o>&amp;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>))</span>
            <span class=c1>// 走这个分支</span>
            <span class=n>w</span> <span class=o>=</span> <span class=n>list_first_entry</span><span class=p>(</span><span class=o>&amp;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>binder_work</span><span class=p>,</span> <span class=n>entry</span><span class=p>);</span>
        <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=o>!</span><span class=n>list_empty</span><span class=p>(</span><span class=o>&amp;</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>wait_for_proc_work</span><span class=p>)</span>
            <span class=n>w</span> <span class=o>=</span> <span class=n>list_first_entry</span><span class=p>(</span><span class=o>&amp;</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>binder_work</span><span class=p>,</span> <span class=n>entry</span><span class=p>);</span>
        <span class=k>else</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>ptr</span> <span class=o>-</span> <span class=n>buffer</span> <span class=o>==</span> <span class=mi>4</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=p>(</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>looper</span> <span class=o>&amp;</span> <span class=n>BINDER_LOOPER_STATE_NEED_RETURN</span><span class=p>))</span> <span class=cm>/* no data added */</span>
                <span class=k>goto</span> <span class=n>retry</span><span class=p>;</span>
            <span class=k>break</span><span class=p>;</span>
        <span class=p>}</span>

        <span class=p>......</span>

        <span class=k>switch</span> <span class=p>(</span><span class=n>w</span><span class=o>-&gt;</span><span class=n>type</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>case</span> <span class=nl>BINDER_WORK_TRANSACTION</span><span class=p>:</span> <span class=p>{</span>
            <span class=n>t</span> <span class=o>=</span> <span class=n>container_of</span><span class=p>(</span><span class=n>w</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>binder_transaction</span><span class=p>,</span> <span class=n>work</span><span class=p>);</span>
                                      <span class=p>}</span> <span class=k>break</span><span class=p>;</span>
        <span class=p>......</span>
        <span class=p>}</span>

        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>t</span><span class=p>)</span>
            <span class=k>continue</span><span class=p>;</span>

        <span class=n>BUG_ON</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>target_node</span><span class=p>)</span> <span class=p>{</span>
            <span class=p>......</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=n>tr</span><span class=p>.</span><span class=n>target</span><span class=p>.</span><span class=n>ptr</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
            <span class=n>tr</span><span class=p>.</span><span class=n>cookie</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
            <span class=n>cmd</span> <span class=o>=</span> <span class=n>BR_REPLY</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=n>tr</span><span class=p>.</span><span class=n>code</span> <span class=o>=</span> <span class=n>t</span><span class=o>-&gt;</span><span class=n>code</span><span class=p>;</span>
        <span class=n>tr</span><span class=p>.</span><span class=n>flags</span> <span class=o>=</span> <span class=n>t</span><span class=o>-&gt;</span><span class=n>flags</span><span class=p>;</span>
        <span class=n>tr</span><span class=p>.</span><span class=n>sender_euid</span> <span class=o>=</span> <span class=n>t</span><span class=o>-&gt;</span><span class=n>sender_euid</span><span class=p>;</span>

        <span class=k>if</span> <span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>from</span><span class=p>)</span> <span class=p>{</span>
            <span class=p>......</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=n>tr</span><span class=p>.</span><span class=n>sender_pid</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
        <span class=p>}</span>

        <span class=n>tr</span><span class=p>.</span><span class=n>data_size</span> <span class=o>=</span> <span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>data_size</span><span class=p>;</span>
        <span class=n>tr</span><span class=p>.</span><span class=n>offsets_size</span> <span class=o>=</span> <span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>offsets_size</span><span class=p>;</span>
        <span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>buffer</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>+</span> <span class=n>proc</span><span class=o>-&gt;</span><span class=n>user_buffer_offset</span><span class=p>;</span>
        <span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>offsets</span> <span class=o>=</span> <span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>buffer</span> <span class=o>+</span> <span class=n>ALIGN</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>data_size</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>));</span>

        <span class=k>if</span> <span class=p>(</span><span class=n>put_user</span><span class=p>(</span><span class=n>cmd</span><span class=p>,</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>__user</span> <span class=o>*</span><span class=p>)</span><span class=n>ptr</span><span class=p>))</span>
            <span class=k>return</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
        <span class=n>ptr</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>copy_to_user</span><span class=p>(</span><span class=n>ptr</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>tr</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>tr</span><span class=p>)))</span>
            <span class=k>return</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
        <span class=n>ptr</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>tr</span><span class=p>);</span>

        <span class=p>......</span>

        <span class=n>list_del</span><span class=p>(</span><span class=o>&amp;</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>work</span><span class=p>.</span><span class=n>entry</span><span class=p>);</span>
        <span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>allow_user_free</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>cmd</span> <span class=o>==</span> <span class=n>BR_TRANSACTION</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>TF_ONE_WAY</span><span class=p>))</span> <span class=p>{</span>
            <span class=p>......</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>transaction</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
            <span class=n>kfree</span><span class=p>(</span><span class=n>t</span><span class=p>);</span>
            <span class=n>binder_stats</span><span class=p>.</span><span class=n>obj_deleted</span><span class=p>[</span><span class=n>BINDER_STAT_TRANSACTION</span><span class=p>]</span><span class=o>++</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=k>break</span><span class=p>;</span>
    <span class=p>}</span>

<span class=nl>done</span><span class=p>:</span>
    <span class=p>......</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>在函数的while循环中，从<code>thread-&gt;todo</code>得到<code>w</code>，<code>w-&gt;type</code>为<code>BINDER_WORK_TRANSACTION</code>，于是，得到<code>t</code>。从上面可以知道，Service Manager反回了一个0回来，写在<code>t-&gt;buffer-&gt;data</code>里面，现在把<code>t-&gt;buffer-&gt;data</code>加上<code>proc-&gt;user_buffer_offset</code>，得到用户空间地址，保存在<code>tr.data.ptr.buffer</code>里面，这样用户空间就可以访问这个返回码了。由于cmd不等于BR_TRANSACTION，这时就可以把t删除掉了，因为以后都不需要用了。 </p> <p>执行完这个函数后，就返回到<code>binder_ioctl</code>函数，执行下面语句，把数据返回给用户空间：</p> <div class=highlight><pre><span></span><code><span class=k>if</span> <span class=p>(</span><span class=n>copy_to_user</span><span class=p>(</span><span class=n>ubuf</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>bwr</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>bwr</span><span class=p>)))</span> <span class=p>{</span>
    <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
    <span class=k>goto</span> <span class=n>err</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>接着返回到用户空间<code>IPCThreadState::talkWithDriver</code>函数，最后返回到<code>IPCThreadState::waitForResponse</code>函数，最终执行到下面语句：</p> <div class=highlight><pre><span></span><code><span class=n>status_t</span> <span class=n>IPCThreadState</span><span class=o>::</span><span class=n>waitForResponse</span><span class=p>(</span><span class=n>Parcel</span> <span class=o>*</span><span class=n>reply</span><span class=p>,</span> <span class=n>status_t</span> <span class=o>*</span><span class=n>acquireResult</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>int32_t</span> <span class=n>cmd</span><span class=p>;</span>
    <span class=kt>int32_t</span> <span class=n>err</span><span class=p>;</span>

    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>((</span><span class=n>err</span><span class=o>=</span><span class=n>talkWithDriver</span><span class=p>())</span> <span class=o>&lt;</span> <span class=n>NO_ERROR</span><span class=p>)</span> <span class=k>break</span><span class=p>;</span>

        <span class=p>......</span>

        <span class=n>cmd</span> <span class=o>=</span> <span class=n>mIn</span><span class=p>.</span><span class=n>readInt32</span><span class=p>();</span>

        <span class=p>......</span>

        <span class=k>switch</span> <span class=p>(</span><span class=n>cmd</span><span class=p>)</span> <span class=p>{</span>
        <span class=p>......</span>
        <span class=k>case</span> <span class=nl>BR_REPLY</span><span class=p>:</span>
            <span class=p>{</span>
                <span class=n>binder_transaction_data</span> <span class=n>tr</span><span class=p>;</span>
                <span class=n>err</span> <span class=o>=</span> <span class=n>mIn</span><span class=p>.</span><span class=n>read</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tr</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>tr</span><span class=p>));</span>
                <span class=n>LOG_ASSERT</span><span class=p>(</span><span class=n>err</span> <span class=o>==</span> <span class=n>NO_ERROR</span><span class=p>,</span> <span class=s>&quot;Not enough command data for brREPLY&quot;</span><span class=p>);</span>
                <span class=k>if</span> <span class=p>(</span><span class=n>err</span> <span class=o>!=</span> <span class=n>NO_ERROR</span><span class=p>)</span> <span class=k>goto</span> <span class=n>finish</span><span class=p>;</span>

                <span class=k>if</span> <span class=p>(</span><span class=n>reply</span><span class=p>)</span> <span class=p>{</span>
                    <span class=k>if</span> <span class=p>((</span><span class=n>tr</span><span class=p>.</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>TF_STATUS_CODE</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
                        <span class=n>reply</span><span class=o>-&gt;</span><span class=n>ipcSetDataReference</span><span class=p>(</span>
                            <span class=n>reinterpret_cast</span><span class=o>&lt;</span><span class=k>const</span> <span class=kt>uint8_t</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>buffer</span><span class=p>),</span>
                            <span class=n>tr</span><span class=p>.</span><span class=n>data_size</span><span class=p>,</span>
                            <span class=n>reinterpret_cast</span><span class=o>&lt;</span><span class=k>const</span> <span class=kt>size_t</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>offsets</span><span class=p>),</span>
                            <span class=n>tr</span><span class=p>.</span><span class=n>offsets_size</span><span class=o>/</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>size_t</span><span class=p>),</span>
                            <span class=n>freeBuffer</span><span class=p>,</span> <span class=n>this</span><span class=p>);</span>
                    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
                        <span class=p>......</span>
                    <span class=p>}</span>
                <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
                    <span class=p>......</span>
                <span class=p>}</span>
            <span class=p>}</span>
            <span class=k>goto</span> <span class=n>finish</span><span class=p>;</span>

        <span class=p>......</span>
        <span class=p>}</span>
    <span class=p>}</span>

<span class=nl>finish</span><span class=p>:</span>
    <span class=p>......</span>
    <span class=k>return</span> <span class=n>err</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>注意，这里的tr.flags等于0，这个是在上面<code>binder_send_reply</code>函数里设置的。最终把结果保存在reply了：</p> <div class=highlight><pre><span></span><code><span class=n>reply</span><span class=o>-&gt;</span><span class=n>ipcSetDataReference</span><span class=p>(</span>
       <span class=n>reinterpret_cast</span><span class=o>&lt;</span><span class=k>const</span> <span class=kt>uint8_t</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>buffer</span><span class=p>),</span>
       <span class=n>tr</span><span class=p>.</span><span class=n>data_size</span><span class=p>,</span>
       <span class=n>reinterpret_cast</span><span class=o>&lt;</span><span class=k>const</span> <span class=kt>size_t</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>offsets</span><span class=p>),</span>
       <span class=n>tr</span><span class=p>.</span><span class=n>offsets_size</span><span class=o>/</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>size_t</span><span class=p>),</span>
       <span class=n>freeBuffer</span><span class=p>,</span> <span class=n>this</span><span class=p>);</span>
</code></pre></div> <p>从这里层层返回，最后回到<code>MediaPlayerService::instantiate</code>函数中。</p> <p>至此，<code>IServiceManager::addService</code>终于执行完毕了。这个过程非常复杂，但是如果我们能够深刻地理解这一过程，将能很好地理解Binder机制的设计思想和实现过程。这里，对<code>IServiceManager::addService</code>过程中MediaPlayerService、ServiceManager和BinderDriver之间的交互作一个小结：</p> <p><img alt=IServiceManager::addService的时序图 src=/assets/images/android/binder_service_manager_add_service_sequence.png></p> <p>回到frameworks/base/media/mediaserver/main_mediaserver.cpp文件中的main函数，接下去还要执行下面两个函数：</p> <div class=highlight><pre><span></span><code><span class=n>ProcessState</span><span class=o>::</span><span class=n>self</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>startThreadPool</span><span class=p>();</span>
<span class=n>IPCThreadState</span><span class=o>::</span><span class=n>self</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>joinThreadPool</span><span class=p>();</span>
</code></pre></div> <p>首先看<code>ProcessState::startThreadPool</code>函数的实现：</p> <div class=highlight><pre><span></span><code><span class=kt>void</span> <span class=n>ProcessState</span><span class=o>::</span><span class=n>startThreadPool</span><span class=p>()</span>
<span class=p>{</span>
    <span class=n>AutoMutex</span> <span class=nf>_l</span><span class=p>(</span><span class=n>mLock</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>mThreadPoolStarted</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>mThreadPoolStarted</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
        <span class=n>spawnPooledThread</span><span class=p>(</span><span class=nb>true</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div> <p>调用了<code>spwanPooledThread</code>：</p> <div class=highlight><pre><span></span><code><span class=kt>void</span> <span class=n>ProcessState</span><span class=o>::</span><span class=n>spawnPooledThread</span><span class=p>(</span><span class=kt>bool</span> <span class=n>isMain</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>mThreadPoolStarted</span><span class=p>)</span> <span class=p>{</span>
        <span class=kt>int32_t</span> <span class=n>s</span> <span class=o>=</span> <span class=n>android_atomic_add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>mThreadPoolSeq</span><span class=p>);</span>
        <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mi>32</span><span class=p>];</span>
        <span class=n>sprintf</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span> <span class=s>&quot;Binder Thread #%d&quot;</span><span class=p>,</span> <span class=n>s</span><span class=p>);</span>
        <span class=n>LOGV</span><span class=p>(</span><span class=s>&quot;Spawning new pooled thread, name=%s</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span> <span class=n>buf</span><span class=p>);</span>
        <span class=n>sp</span><span class=o>&lt;</span><span class=n>Thread</span><span class=o>&gt;</span> <span class=n>t</span> <span class=o>=</span> <span class=n>new</span> <span class=n>PoolThread</span><span class=p>(</span><span class=n>isMain</span><span class=p>);</span>
        <span class=n>t</span><span class=o>-&gt;</span><span class=n>run</span><span class=p>(</span><span class=n>buf</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div> <p>这里主要是创建一个线程，PoolThread继续Thread类，Thread类定义在frameworks/base/libs/utils/Threads.cpp文件中，其run函数最终调用子类的threadLoop函数，这里即为<code>PoolThread::threadLoop</code>函数：</p> <div class=highlight><pre><span></span><code><span class=n>virtual</span> <span class=kt>bool</span> <span class=n>threadLoop</span><span class=p>()</span>
<span class=p>{</span>
    <span class=n>IPCThreadState</span><span class=o>::</span><span class=n>self</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>joinThreadPool</span><span class=p>(</span><span class=n>mIsMain</span><span class=p>);</span>
    <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>这里和frameworks/base/media/mediaserver/main_mediaserver.cpp文件中的main函数一样，最终都是调用了<code>IPCThreadState::joinThreadPool</code>函数，它们两个都是true，一个参数是true，一个是默认值true。我们来看一下这个函数的实现：</p> <div class=highlight><pre><span></span><code><span class=kt>void</span> <span class=n>IPCThreadState</span><span class=o>::</span><span class=n>joinThreadPool</span><span class=p>(</span><span class=kt>bool</span> <span class=n>isMain</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>LOG_THREADPOOL</span><span class=p>(</span><span class=s>&quot;**** THREAD %p (PID %d) IS JOINING THE THREAD POOL</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>pthread_self</span><span class=p>(),</span> <span class=n>getpid</span><span class=p>());</span>

    <span class=n>mOut</span><span class=p>.</span><span class=n>writeInt32</span><span class=p>(</span><span class=n>isMain</span> <span class=o>?</span> <span class=nl>BC_ENTER_LOOPER</span> <span class=p>:</span> <span class=n>BC_REGISTER_LOOPER</span><span class=p>);</span>

    <span class=p>......</span>

    <span class=n>status_t</span> <span class=n>result</span><span class=p>;</span>
    <span class=k>do</span> <span class=p>{</span>
        <span class=kt>int32_t</span> <span class=n>cmd</span><span class=p>;</span>

        <span class=p>.......</span>

        <span class=c1>// now get the next command to be processed, waiting if necessary</span>
        <span class=n>result</span> <span class=o>=</span> <span class=n>talkWithDriver</span><span class=p>();</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>result</span> <span class=o>&gt;=</span> <span class=n>NO_ERROR</span><span class=p>)</span> <span class=p>{</span>
            <span class=kt>size_t</span> <span class=n>IN</span> <span class=o>=</span> <span class=n>mIn</span><span class=p>.</span><span class=n>dataAvail</span><span class=p>();</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>IN</span> <span class=o>&lt;</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int32_t</span><span class=p>))</span> <span class=k>continue</span><span class=p>;</span>
            <span class=n>cmd</span> <span class=o>=</span> <span class=n>mIn</span><span class=p>.</span><span class=n>readInt32</span><span class=p>();</span>
            <span class=p>......</span>
            <span class=p>}</span>

            <span class=n>result</span> <span class=o>=</span> <span class=n>executeCommand</span><span class=p>(</span><span class=n>cmd</span><span class=p>);</span>
        <span class=p>}</span>

        <span class=p>......</span>
    <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=n>result</span> <span class=o>!=</span> <span class=o>-</span><span class=n>ECONNREFUSED</span> <span class=o>&amp;&amp;</span> <span class=n>result</span> <span class=o>!=</span> <span class=o>-</span><span class=n>EBADF</span><span class=p>);</span>

    <span class=p>.......</span>

    <span class=n>mOut</span><span class=p>.</span><span class=n>writeInt32</span><span class=p>(</span><span class=n>BC_EXIT_LOOPER</span><span class=p>);</span>
    <span class=n>talkWithDriver</span><span class=p>(</span><span class=nb>false</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div> <p>这个函数最终是在一个无穷循环中，通过调用<code>talkWithDriver</code>函数来和Binder驱动程序进行交互，实际上就是调用<code>talkWithDriver</code>来等待Client的请求，然后再调用<code>executeCommand</code>来处理请求，而在<code>executeCommand</code>函数中，最终会调用<code>BBinder::transact</code>来真正处理Client的请求：</p> <div class=highlight><pre><span></span><code><span class=n>status_t</span> <span class=n>IPCThreadState</span><span class=o>::</span><span class=n>executeCommand</span><span class=p>(</span><span class=kt>int32_t</span> <span class=n>cmd</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>BBinder</span><span class=o>*</span> <span class=n>obj</span><span class=p>;</span>
    <span class=n>RefBase</span><span class=o>::</span><span class=n>weakref_type</span><span class=o>*</span> <span class=n>refs</span><span class=p>;</span>
    <span class=n>status_t</span> <span class=n>result</span> <span class=o>=</span> <span class=n>NO_ERROR</span><span class=p>;</span>

    <span class=k>switch</span> <span class=p>(</span><span class=n>cmd</span><span class=p>)</span> <span class=p>{</span>
    <span class=p>......</span>

    <span class=k>case</span> <span class=nl>BR_TRANSACTION</span><span class=p>:</span>
        <span class=p>{</span>
            <span class=n>binder_transaction_data</span> <span class=n>tr</span><span class=p>;</span>
            <span class=n>result</span> <span class=o>=</span> <span class=n>mIn</span><span class=p>.</span><span class=n>read</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tr</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>tr</span><span class=p>));</span>

            <span class=p>......</span>

            <span class=n>Parcel</span> <span class=n>reply</span><span class=p>;</span>

            <span class=p>......</span>

            <span class=k>if</span> <span class=p>(</span><span class=n>tr</span><span class=p>.</span><span class=n>target</span><span class=p>.</span><span class=n>ptr</span><span class=p>)</span> <span class=p>{</span>
                <span class=n>sp</span><span class=o>&lt;</span><span class=n>BBinder</span><span class=o>&gt;</span> <span class=n>b</span><span class=p>((</span><span class=n>BBinder</span><span class=o>*</span><span class=p>)</span><span class=n>tr</span><span class=p>.</span><span class=n>cookie</span><span class=p>);</span>
                <span class=k>const</span> <span class=n>status_t</span> <span class=n>error</span> <span class=o>=</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>transact</span><span class=p>(</span><span class=n>tr</span><span class=p>.</span><span class=n>code</span><span class=p>,</span> <span class=n>buffer</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>reply</span><span class=p>,</span> <span class=n>tr</span><span class=p>.</span><span class=n>flags</span><span class=p>);</span>
                <span class=k>if</span> <span class=p>(</span><span class=n>error</span> <span class=o>&lt;</span> <span class=n>NO_ERROR</span><span class=p>)</span> <span class=n>reply</span><span class=p>.</span><span class=n>setError</span><span class=p>(</span><span class=n>error</span><span class=p>);</span>

            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
                <span class=k>const</span> <span class=n>status_t</span> <span class=n>error</span> <span class=o>=</span> <span class=n>the_context_object</span><span class=o>-&gt;</span><span class=n>transact</span><span class=p>(</span><span class=n>tr</span><span class=p>.</span><span class=n>code</span><span class=p>,</span> <span class=n>buffer</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>reply</span><span class=p>,</span> <span class=n>tr</span><span class=p>.</span><span class=n>flags</span><span class=p>);</span>
                <span class=k>if</span> <span class=p>(</span><span class=n>error</span> <span class=o>&lt;</span> <span class=n>NO_ERROR</span><span class=p>)</span> <span class=n>reply</span><span class=p>.</span><span class=n>setError</span><span class=p>(</span><span class=n>error</span><span class=p>);</span>
            <span class=p>}</span>

            <span class=p>......</span>
        <span class=p>}</span>
        <span class=k>break</span><span class=p>;</span>

    <span class=p>.......</span>
    <span class=p>}</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>result</span> <span class=o>!=</span> <span class=n>NO_ERROR</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>mLastError</span> <span class=o>=</span> <span class=n>result</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>result</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>接下来再看一下<code>BBinder::transact</code>的实现：</p> <div class=highlight><pre><span></span><code><span class=n>status_t</span> <span class=n>BBinder</span><span class=o>::</span><span class=n>transact</span><span class=p>(</span>
    <span class=kt>uint32_t</span> <span class=n>code</span><span class=p>,</span> <span class=k>const</span> <span class=n>Parcel</span><span class=o>&amp;</span> <span class=n>data</span><span class=p>,</span> <span class=n>Parcel</span><span class=o>*</span> <span class=n>reply</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>flags</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>data</span><span class=p>.</span><span class=n>setDataPosition</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>

    <span class=n>status_t</span> <span class=n>err</span> <span class=o>=</span> <span class=n>NO_ERROR</span><span class=p>;</span>
    <span class=k>switch</span> <span class=p>(</span><span class=n>code</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>case</span> <span class=nl>PING_TRANSACTION</span><span class=p>:</span>
            <span class=n>reply</span><span class=o>-&gt;</span><span class=n>writeInt32</span><span class=p>(</span><span class=n>pingBinder</span><span class=p>());</span>
            <span class=k>break</span><span class=p>;</span>
        <span class=k>default</span><span class=o>:</span>
            <span class=n>err</span> <span class=o>=</span> <span class=n>onTransact</span><span class=p>(</span><span class=n>code</span><span class=p>,</span> <span class=n>data</span><span class=p>,</span> <span class=n>reply</span><span class=p>,</span> <span class=n>flags</span><span class=p>);</span>
            <span class=k>break</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>reply</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>reply</span><span class=o>-&gt;</span><span class=n>setDataPosition</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>err</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>最终会调用<code>onTransact</code>函数来处理。在这个场景中，<code>BnMediaPlayerService</code>继承了<code>BBinder</code>类，并且重载了<code>onTransact</code>函数，因此，这里实际上是调用了<code>BnMediaPlayerService::onTransact</code>函数，这个函数定义在frameworks/base/libs/media/libmedia/IMediaPlayerService.cpp文件中：</p> <div class=highlight><pre><span></span><code><span class=n>status_t</span> <span class=n>BnMediaPlayerService</span><span class=o>::</span><span class=n>onTransact</span><span class=p>(</span>
    <span class=kt>uint32_t</span> <span class=n>code</span><span class=p>,</span> <span class=k>const</span> <span class=n>Parcel</span><span class=o>&amp;</span> <span class=n>data</span><span class=p>,</span> <span class=n>Parcel</span><span class=o>*</span> <span class=n>reply</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>flags</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>switch</span><span class=p>(</span><span class=n>code</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>case</span> <span class=nl>CREATE_URL</span><span class=p>:</span> <span class=p>{</span>
            <span class=p>......</span>
                         <span class=p>}</span> <span class=k>break</span><span class=p>;</span>
        <span class=k>case</span> <span class=nl>CREATE_FD</span><span class=p>:</span> <span class=p>{</span>
            <span class=p>......</span>
                        <span class=p>}</span> <span class=k>break</span><span class=p>;</span>
        <span class=k>case</span> <span class=nl>DECODE_URL</span><span class=p>:</span> <span class=p>{</span>
            <span class=p>......</span>
                         <span class=p>}</span> <span class=k>break</span><span class=p>;</span>
        <span class=k>case</span> <span class=nl>DECODE_FD</span><span class=p>:</span> <span class=p>{</span>
            <span class=p>......</span>
                        <span class=p>}</span> <span class=k>break</span><span class=p>;</span>
        <span class=k>case</span> <span class=nl>CREATE_MEDIA_RECORDER</span><span class=p>:</span> <span class=p>{</span>
            <span class=p>......</span>
                                    <span class=p>}</span> <span class=k>break</span><span class=p>;</span>
        <span class=k>case</span> <span class=nl>CREATE_METADATA_RETRIEVER</span><span class=p>:</span> <span class=p>{</span>
            <span class=p>......</span>
                                        <span class=p>}</span> <span class=k>break</span><span class=p>;</span>
        <span class=k>case</span> <span class=nl>GET_OMX</span><span class=p>:</span> <span class=p>{</span>
            <span class=p>......</span>
                      <span class=p>}</span> <span class=k>break</span><span class=p>;</span>
        <span class=k>default</span><span class=o>:</span>
            <span class=k>return</span> <span class=n>BBinder</span><span class=o>::</span><span class=n>onTransact</span><span class=p>(</span><span class=n>code</span><span class=p>,</span> <span class=n>data</span><span class=p>,</span> <span class=n>reply</span><span class=p>,</span> <span class=n>flags</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div> <p>至此，我们就以MediaPlayerService为例，完整地介绍了Android系统进程间通信Binder机制中的Server启动过程。Server启动起来之后，就会在一个无穷循环中等待Client的请求了。</p> <h2 id=4-clientserver>4 <a href=https://blog.csdn.net/luoshengyang/article/details/6633311>Client如何获得Server的远程接口</a><a class=headerlink href=#4-clientserver title="Permanent link">&para;</a></h2> <p>我们将深入到Binder驱动程序源代码去分析Client是如何通过Service Manager的getService接口中来获得Server远程接口的。Client只有获得了Server的远程接口之后，才能进一步调用Server提供的服务。</p> <p>我们接着上面一节进行分析，此时Service Manager和MediaPlayerService已经启动完毕，Service Manager现在等待Client的请求。 </p> <p>这里，我们要举例子说明的Client便是MediaPlayer了，它声明和实现在frameworks/base/include/media/mediaplayer.h和frameworks/base/media/libmedia/mediaplayer.cpp文件中。MediaPlayer继承于IMediaDeathNotifier类，这个类声明和实现在frameworks/base/include/media/IMediaDeathNotifier.h和frameworks/base/media/libmedia//IMediaDeathNotifier.cpp文件中，里面有一个静态成员函数getMeidaPlayerService，它通过IServiceManager::getService接口来获得MediaPlayerService的远程接口。</p> <p>在介绍<code>IMediaDeathNotifier::getMediaPlayerService()</code>函数之前，我们先了解一下这个函数。<br> 在2.3节中我们知道，获取Service Manager远程接口时，最终是获得了一个BpServiceManager对象的IServiceManager接口。类似地，我们要获得MediaPlayerService的远程接口，实际上就是要获得一个称为BpMediaPlayerService对象的IMediaPlayerService接口。现在，我们就先来看一下BpMediaPlayerService的类图（2.3节中的是BnMediaPlayerService的类图）：</p> <p><a href=/assets/images/android/binder_bp_media_player_service.png><img alt=BpMediaPlayerService src=/assets/images/android/binder_bp_media_player_service.png></a></p> <p>从这个类图可以看到，BpMediaPlayerService继承于BpInterface<imediaplayerservice>类，即BpMediaPlayerService继承了IMediaPlayerService类和BpRefBase类，这两个类又分别继续了RefBase类。BpRefBase类有一个成员变量mRemote，它的类型为IBinder，实际是一个BpBinder对象。BpBinder类使用了IPCThreadState类来与Binder驱动程序进行交互，而IPCThreadState类有一个成员变量mProcess，它的类型为ProcessState，IPCThreadState类借助ProcessState类来打开Binder设备文件/dev/binder，因此，它可以和Binder驱动程序进行交互。</p> <p>BpMediaPlayerService的构造函数有一个参数impl，它的类型为const sp<ibinder>&amp;，从上面的描述中，这个实际上就是一个BpBinder对象。这样，要创建一个BpMediaPlayerService对象，首先就要有一个BpBinder对象。再来看BpBinder类的构造函数，它有一个参数handle，类型为int32_t，这个参数的意义就是请求MediaPlayerService这个远程接口的进程对MediaPlayerService这个Binder实体的引用了。因此，获取MediaPlayerService这个远程接口的本质问题就变为从Service Manager中获得MediaPlayerService的一个句柄了。</p> <p>现在，我们就来看一下<code>IMediaDeathNotifier::getMeidaPlayerService</code>的实现：</p> <div class=highlight><pre><span></span><code><span class=c1>// establish binder interface to MediaPlayerService</span>
<span class=cm>/*static*/</span><span class=k>const</span> <span class=n>sp</span><span class=o>&lt;</span><span class=n>IMediaPlayerService</span><span class=o>&gt;&amp;</span>
<span class=n>IMediaDeathNotifier</span><span class=o>::</span><span class=n>getMediaPlayerService</span><span class=p>()</span>
<span class=p>{</span>
    <span class=n>LOGV</span><span class=p>(</span><span class=s>&quot;getMediaPlayerService&quot;</span><span class=p>);</span>
    <span class=n>Mutex</span><span class=o>::</span><span class=n>Autolock</span> <span class=n>_l</span><span class=p>(</span><span class=n>sServiceLock</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>sMediaPlayerService</span><span class=p>.</span><span class=n>get</span><span class=p>()</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>// 获得SM的远程接口</span>
        <span class=n>sp</span><span class=o>&lt;</span><span class=n>IServiceManager</span><span class=o>&gt;</span> <span class=n>sm</span> <span class=o>=</span> <span class=n>defaultServiceManager</span><span class=p>();</span>
        <span class=n>sp</span><span class=o>&lt;</span><span class=n>IBinder</span><span class=o>&gt;</span> <span class=n>binder</span><span class=p>;</span>
        <span class=c1>// 在while循环中通过sm-&gt;getService获得MPS</span>
        <span class=k>do</span> <span class=p>{</span>
            <span class=c1>// 相当于binder = new BpBinder(handle);</span>
            <span class=n>binder</span> <span class=o>=</span> <span class=n>sm</span><span class=o>-&gt;</span><span class=n>getService</span><span class=p>(</span><span class=n>String16</span><span class=p>(</span><span class=s>&quot;media.player&quot;</span><span class=p>));</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>binder</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
                <span class=k>break</span><span class=p>;</span>
             <span class=p>}</span>
             <span class=n>LOGW</span><span class=p>(</span><span class=s>&quot;Media player service not published, waiting...&quot;</span><span class=p>);</span>
             <span class=n>usleep</span><span class=p>(</span><span class=mi>500000</span><span class=p>);</span> <span class=c1>// 0.5 s</span>
        <span class=p>}</span> <span class=k>while</span><span class=p>(</span><span class=nb>true</span><span class=p>);</span>

        <span class=k>if</span> <span class=p>(</span><span class=n>sDeathNotifier</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>sDeathNotifier</span> <span class=o>=</span> <span class=n>new</span> <span class=n>DeathNotifier</span><span class=p>();</span>
    <span class=p>}</span>
    <span class=n>binder</span><span class=o>-&gt;</span><span class=n>linkToDeath</span><span class=p>(</span><span class=n>sDeathNotifier</span><span class=p>);</span>
    <span class=c1>// 相当于sMediaPlayerService = new BpMediaPlayerService(new BpBinder(handle))</span>
    <span class=n>sMediaPlayerService</span> <span class=o>=</span> <span class=n>interface_cast</span><span class=o>&lt;</span><span class=n>IMediaPlayerService</span><span class=o>&gt;</span><span class=p>(</span><span class=n>binder</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=n>LOGE_IF</span><span class=p>(</span><span class=n>sMediaPlayerService</span> <span class=o>==</span> <span class=mi>0</span><span class=p>,</span> <span class=s>&quot;no media player service!?&quot;</span><span class=p>);</span>
    <span class=k>return</span> <span class=n>sMediaPlayerService</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>函数首先通过<code>defaultServiceManager</code>函数来获得Service Manager的远程接口，这个函数我们在上面分析过，相当于是</p> <div class=highlight><pre><span></span><code><span class=n>sp</span><span class=o>&lt;</span><span class=n>IServiceManager</span><span class=o>&gt;</span> <span class=n>sm</span> <span class=o>=</span> <span class=n>new</span> <span class=n>BpServiceManager</span><span class=p>(</span><span class=n>new</span> <span class=n>BpBinder</span><span class=p>(</span><span class=mi>0</span><span class=p>));</span>
</code></pre></div> <p>接下去的while循环是通过<code>sm-&gt;getService</code>接口来不断尝试获得名称为“media.player”的Service，即MediaPlayerService。<br> 为什么要通过这无穷循环来得MediaPlayerService呢？因为这时候MediaPlayerService可能还没有启动起来，所以这里如果发现取回来的binder接口为NULL，就睡眠0.5秒，然后再尝试获取，这是获取Service接口的标准做法。</p> <p>我们来看一下<code>BpServiceManager::getService</code>的实现：</p> <div class=highlight><pre><span></span><code><span class=n>class</span> <span class=nl>BpServiceManager</span> <span class=p>:</span> <span class=n>public</span> <span class=n>BpInterface</span><span class=o>&lt;</span><span class=n>IServiceManager</span><span class=o>&gt;</span>
<span class=p>{</span>
<span class=nl>public</span><span class=p>:</span>
    <span class=p>...</span>
    <span class=n>virtual</span> <span class=n>sp</span><span class=o>&lt;</span><span class=n>IBinder</span><span class=o>&gt;</span> <span class=n>getService</span><span class=p>(</span><span class=k>const</span> <span class=n>String16</span><span class=o>&amp;</span> <span class=n>name</span><span class=p>)</span> <span class=k>const</span>
    <span class=p>{</span>
        <span class=kt>unsigned</span> <span class=n>n</span><span class=p>;</span>
        <span class=k>for</span> <span class=p>(</span><span class=n>n</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>n</span> <span class=o>&lt;</span> <span class=mi>5</span><span class=p>;</span> <span class=n>n</span><span class=o>++</span><span class=p>){</span>
            <span class=n>sp</span><span class=o>&lt;</span><span class=n>IBinder</span><span class=o>&gt;</span> <span class=n>svc</span> <span class=o>=</span> <span class=n>checkService</span><span class=p>(</span><span class=n>name</span><span class=p>);</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>svc</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=k>return</span> <span class=n>svc</span><span class=p>;</span>
            <span class=n>LOGI</span><span class=p>(</span><span class=s>&quot;Waiting for sevice %s...</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span> <span class=n>String8</span><span class=p>(</span><span class=n>name</span><span class=p>).</span><span class=n>string</span><span class=p>());</span>
            <span class=n>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
        <span class=p>}</span>
        <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=n>virtual</span> <span class=n>sp</span><span class=o>&lt;</span><span class=n>IBinder</span><span class=o>&gt;</span> <span class=n>checkService</span><span class=p>(</span> <span class=k>const</span> <span class=n>String16</span><span class=o>&amp;</span> <span class=n>name</span><span class=p>)</span> <span class=k>const</span>
    <span class=p>{</span>
        <span class=n>Parcel</span> <span class=n>data</span><span class=p>,</span> <span class=n>reply</span><span class=p>;</span>
        <span class=n>data</span><span class=p>.</span><span class=n>writeInterfaceToken</span><span class=p>(</span><span class=n>IServiceManager</span><span class=o>::</span><span class=n>getInterfaceDescriptor</span><span class=p>());</span>
        <span class=n>data</span><span class=p>.</span><span class=n>writeString16</span><span class=p>(</span><span class=n>name</span><span class=p>);</span>
        <span class=n>remote</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>transact</span><span class=p>(</span><span class=n>CHECK_SERVICE_TRANSACTION</span><span class=p>,</span> <span class=n>data</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>reply</span><span class=p>);</span>
        <span class=k>return</span> <span class=n>reply</span><span class=p>.</span><span class=n>readStrongBinder</span><span class=p>();</span>
    <span class=p>}</span>
    <span class=p>...</span>
<span class=p>};</span>
</code></pre></div> <p><code>BpServiceManager::getService</code>通过<code>BpServiceManager::checkService</code>执行操作。 </p> <p>在<code>BpServiceManager::checkService</code>函数中，首先是通过<code>Parcel::writeInterfaceToken</code>往data写入一个RPC头，这个我们在2.4节中已经介绍过了，就是写往data里面写入了一个整数和一个字符串“android.os.IServiceManager”，Service Manager来处理CHECK_SERVICE_TRANSACTION请求之前，会先验证一下这个RPC头，看看是否正确。接着再往data写入一个字符串name，这里就是“media.player”了。回忆一下2.4节中，那里已经往Service Manager中注册了一个名字为“media.player”的MediaPlayerService。</p> <p>这里的<code>remote()</code>就是一个<code>BpBinder</code>，所以就进入到<code>BpBinder::transact</code>函数中了，这里又继续调用<code>IPCThreadState::transact</code>函数中。<br> 首先调用<code>writeTransactionData</code>写入要传输的数据到<code>mOut</code>中，这里<code>struct binder_transaction_data tr</code>里面的内容：handle = 0, code = CHECK_SERVICE_TRANSACTION, cmd = BC_TRANSACTION, data里面的数据分别为：</p> <div class=highlight><pre><span></span><code><span class=n>writeInt32</span><span class=p>(</span><span class=n>IPCThreadState</span><span class=o>::</span><span class=n>self</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>getStrictModePolicy</span><span class=p>()</span> <span class=o>|</span> <span class=n>STRICT_MODE_PENALTY_GATHER</span><span class=p>);</span>
<span class=n>writeString16</span><span class=p>(</span><span class=s>&quot;android.os.IServiceManager&quot;</span><span class=p>);</span>
<span class=n>writeString16</span><span class=p>(</span><span class=s>&quot;media.player&quot;</span><span class=p>);</span>
</code></pre></div> <p>这是在<code>BpServiceManager::checkService</code>函数里面写进去的，其中前两个是RPC头，Service Manager在收到这个请求时会验证这两个参数是否正确，这点前面也提到了。<code>IPCThread-&gt;getStrictModePolicy</code>默认返回0，<code>STRICT_MODE_PENALTY_GATHER</code>定义为：</p> <div class=highlight><pre><span></span><code><span class=c1>// Note: must be kept in sync with android/os/StrictMode.java&#39;s PENALTY_GATHER</span>
<span class=cp>#define STRICT_MODE_PENALTY_GATHER 0x100</span>
</code></pre></div> <p>我们不关心这个参数的含义，这不会影响我们分析下面的源代码，有兴趣的读者可以研究一下。这里要注意的是，要传输的参数不包含有Binder对象，因此<code>tr.offsets_size = 0</code>。要传输的参数最后写入到IPCThreadState的成员变量mOut中，包括cmd和tr两个数据。</p> <p>回到<code>IPCThreadState::transact</code>函数中，由于<code>(flags &amp; TF_ONE_WAY) == 0</code>为true，即这是一个同步请求，并且<code>reply != NULL</code>，最终调用：<code>err = waitForResponse(reply);</code>。进入到<code>waitForResponse</code>函数中：</p> <div class=highlight><pre><span></span><code><span class=n>status_t</span> <span class=n>IPCThreadState</span><span class=o>::</span><span class=n>waitForResponse</span><span class=p>(</span><span class=n>Parcel</span> <span class=o>*</span><span class=n>reply</span><span class=p>,</span> <span class=n>status_t</span> <span class=o>*</span><span class=n>acquireResult</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>int32_t</span> <span class=n>cmd</span><span class=p>;</span>
    <span class=kt>int32_t</span> <span class=n>err</span><span class=p>;</span>

    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>((</span><span class=n>err</span><span class=o>=</span><span class=n>talkWithDriver</span><span class=p>())</span> <span class=o>&lt;</span> <span class=n>NO_ERROR</span><span class=p>)</span> <span class=k>break</span><span class=p>;</span>
        <span class=n>err</span> <span class=o>=</span> <span class=n>mIn</span><span class=p>.</span><span class=n>errorCheck</span><span class=p>();</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>err</span> <span class=o>&lt;</span> <span class=n>NO_ERROR</span><span class=p>)</span> <span class=k>break</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>mIn</span><span class=p>.</span><span class=n>dataAvail</span><span class=p>()</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=k>continue</span><span class=p>;</span>

        <span class=n>cmd</span> <span class=o>=</span> <span class=n>mIn</span><span class=p>.</span><span class=n>readInt32</span><span class=p>();</span>

        <span class=n>IF_LOG_COMMANDS</span><span class=p>()</span> <span class=p>{</span>
            <span class=n>alog</span> <span class=o>&lt;&lt;</span> <span class=s>&quot;Processing waitForResponse Command: &quot;</span>
            <span class=o>&lt;&lt;</span> <span class=n>getReturnString</span><span class=p>(</span><span class=n>cmd</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
        <span class=p>}</span>

        <span class=k>switch</span> <span class=p>(</span><span class=n>cmd</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>case</span> <span class=nl>BR_TRANSACTION_COMPLETE</span><span class=p>:</span>
                <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>reply</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>acquireResult</span><span class=p>)</span> <span class=k>goto</span> <span class=n>finish</span><span class=p>;</span>
                <span class=k>break</span><span class=p>;</span>

            <span class=k>case</span> <span class=nl>BR_DEAD_REPLY</span><span class=p>:</span>
                <span class=n>err</span> <span class=o>=</span> <span class=n>DEAD_OBJECT</span><span class=p>;</span>
                <span class=k>goto</span> <span class=n>finish</span><span class=p>;</span>

            <span class=k>case</span> <span class=nl>BR_FAILED_REPLY</span><span class=p>:</span>
                <span class=n>err</span> <span class=o>=</span> <span class=n>FAILED_TRANSACTION</span><span class=p>;</span>
                <span class=k>goto</span> <span class=n>finish</span><span class=p>;</span>

            <span class=k>case</span> <span class=nl>BR_ACQUIRE_RESULT</span><span class=p>:</span>
            <span class=p>{</span>
                <span class=n>LOG_ASSERT</span><span class=p>(</span><span class=n>acquireResult</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>,</span> <span class=s>&quot;Unexpected brACQUIRE_RESULT&quot;</span><span class=p>);</span>
                <span class=k>const</span> <span class=kt>int32_t</span> <span class=n>result</span> <span class=o>=</span> <span class=n>mIn</span><span class=p>.</span><span class=n>readInt32</span><span class=p>();</span>
                <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>acquireResult</span><span class=p>)</span> <span class=k>continue</span><span class=p>;</span>
                <span class=o>*</span><span class=n>acquireResult</span> <span class=o>=</span> <span class=n>result</span> <span class=o>?</span> <span class=nl>NO_ERROR</span> <span class=p>:</span> <span class=n>INVALID_OPERATION</span><span class=p>;</span>
            <span class=p>}</span>
                <span class=k>goto</span> <span class=n>finish</span><span class=p>;</span>

            <span class=k>case</span> <span class=nl>BR_REPLY</span><span class=p>:</span>
            <span class=p>{</span>
                <span class=n>binder_transaction_data</span> <span class=n>tr</span><span class=p>;</span>
                <span class=n>err</span> <span class=o>=</span> <span class=n>mIn</span><span class=p>.</span><span class=n>read</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tr</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>tr</span><span class=p>));</span>
                <span class=n>LOG_ASSERT</span><span class=p>(</span><span class=n>err</span> <span class=o>==</span> <span class=n>NO_ERROR</span><span class=p>,</span> <span class=s>&quot;Not enough command data for brREPLY&quot;</span><span class=p>);</span>
                <span class=k>if</span> <span class=p>(</span><span class=n>err</span> <span class=o>!=</span> <span class=n>NO_ERROR</span><span class=p>)</span> <span class=k>goto</span> <span class=n>finish</span><span class=p>;</span>

                <span class=k>if</span> <span class=p>(</span><span class=n>reply</span><span class=p>)</span> <span class=p>{</span>
                    <span class=k>if</span> <span class=p>((</span><span class=n>tr</span><span class=p>.</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>TF_STATUS_CODE</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
                        <span class=n>reply</span><span class=o>-&gt;</span><span class=n>ipcSetDataReference</span><span class=p>(</span>
                                                    <span class=n>reinterpret_cast</span><span class=o>&lt;</span><span class=k>const</span> <span class=kt>uint8_t</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>buffer</span><span class=p>),</span>
                                                    <span class=n>tr</span><span class=p>.</span><span class=n>data_size</span><span class=p>,</span>
                                                    <span class=n>reinterpret_cast</span><span class=o>&lt;</span><span class=k>const</span> <span class=kt>size_t</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>offsets</span><span class=p>),</span>
                                                    <span class=n>tr</span><span class=p>.</span><span class=n>offsets_size</span><span class=o>/</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>size_t</span><span class=p>),</span>
                                                    <span class=n>freeBuffer</span><span class=p>,</span> <span class=n>this</span><span class=p>);</span>
                    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
                        <span class=n>err</span> <span class=o>=</span> <span class=o>*</span><span class=n>static_cast</span><span class=o>&lt;</span><span class=k>const</span> <span class=n>status_t</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>buffer</span><span class=p>);</span>
                        <span class=n>freeBuffer</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span>
                                    <span class=n>reinterpret_cast</span><span class=o>&lt;</span><span class=k>const</span> <span class=kt>uint8_t</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>buffer</span><span class=p>),</span>
                                    <span class=n>tr</span><span class=p>.</span><span class=n>data_size</span><span class=p>,</span>
                                    <span class=n>reinterpret_cast</span><span class=o>&lt;</span><span class=k>const</span> <span class=kt>size_t</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>offsets</span><span class=p>),</span>
                                    <span class=n>tr</span><span class=p>.</span><span class=n>offsets_size</span><span class=o>/</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>size_t</span><span class=p>),</span> <span class=n>this</span><span class=p>);</span>
                    <span class=p>}</span>
                <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
                    <span class=n>freeBuffer</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span>
                                <span class=n>reinterpret_cast</span><span class=o>&lt;</span><span class=k>const</span> <span class=kt>uint8_t</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>buffer</span><span class=p>),</span>
                                <span class=n>tr</span><span class=p>.</span><span class=n>data_size</span><span class=p>,</span>
                                <span class=n>reinterpret_cast</span><span class=o>&lt;</span><span class=k>const</span> <span class=kt>size_t</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>offsets</span><span class=p>),</span>
                                <span class=n>tr</span><span class=p>.</span><span class=n>offsets_size</span><span class=o>/</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>size_t</span><span class=p>),</span> <span class=n>this</span><span class=p>);</span>
                    <span class=k>continue</span><span class=p>;</span>
                <span class=p>}</span>
            <span class=p>}</span>
                <span class=k>goto</span> <span class=n>finish</span><span class=p>;</span>

            <span class=k>default</span><span class=o>:</span>
                <span class=n>err</span> <span class=o>=</span> <span class=n>executeCommand</span><span class=p>(</span><span class=n>cmd</span><span class=p>);</span>
                <span class=k>if</span> <span class=p>(</span><span class=n>err</span> <span class=o>!=</span> <span class=n>NO_ERROR</span><span class=p>)</span> <span class=k>goto</span> <span class=n>finish</span><span class=p>;</span>
                <span class=k>break</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>

<span class=nl>finish</span><span class=p>:</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>err</span> <span class=o>!=</span> <span class=n>NO_ERROR</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>acquireResult</span><span class=p>)</span> <span class=o>*</span><span class=n>acquireResult</span> <span class=o>=</span> <span class=n>err</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>reply</span><span class=p>)</span> <span class=n>reply</span><span class=o>-&gt;</span><span class=n>setError</span><span class=p>(</span><span class=n>err</span><span class=p>);</span>
        <span class=n>mLastError</span> <span class=o>=</span> <span class=n>err</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>err</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>这个函数通过<code>IPCThreadState::talkWithDriver</code>与驱动程序进行交互：</p> <div class=highlight><pre><span></span><code><span class=n>status_t</span> <span class=n>IPCThreadState</span><span class=o>::</span><span class=n>talkWithDriver</span><span class=p>(</span><span class=kt>bool</span> <span class=n>doReceive</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>LOG_ASSERT</span><span class=p>(</span><span class=n>mProcess</span><span class=o>-&gt;</span><span class=n>mDriverFD</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>,</span> <span class=s>&quot;Binder driver is not opened&quot;</span><span class=p>);</span>

    <span class=n>binder_write_read</span> <span class=n>bwr</span><span class=p>;</span>

    <span class=c1>// Is the read buffer empty?</span>
    <span class=k>const</span> <span class=kt>bool</span> <span class=n>needRead</span> <span class=o>=</span> <span class=n>mIn</span><span class=p>.</span><span class=n>dataPosition</span><span class=p>()</span> <span class=o>&gt;=</span> <span class=n>mIn</span><span class=p>.</span><span class=n>dataSize</span><span class=p>();</span>

    <span class=c1>// We don&#39;t want to write anything if we are still reading</span>
    <span class=c1>// from data left in the input buffer and the caller</span>
    <span class=c1>// has requested to read the next data.</span>
    <span class=k>const</span> <span class=kt>size_t</span> <span class=n>outAvail</span> <span class=o>=</span> <span class=p>(</span><span class=o>!</span><span class=n>doReceive</span> <span class=o>||</span> <span class=n>needRead</span><span class=p>)</span> <span class=o>?</span> <span class=n>mOut</span><span class=p>.</span><span class=n>dataSize</span><span class=p>()</span> <span class=o>:</span> <span class=mi>0</span><span class=p>;</span>

    <span class=n>bwr</span><span class=p>.</span><span class=n>write_size</span> <span class=o>=</span> <span class=n>outAvail</span><span class=p>;</span>
    <span class=n>bwr</span><span class=p>.</span><span class=n>write_buffer</span> <span class=o>=</span> <span class=p>(</span><span class=kt>long</span> <span class=kt>unsigned</span> <span class=kt>int</span><span class=p>)</span><span class=n>mOut</span><span class=p>.</span><span class=n>data</span><span class=p>();</span>

    <span class=c1>// This is what we&#39;ll read.</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>doReceive</span> <span class=o>&amp;&amp;</span> <span class=n>needRead</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>bwr</span><span class=p>.</span><span class=n>read_size</span> <span class=o>=</span> <span class=n>mIn</span><span class=p>.</span><span class=n>dataCapacity</span><span class=p>();</span>
        <span class=n>bwr</span><span class=p>.</span><span class=n>read_buffer</span> <span class=o>=</span> <span class=p>(</span><span class=kt>long</span> <span class=kt>unsigned</span> <span class=kt>int</span><span class=p>)</span><span class=n>mIn</span><span class=p>.</span><span class=n>data</span><span class=p>();</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=n>bwr</span><span class=p>.</span><span class=n>read_size</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=c1>// Return immediately if there is nothing to do.</span>
    <span class=k>if</span> <span class=p>((</span><span class=n>bwr</span><span class=p>.</span><span class=n>write_size</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>bwr</span><span class=p>.</span><span class=n>read_size</span> <span class=o>==</span> <span class=mi>0</span><span class=p>))</span> <span class=k>return</span> <span class=n>NO_ERROR</span><span class=p>;</span>

    <span class=n>bwr</span><span class=p>.</span><span class=n>write_consumed</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>bwr</span><span class=p>.</span><span class=n>read_consumed</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>status_t</span> <span class=n>err</span><span class=p>;</span>
    <span class=k>do</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>ioctl</span><span class=p>(</span><span class=n>mProcess</span><span class=o>-&gt;</span><span class=n>mDriverFD</span><span class=p>,</span> <span class=n>BINDER_WRITE_READ</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>bwr</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>)</span>
            <span class=n>err</span> <span class=o>=</span> <span class=n>NO_ERROR</span><span class=p>;</span>
        <span class=k>else</span>
            <span class=n>err</span> <span class=o>=</span> <span class=o>-</span><span class=n>errno</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=n>err</span> <span class=o>==</span> <span class=o>-</span><span class=n>EINTR</span><span class=p>);</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>err</span> <span class=o>&gt;=</span> <span class=n>NO_ERROR</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>bwr</span><span class=p>.</span><span class=n>write_consumed</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>bwr</span><span class=p>.</span><span class=n>write_consumed</span> <span class=o>&lt;</span> <span class=p>(</span><span class=kt>ssize_t</span><span class=p>)</span><span class=n>mOut</span><span class=p>.</span><span class=n>dataSize</span><span class=p>())</span>
                <span class=n>mOut</span><span class=p>.</span><span class=n>remove</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>bwr</span><span class=p>.</span><span class=n>write_consumed</span><span class=p>);</span>
            <span class=k>else</span>
                <span class=n>mOut</span><span class=p>.</span><span class=n>setDataSize</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
        <span class=p>}</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>bwr</span><span class=p>.</span><span class=n>read_consumed</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>mIn</span><span class=p>.</span><span class=n>setDataSize</span><span class=p>(</span><span class=n>bwr</span><span class=p>.</span><span class=n>read_consumed</span><span class=p>);</span>
            <span class=n>mIn</span><span class=p>.</span><span class=n>setDataPosition</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
        <span class=p>}</span>

        <span class=k>return</span> <span class=n>NO_ERROR</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>err</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>这里<code>doReceive</code>默认值为true，<code>needRead</code>显然为true，所以<code>outAvail</code>大于0，即<code>bwr.write_size &gt; 0</code>；<code>bwr.read_size = mIn.dataCapacity()</code>显然大于0。<br> 函数最后通过<code>ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr)</code>进入到Binder驱动程序的<code>binder_ioctl</code>函数中。<br> <code>BINDER_WRITE_READ</code>相关代码在已经在本文中贴出很多次了，这里略过。<br> 因为<code>bwr.write_size</code>是大于0的，因此进入<code>binder_thread_write</code>函数中，我们关注<code>BC_TRANSACTION</code>相关的逻辑（这部分也贴出过很多次了）。 </p> <p>函数中先把用户传出来的参数拷贝到本地变量<code>struct binder_transaction_data br</code>中，也就是前面在<code>IPCThreadState::writeTransactionData</code>写入的内容。接着进入到<code>binder_transaction</code>函数中。</p> <p>在该函数中，这里的参数reply = 0，表示这是一个BC_TRANSACTION命令。<br> 前面我们提到，传给驱动程序的handle值为0，即这里的<code>tr-&gt;target.handle = 0</code>，表示请求的目标Binder对象是Service Manager，因此有以下赋值：</p> <div class=highlight><pre><span></span><code><span class=n>target_node</span> <span class=o>=</span> <span class=n>binder_context_mgr_node</span><span class=p>;</span>
<span class=n>target_proc</span> <span class=o>=</span> <span class=n>target_node</span><span class=o>-&gt;</span><span class=n>proc</span><span class=p>;</span>
<span class=n>target_list</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>target_proc</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>;</span>
<span class=n>target_wait</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>target_proc</span><span class=o>-&gt;</span><span class=n>wait</span><span class=p>;</span>
</code></pre></div> <p>其中binder_context_mgr_node是在Service Manager通知Binder驱动程序它是守护过程时创建的。</p> <p>接着创建一个待完成事项tcomplete，它的类型为struct binder_work，这是等一会要保存在当前线程的todo队列去的，表示当前线程有一个待完成的事务。紧跟着创建一个待处理事务t，它的类型为struct binder_transaction，这是等一会要存在到Service Manager的todo队列去的，表示Service Manager当前有一个事务需要处理。同时，最后这个待处理事务t也要存放在当前线程的待完成事务transaction_stack列表中去。</p> <div class=highlight><pre><span></span><code><span class=n>t</span><span class=o>-&gt;</span><span class=n>from_parent</span> <span class=o>=</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>transaction_stack</span><span class=p>;</span>
<span class=kr>thread</span><span class=o>-&gt;</span><span class=n>transaction_stack</span> <span class=o>=</span> <span class=n>t</span><span class=p>;</span>
</code></pre></div> <p>最后，Service Manager有事情可做了，就要唤醒它了：<code>wake_up_interruptible(target_wait);</code>。</p> <p>前面我们提到，此时Service Manager正在等待Client的请求，也就是Service Manager此时正在进入到Binder驱动程序的binder_thread_read函数中，并且休眠在target-&gt;wait上，详情在2.2节。</p> <p>这里，我们暂时忽略Service Manager被唤醒之后的情景，继续看当前线程的执行。<br> 函数<code>binder_transaction</code>执行完成之后，就一路返回到<code>binder_ioctl</code>函数里去了。函数<code>binder_ioctl</code>从<code>binder_thread_write</code>函数调用处返回后，发现<code>bwr.read_size</code>大于0，于是就进入到<code>binder_thread_read</code>函数去了。</p> <div class=highlight><pre><span></span><code><span class=k>static</span> <span class=kt>int</span>
<span class=n>binder_thread_read</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_proc</span> <span class=o>*</span><span class=n>proc</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>binder_thread</span> <span class=o>*</span><span class=kr>thread</span><span class=p>,</span>
                   <span class=kt>void</span>  <span class=n>__user</span> <span class=o>*</span><span class=n>buffer</span><span class=p>,</span> <span class=kt>int</span> <span class=n>size</span><span class=p>,</span> <span class=kt>signed</span> <span class=kt>long</span> <span class=o>*</span><span class=n>consumed</span><span class=p>,</span> <span class=kt>int</span> <span class=n>non_block</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=n>ptr</span> <span class=o>=</span> <span class=n>buffer</span> <span class=o>+</span> <span class=o>*</span><span class=n>consumed</span><span class=p>;</span>
    <span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=n>end</span> <span class=o>=</span> <span class=n>buffer</span> <span class=o>+</span> <span class=n>size</span><span class=p>;</span>

    <span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>wait_for_proc_work</span><span class=p>;</span>

    <span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=n>consumed</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>put_user</span><span class=p>(</span><span class=n>BR_NOOP</span><span class=p>,</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>__user</span> <span class=o>*</span><span class=p>)</span><span class=n>ptr</span><span class=p>))</span>
            <span class=k>return</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
        <span class=n>ptr</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>);</span>
    <span class=p>}</span>

<span class=nl>retry</span><span class=p>:</span>
    <span class=n>wait_for_proc_work</span> <span class=o>=</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>transaction_stack</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=o>&amp;&amp;</span> <span class=n>list_empty</span><span class=p>(</span><span class=o>&amp;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>);</span>

    <span class=p>......</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>wait_for_proc_work</span><span class=p>)</span> <span class=p>{</span>
        <span class=p>......</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>non_block</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>binder_has_thread_work</span><span class=p>(</span><span class=kr>thread</span><span class=p>))</span>
                <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>EAGAIN</span><span class=p>;</span>
        <span class=p>}</span> <span class=k>else</span>
            <span class=n>ret</span> <span class=o>=</span> <span class=n>wait_event_interruptible</span><span class=p>(</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>wait</span><span class=p>,</span> <span class=n>binder_has_thread_work</span><span class=p>(</span><span class=kr>thread</span><span class=p>));</span>
    <span class=p>}</span>

    <span class=p>......</span>

    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
        <span class=kt>uint32_t</span> <span class=n>cmd</span><span class=p>;</span>
        <span class=k>struct</span> <span class=nc>binder_transaction_data</span> <span class=n>tr</span><span class=p>;</span>
        <span class=k>struct</span> <span class=nc>binder_work</span> <span class=o>*</span><span class=n>w</span><span class=p>;</span>
        <span class=k>struct</span> <span class=nc>binder_transaction</span> <span class=o>*</span><span class=n>t</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>

        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>list_empty</span><span class=p>(</span><span class=o>&amp;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>))</span>
            <span class=n>w</span> <span class=o>=</span> <span class=n>list_first_entry</span><span class=p>(</span><span class=o>&amp;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>binder_work</span><span class=p>,</span> <span class=n>entry</span><span class=p>);</span>
        <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=o>!</span><span class=n>list_empty</span><span class=p>(</span><span class=o>&amp;</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>wait_for_proc_work</span><span class=p>)</span>
            <span class=n>w</span> <span class=o>=</span> <span class=n>list_first_entry</span><span class=p>(</span><span class=o>&amp;</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>binder_work</span><span class=p>,</span> <span class=n>entry</span><span class=p>);</span>
        <span class=k>else</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>ptr</span> <span class=o>-</span> <span class=n>buffer</span> <span class=o>==</span> <span class=mi>4</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=p>(</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>looper</span> <span class=o>&amp;</span> <span class=n>BINDER_LOOPER_STATE_NEED_RETURN</span><span class=p>))</span> <span class=cm>/* no data added */</span>
                <span class=k>goto</span> <span class=n>retry</span><span class=p>;</span>
            <span class=k>break</span><span class=p>;</span>
        <span class=p>}</span>

        <span class=k>if</span> <span class=p>(</span><span class=n>end</span> <span class=o>-</span> <span class=n>ptr</span> <span class=o>&lt;</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>tr</span><span class=p>)</span> <span class=o>+</span> <span class=mi>4</span><span class=p>)</span>
            <span class=k>break</span><span class=p>;</span>

        <span class=k>switch</span> <span class=p>(</span><span class=n>w</span><span class=o>-&gt;</span><span class=n>type</span><span class=p>)</span> <span class=p>{</span>
        <span class=p>......</span>
        <span class=k>case</span> <span class=nl>BINDER_WORK_TRANSACTION_COMPLETE</span><span class=p>:</span> <span class=p>{</span>
            <span class=n>cmd</span> <span class=o>=</span> <span class=n>BR_TRANSACTION_COMPLETE</span><span class=p>;</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>put_user</span><span class=p>(</span><span class=n>cmd</span><span class=p>,</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>__user</span> <span class=o>*</span><span class=p>)</span><span class=n>ptr</span><span class=p>))</span>
                <span class=k>return</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
            <span class=n>ptr</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>);</span>

            <span class=n>binder_stat_br</span><span class=p>(</span><span class=n>proc</span><span class=p>,</span> <span class=kr>thread</span><span class=p>,</span> <span class=n>cmd</span><span class=p>);</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>binder_debug_mask</span> <span class=o>&amp;</span> <span class=n>BINDER_DEBUG_TRANSACTION_COMPLETE</span><span class=p>)</span>
                <span class=n>printk</span><span class=p>(</span><span class=n>KERN_INFO</span> <span class=s>&quot;binder: %d:%d BR_TRANSACTION_COMPLETE</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span>
                <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>);</span>

            <span class=n>list_del</span><span class=p>(</span><span class=o>&amp;</span><span class=n>w</span><span class=o>-&gt;</span><span class=n>entry</span><span class=p>);</span>
            <span class=n>kfree</span><span class=p>(</span><span class=n>w</span><span class=p>);</span>
            <span class=n>binder_stats</span><span class=p>.</span><span class=n>obj_deleted</span><span class=p>[</span><span class=n>BINDER_STAT_TRANSACTION_COMPLETE</span><span class=p>]</span><span class=o>++</span><span class=p>;</span>
                                               <span class=p>}</span> <span class=k>break</span><span class=p>;</span>
        <span class=p>......</span>
        <span class=p>}</span>

        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>t</span><span class=p>)</span>
            <span class=k>continue</span><span class=p>;</span>

        <span class=p>......</span>
    <span class=p>}</span>

<span class=nl>done</span><span class=p>:</span>
    <span class=p>......</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>在<code>binder_thread_read</code>函数中首先是写入一个操作码BR_NOOP到用户传进来的缓冲区中去。</p> <p>回忆一下上面的binder_transaction函数，这里的<code>thread-&gt;transaction_stack</code>不为NULL，并且<code>thread-&gt;todo</code>也不为空，所以线程不会进入休眠状态。<br> 进入while循环中，首先是从<code>thread-&gt;todo</code>队列中取回待处理事项w，w的类型为BINDER_WORK_TRANSACTION_COMPLETE，这也是在<code>binder_transaction</code>函数里面设置的。对BINDER_WORK_TRANSACTION_COMPLETE的处理也很简单，只是把一个操作码BR_TRANSACTION_COMPLETE写回到用户传进来的缓冲区中去。这时候，用户传进来的缓冲区就包含两个操作码了，分别是BR_NOOP和BINDER_WORK_TRANSACTION_COMPLETE。</p> <p><code>binder_thread_read</code>执行完之后，返回到<code>binder_ioctl</code>函数中，将操作结果写回到用户空间中去：</p> <div class=highlight><pre><span></span><code><span class=k>if</span> <span class=p>(</span><span class=n>copy_to_user</span><span class=p>(</span><span class=n>ubuf</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>bwr</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>bwr</span><span class=p>)))</span> <span class=p>{</span>
    <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
    <span class=k>goto</span> <span class=n>err</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>最后就返回到<code>IPCThreadState::talkWithDriver</code>函数中了。从<code>ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0</code>返回后，首先是清空之前写入Binder驱动程序的内容：</p> <div class=highlight><pre><span></span><code><span class=k>if</span> <span class=p>(</span><span class=n>bwr</span><span class=p>.</span><span class=n>write_consumed</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
     <span class=k>if</span> <span class=p>(</span><span class=n>bwr</span><span class=p>.</span><span class=n>write_consumed</span> <span class=o>&lt;</span> <span class=p>(</span><span class=kt>ssize_t</span><span class=p>)</span><span class=n>mOut</span><span class=p>.</span><span class=n>dataSize</span><span class=p>())</span>
          <span class=n>mOut</span><span class=p>.</span><span class=n>remove</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>bwr</span><span class=p>.</span><span class=n>write_consumed</span><span class=p>);</span>
     <span class=k>else</span>
          <span class=n>mOut</span><span class=p>.</span><span class=n>setDataSize</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div> <p>接着是设置从Binder驱动程序读取的内容：</p> <div class=highlight><pre><span></span><code><span class=k>if</span> <span class=p>(</span><span class=n>bwr</span><span class=p>.</span><span class=n>read_consumed</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
     <span class=n>mIn</span><span class=p>.</span><span class=n>setDataSize</span><span class=p>(</span><span class=n>bwr</span><span class=p>.</span><span class=n>read_consumed</span><span class=p>);</span>
     <span class=n>mIn</span><span class=p>.</span><span class=n>setDataPosition</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div> <p>然后就返回到<code>IPCThreadState::waitForResponse</code>函数。<br> <code>IPCThreadState::waitForResponse</code>函数的处理也很简单，就是处理刚才从Binder驱动程序读入内容了。从前面的分析中，我们知道，从Binder驱动程序读入的内容就是两个整数了，分别是BR_NOOP和BR_TRANSACTION_COMPLETE。对BR_NOOP的处理很简单，正如它的名字所示，什么也不做；而对BR_TRANSACTION_COMPLETE的处理，就分情况了，如果这个请求是异步的，那个整个BC_TRANSACTION操作就完成了，如果这个请求是同步的，即要等待回复的，也就是reply不为空，那么还要继续循环通过<code>IPCThreadState::talkWithDriver</code>进入到Binder驱动程序中去等待BC_TRANSACTION操作的处理结果。 </p> <p>这里属于后一种情况，于是再次通过<code>IPCThreadState::talkWithDriver</code>进入到Binder驱动程序的<code>binder_ioctl</code>函数中。不过这一次在<code>binder_ioctl</code>函数中，<code>bwr.write_size</code>等于0，而<code>bwr.read_size</code>大于0，于是再次进入到<code>binder_thread_read</code>函数中。这时候<code>thread-&gt;transaction_stack</code>仍然不为NULL，不过<code>thread-&gt;todo</code>队列已经为空了，因为前面我们已经处理过<code>thread-&gt;todo</code>队列的内容了，于是就通过下面语句进入休眠状态了，等待Service Manager的唤醒：</p> <div class=highlight><pre><span></span><code><span class=n>ret</span> <span class=o>=</span> <span class=n>wait_event_interruptible</span><span class=p>(</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>wait</span><span class=p>,</span> <span class=n>binder_has_thread_work</span><span class=p>(</span><span class=kr>thread</span><span class=p>));</span>
</code></pre></div> <p>现在，我们终于可以回到Service Manager被唤醒之后的过程了。前面我们说过，Service Manager此时正在<code>binder_thread_read</code>函数中休眠中：</p> <div class=highlight><pre><span></span><code><span class=k>static</span> <span class=kt>int</span>
<span class=n>binder_thread_read</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_proc</span> <span class=o>*</span><span class=n>proc</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>binder_thread</span> <span class=o>*</span><span class=kr>thread</span><span class=p>,</span>
                   <span class=kt>void</span>  <span class=n>__user</span> <span class=o>*</span><span class=n>buffer</span><span class=p>,</span> <span class=kt>int</span> <span class=n>size</span><span class=p>,</span> <span class=kt>signed</span> <span class=kt>long</span> <span class=o>*</span><span class=n>consumed</span><span class=p>,</span> <span class=kt>int</span> <span class=n>non_block</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=n>ptr</span> <span class=o>=</span> <span class=n>buffer</span> <span class=o>+</span> <span class=o>*</span><span class=n>consumed</span><span class=p>;</span>
    <span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=n>end</span> <span class=o>=</span> <span class=n>buffer</span> <span class=o>+</span> <span class=n>size</span><span class=p>;</span>

    <span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>wait_for_proc_work</span><span class=p>;</span>

    <span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=n>consumed</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>put_user</span><span class=p>(</span><span class=n>BR_NOOP</span><span class=p>,</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>__user</span> <span class=o>*</span><span class=p>)</span><span class=n>ptr</span><span class=p>))</span>
            <span class=k>return</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
        <span class=n>ptr</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>);</span>
    <span class=p>}</span>

<span class=nl>retry</span><span class=p>:</span>
    <span class=n>wait_for_proc_work</span> <span class=o>=</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>transaction_stack</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=o>&amp;&amp;</span> <span class=n>list_empty</span><span class=p>(</span><span class=o>&amp;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>);</span>

    <span class=p>......</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>wait_for_proc_work</span><span class=p>)</span> <span class=p>{</span>
        <span class=p>......</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>non_block</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>binder_has_proc_work</span><span class=p>(</span><span class=n>proc</span><span class=p>,</span> <span class=kr>thread</span><span class=p>))</span>
                <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>EAGAIN</span><span class=p>;</span>
        <span class=p>}</span> <span class=k>else</span>
            <span class=n>ret</span> <span class=o>=</span> <span class=n>wait_event_interruptible_exclusive</span><span class=p>(</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>wait</span><span class=p>,</span> <span class=n>binder_has_proc_work</span><span class=p>(</span><span class=n>proc</span><span class=p>,</span> <span class=kr>thread</span><span class=p>));</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=p>......</span>
    <span class=p>}</span>

    <span class=p>......</span>

    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
        <span class=kt>uint32_t</span> <span class=n>cmd</span><span class=p>;</span>
        <span class=k>struct</span> <span class=nc>binder_transaction_data</span> <span class=n>tr</span><span class=p>;</span>
        <span class=k>struct</span> <span class=nc>binder_work</span> <span class=o>*</span><span class=n>w</span><span class=p>;</span>
        <span class=k>struct</span> <span class=nc>binder_transaction</span> <span class=o>*</span><span class=n>t</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>

        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>list_empty</span><span class=p>(</span><span class=o>&amp;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>))</span>
            <span class=n>w</span> <span class=o>=</span> <span class=n>list_first_entry</span><span class=p>(</span><span class=o>&amp;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>binder_work</span><span class=p>,</span> <span class=n>entry</span><span class=p>);</span>
        <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=o>!</span><span class=n>list_empty</span><span class=p>(</span><span class=o>&amp;</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>wait_for_proc_work</span><span class=p>)</span>
            <span class=n>w</span> <span class=o>=</span> <span class=n>list_first_entry</span><span class=p>(</span><span class=o>&amp;</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>binder_work</span><span class=p>,</span> <span class=n>entry</span><span class=p>);</span>
        <span class=k>else</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>ptr</span> <span class=o>-</span> <span class=n>buffer</span> <span class=o>==</span> <span class=mi>4</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=p>(</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>looper</span> <span class=o>&amp;</span> <span class=n>BINDER_LOOPER_STATE_NEED_RETURN</span><span class=p>))</span> <span class=cm>/* no data added */</span>
                <span class=k>goto</span> <span class=n>retry</span><span class=p>;</span>
            <span class=k>break</span><span class=p>;</span>
        <span class=p>}</span>

        <span class=k>if</span> <span class=p>(</span><span class=n>end</span> <span class=o>-</span> <span class=n>ptr</span> <span class=o>&lt;</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>tr</span><span class=p>)</span> <span class=o>+</span> <span class=mi>4</span><span class=p>)</span>
            <span class=k>break</span><span class=p>;</span>

        <span class=k>switch</span> <span class=p>(</span><span class=n>w</span><span class=o>-&gt;</span><span class=n>type</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>case</span> <span class=nl>BINDER_WORK_TRANSACTION</span><span class=p>:</span> <span class=p>{</span>
            <span class=n>t</span> <span class=o>=</span> <span class=n>container_of</span><span class=p>(</span><span class=n>w</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>binder_transaction</span><span class=p>,</span> <span class=n>work</span><span class=p>);</span>
                                      <span class=p>}</span> <span class=k>break</span><span class=p>;</span>
        <span class=p>......</span>
        <span class=p>}</span>

        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>t</span><span class=p>)</span>
            <span class=k>continue</span><span class=p>;</span>

        <span class=n>BUG_ON</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>target_node</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>struct</span> <span class=nc>binder_node</span> <span class=o>*</span><span class=n>target_node</span> <span class=o>=</span> <span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>target_node</span><span class=p>;</span>
            <span class=n>tr</span><span class=p>.</span><span class=n>target</span><span class=p>.</span><span class=n>ptr</span> <span class=o>=</span> <span class=n>target_node</span><span class=o>-&gt;</span><span class=n>ptr</span><span class=p>;</span>
            <span class=n>tr</span><span class=p>.</span><span class=n>cookie</span> <span class=o>=</span>  <span class=n>target_node</span><span class=o>-&gt;</span><span class=n>cookie</span><span class=p>;</span>
            <span class=n>t</span><span class=o>-&gt;</span><span class=n>saved_priority</span> <span class=o>=</span> <span class=n>task_nice</span><span class=p>(</span><span class=n>current</span><span class=p>);</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>priority</span> <span class=o>&lt;</span> <span class=n>target_node</span><span class=o>-&gt;</span><span class=n>min_priority</span> <span class=o>&amp;&amp;</span>
                <span class=o>!</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>TF_ONE_WAY</span><span class=p>))</span>
                <span class=n>binder_set_nice</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>priority</span><span class=p>);</span>
            <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>TF_ONE_WAY</span><span class=p>)</span> <span class=o>||</span>
                <span class=n>t</span><span class=o>-&gt;</span><span class=n>saved_priority</span> <span class=o>&gt;</span> <span class=n>target_node</span><span class=o>-&gt;</span><span class=n>min_priority</span><span class=p>)</span>
                <span class=n>binder_set_nice</span><span class=p>(</span><span class=n>target_node</span><span class=o>-&gt;</span><span class=n>min_priority</span><span class=p>);</span>
            <span class=n>cmd</span> <span class=o>=</span> <span class=n>BR_TRANSACTION</span><span class=p>;</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=p>......</span>
        <span class=p>}</span>
        <span class=n>tr</span><span class=p>.</span><span class=n>code</span> <span class=o>=</span> <span class=n>t</span><span class=o>-&gt;</span><span class=n>code</span><span class=p>;</span>
        <span class=n>tr</span><span class=p>.</span><span class=n>flags</span> <span class=o>=</span> <span class=n>t</span><span class=o>-&gt;</span><span class=n>flags</span><span class=p>;</span>
        <span class=n>tr</span><span class=p>.</span><span class=n>sender_euid</span> <span class=o>=</span> <span class=n>t</span><span class=o>-&gt;</span><span class=n>sender_euid</span><span class=p>;</span>

        <span class=k>if</span> <span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>from</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>struct</span> <span class=nc>task_struct</span> <span class=o>*</span><span class=n>sender</span> <span class=o>=</span> <span class=n>t</span><span class=o>-&gt;</span><span class=n>from</span><span class=o>-&gt;</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>tsk</span><span class=p>;</span>
            <span class=n>tr</span><span class=p>.</span><span class=n>sender_pid</span> <span class=o>=</span> <span class=n>task_tgid_nr_ns</span><span class=p>(</span><span class=n>sender</span><span class=p>,</span> <span class=n>current</span><span class=o>-&gt;</span><span class=n>nsproxy</span><span class=o>-&gt;</span><span class=n>pid_ns</span><span class=p>);</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=p>......</span>
        <span class=p>}</span>

        <span class=n>tr</span><span class=p>.</span><span class=n>data_size</span> <span class=o>=</span> <span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>data_size</span><span class=p>;</span>
        <span class=n>tr</span><span class=p>.</span><span class=n>offsets_size</span> <span class=o>=</span> <span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>offsets_size</span><span class=p>;</span>
        <span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>buffer</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>+</span> <span class=n>proc</span><span class=o>-&gt;</span><span class=n>user_buffer_offset</span><span class=p>;</span>
        <span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>offsets</span> <span class=o>=</span> <span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>buffer</span> <span class=o>+</span> <span class=n>ALIGN</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>data_size</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>));</span>

        <span class=k>if</span> <span class=p>(</span><span class=n>put_user</span><span class=p>(</span><span class=n>cmd</span><span class=p>,</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>__user</span> <span class=o>*</span><span class=p>)</span><span class=n>ptr</span><span class=p>))</span>
            <span class=k>return</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
        <span class=n>ptr</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>copy_to_user</span><span class=p>(</span><span class=n>ptr</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>tr</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>tr</span><span class=p>)))</span>
            <span class=k>return</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
        <span class=n>ptr</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>tr</span><span class=p>);</span>

        <span class=p>......</span>

        <span class=n>list_del</span><span class=p>(</span><span class=o>&amp;</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>work</span><span class=p>.</span><span class=n>entry</span><span class=p>);</span>
        <span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>allow_user_free</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>cmd</span> <span class=o>==</span> <span class=n>BR_TRANSACTION</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>TF_ONE_WAY</span><span class=p>))</span> <span class=p>{</span>
            <span class=n>t</span><span class=o>-&gt;</span><span class=n>to_parent</span> <span class=o>=</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>transaction_stack</span><span class=p>;</span>
            <span class=n>t</span><span class=o>-&gt;</span><span class=n>to_thread</span> <span class=o>=</span> <span class=kr>thread</span><span class=p>;</span>
            <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>transaction_stack</span> <span class=o>=</span> <span class=n>t</span><span class=p>;</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=p>......</span>
        <span class=p>}</span>
        <span class=k>break</span><span class=p>;</span>
    <span class=p>}</span>

<span class=nl>done</span><span class=p>:</span>

    <span class=o>*</span><span class=n>consumed</span> <span class=o>=</span> <span class=n>ptr</span> <span class=o>-</span> <span class=n>buffer</span><span class=p>;</span>
    <span class=p>......</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>这里就是从语句中唤醒了：</p> <div class=highlight><pre><span></span><code><span class=n>ret</span> <span class=o>=</span> <span class=n>wait_event_interruptible_exclusive</span><span class=p>(</span><span class=n>proc</span><span class=o>-&gt;</span><span class=n>wait</span><span class=p>,</span> <span class=n>binder_has_proc_work</span><span class=p>(</span><span class=n>proc</span><span class=p>,</span> <span class=kr>thread</span><span class=p>));</span>
</code></pre></div> <p>Service Manager唤醒过来看，继续往下执行，进入到while循环中。首先是从proc-&gt;todo中取回待处理事项w。这个事项w的类型是BINDER_WORK_TRANSACTION，这是上面调用binder_transaction的时候设置的，于是通过w得到待处理事务t： </p> <div class=highlight><pre><span></span><code><span class=n>t</span> <span class=o>=</span> <span class=n>container_of</span><span class=p>(</span><span class=n>w</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>binder_transaction</span><span class=p>,</span> <span class=n>work</span><span class=p>);</span>
</code></pre></div> <p>接下来的内容，就把cmd和t-&gt;buffer的内容拷贝到用户传进来的缓冲区去了，这里就是Service Manager从用户空间传进来的缓冲区了：</p> <div class=highlight><pre><span></span><code><span class=k>if</span> <span class=p>(</span><span class=n>put_user</span><span class=p>(</span><span class=n>cmd</span><span class=p>,</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>__user</span> <span class=o>*</span><span class=p>)</span><span class=n>ptr</span><span class=p>))</span>
    <span class=k>return</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
<span class=n>ptr</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>);</span>
<span class=k>if</span> <span class=p>(</span><span class=n>copy_to_user</span><span class=p>(</span><span class=n>ptr</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>tr</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>tr</span><span class=p>)))</span>
    <span class=k>return</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
<span class=n>ptr</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>tr</span><span class=p>);</span>
</code></pre></div> <p>注意，这里先是把t-&gt;buffer的内容拷贝到本地变量tr中，再拷贝到用户空间缓冲区去。关于t-&gt;buffer内容的拷贝，请参考2.4节，它的一个关键地方是Binder驱动程序和Service Manager守护进程共享了同一个物理内存的内容，拷贝的只是这个物理内存在用户空间的虚拟地址回去：</p> <div class=highlight><pre><span></span><code><span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>buffer</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>+</span> <span class=n>proc</span><span class=o>-&gt;</span><span class=n>user_buffer_offset</span><span class=p>;</span>
<span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>offsets</span> <span class=o>=</span> <span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>buffer</span> <span class=o>+</span> <span class=n>ALIGN</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>data_size</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>));</span>
</code></pre></div> <p>然后，对于Binder驱动程序这次操作来说，这个事项就算是处理完了，就要从todo队列中删除：</p> <div class=highlight><pre><span></span><code><span class=n>list_del</span><span class=p>(</span><span class=o>&amp;</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>work</span><span class=p>.</span><span class=n>entry</span><span class=p>);</span>
</code></pre></div> <p>紧接着，还不慌删除这个事务，因为它还要等待Service Manager处理完成后，再进一步处理，因此，放在thread-&gt;transaction_stack队列中：</p> <div class=highlight><pre><span></span><code><span class=c1>// cmd为BR_TRANSACTION， t-&gt;flags也不为TF_ONE_WAY，所以走这个分支</span>
<span class=k>if</span> <span class=p>(</span><span class=n>cmd</span> <span class=o>==</span> <span class=n>BR_TRANSACTION</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>TF_ONE_WAY</span><span class=p>))</span> <span class=p>{</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>to_parent</span> <span class=o>=</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>transaction_stack</span><span class=p>;</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>to_thread</span> <span class=o>=</span> <span class=kr>thread</span><span class=p>;</span>
    <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>transaction_stack</span> <span class=o>=</span> <span class=n>t</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>注意上面写入的cmd = BR_TRANSACTION，告诉Service Manager守护进程，它要做什么事情，后面我们会看到相应的分析。 </p> <p>这样，<code>binder_thread_read</code>函数就处理完了，回到<code>binder_ioctl</code>函数中，同样是操作结果写回到用户空间的缓冲区中去：</p> <div class=highlight><pre><span></span><code><span class=k>if</span> <span class=p>(</span><span class=n>copy_to_user</span><span class=p>(</span><span class=n>ubuf</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>bwr</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>bwr</span><span class=p>)))</span> <span class=p>{</span>
    <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
    <span class=k>goto</span> <span class=n>err</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>最后就从framework中<code>binder.c</code>文件<code>binder_loop</code>函数的<code>res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</code>语句中返回了。接着就调用<code>binder_parse</code>函数分析从Binder驱动程序里面读取出来的数据，这里cmd为BR_TRANSACTION。因此，我们这只需要关注BR_TRANSACTION相关的逻辑：</p> <div class=highlight><pre><span></span><code><span class=kt>int</span> <span class=nf>binder_parse</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_state</span> <span class=o>*</span><span class=n>bs</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>binder_io</span> <span class=o>*</span><span class=n>bio</span><span class=p>,</span>
                 <span class=kt>uint32_t</span> <span class=o>*</span><span class=n>ptr</span><span class=p>,</span> <span class=kt>uint32_t</span> <span class=n>size</span><span class=p>,</span> <span class=n>binder_handler</span> <span class=n>func</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>int</span> <span class=n>r</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
    <span class=kt>uint32_t</span> <span class=o>*</span><span class=n>end</span> <span class=o>=</span> <span class=n>ptr</span> <span class=o>+</span> <span class=p>(</span><span class=n>size</span> <span class=o>/</span> <span class=mi>4</span><span class=p>);</span>

    <span class=k>while</span> <span class=p>(</span><span class=n>ptr</span> <span class=o>&lt;</span> <span class=n>end</span><span class=p>)</span> <span class=p>{</span>
        <span class=kt>uint32_t</span> <span class=n>cmd</span> <span class=o>=</span> <span class=o>*</span><span class=n>ptr</span><span class=o>++</span><span class=p>;</span>
        <span class=k>switch</span><span class=p>(</span><span class=n>cmd</span><span class=p>)</span> <span class=p>{</span>
        <span class=p>......</span>
        <span class=k>case</span> <span class=nl>BR_TRANSACTION</span><span class=p>:</span> <span class=p>{</span>
            <span class=k>struct</span> <span class=nc>binder_txn</span> <span class=o>*</span><span class=n>txn</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=n>ptr</span><span class=p>;</span>
            <span class=p>......</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>func</span><span class=p>)</span> <span class=p>{</span>
                <span class=kt>unsigned</span> <span class=n>rdata</span><span class=p>[</span><span class=mi>256</span><span class=o>/</span><span class=mi>4</span><span class=p>];</span>
                <span class=k>struct</span> <span class=nc>binder_io</span> <span class=n>msg</span><span class=p>;</span>
                <span class=k>struct</span> <span class=nc>binder_io</span> <span class=n>reply</span><span class=p>;</span>
                <span class=kt>int</span> <span class=n>res</span><span class=p>;</span>

                <span class=n>bio_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>reply</span><span class=p>,</span> <span class=n>rdata</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>rdata</span><span class=p>),</span> <span class=mi>4</span><span class=p>);</span>
                <span class=n>bio_init_from_txn</span><span class=p>(</span><span class=o>&amp;</span><span class=n>msg</span><span class=p>,</span> <span class=n>txn</span><span class=p>);</span>
                <span class=n>res</span> <span class=o>=</span> <span class=n>func</span><span class=p>(</span><span class=n>bs</span><span class=p>,</span> <span class=n>txn</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>msg</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>reply</span><span class=p>);</span>
                <span class=n>binder_send_reply</span><span class=p>(</span><span class=n>bs</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>reply</span><span class=p>,</span> <span class=n>txn</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>,</span> <span class=n>res</span><span class=p>);</span>
            <span class=p>}</span>
            <span class=n>ptr</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=n>txn</span><span class=p>)</span> <span class=o>/</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>);</span>
            <span class=k>break</span><span class=p>;</span>
                             <span class=p>}</span>
        <span class=p>......</span>
        <span class=k>default</span><span class=o>:</span>
            <span class=n>LOGE</span><span class=p>(</span><span class=s>&quot;parse: OOPS %d</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span> <span class=n>cmd</span><span class=p>);</span>
            <span class=k>return</span> <span class=mi>-1</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>r</span><span class=p>;</span>
<span class=p>}</span> 
</code></pre></div> <p>这里用到的两个数据结构<code>struct binder_txn</code>和<code>struct binder_io</code>可以参考2.4节，这里就不复述了。 </p> <p>接下来调用<code>bio_init</code>初始化<code>reply</code>变量，调用<code>bio_init_from_txn</code>来初始化<code>msg</code>变量。真正进行处理的函数是从参数中传进来的函数指针func，也就是对应的<code>svcmgr_handler</code>函数。 </p> <div class=highlight><pre><span></span><code><span class=kt>int</span> <span class=nf>svcmgr_handler</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_state</span> <span class=o>*</span><span class=n>bs</span><span class=p>,</span>
                   <span class=k>struct</span> <span class=nc>binder_txn</span> <span class=o>*</span><span class=n>txn</span><span class=p>,</span>
                   <span class=k>struct</span> <span class=nc>binder_io</span> <span class=o>*</span><span class=n>msg</span><span class=p>,</span>
                   <span class=k>struct</span> <span class=nc>binder_io</span> <span class=o>*</span><span class=n>reply</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>struct</span> <span class=nc>svcinfo</span> <span class=o>*</span><span class=n>si</span><span class=p>;</span>
    <span class=kt>uint16_t</span> <span class=o>*</span><span class=n>s</span><span class=p>;</span>
    <span class=kt>unsigned</span> <span class=n>len</span><span class=p>;</span>
    <span class=kt>void</span> <span class=o>*</span><span class=n>ptr</span><span class=p>;</span>
    <span class=kt>uint32_t</span> <span class=n>strict_policy</span><span class=p>;</span>

<span class=c1>//    LOGI(&quot;target=%p code=%d pid=%d uid=%d\n&quot;,</span>
<span class=c1>//         txn-&gt;target, txn-&gt;code, txn-&gt;sender_pid, txn-&gt;sender_euid);</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>txn</span><span class=o>-&gt;</span><span class=n>target</span> <span class=o>!=</span> <span class=n>svcmgr_handle</span><span class=p>)</span>
        <span class=k>return</span> <span class=mi>-1</span><span class=p>;</span>

    <span class=c1>// Equivalent to Parcel::enforceInterface(), reading the RPC</span>
    <span class=c1>// header with the strict mode policy mask and the interface name.</span>
    <span class=c1>// Note that we ignore the strict_policy and don&#39;t propagate it</span>
    <span class=c1>// further (since we do no outbound RPCs anyway).</span>
    <span class=n>strict_policy</span> <span class=o>=</span> <span class=n>bio_get_uint32</span><span class=p>(</span><span class=n>msg</span><span class=p>);</span>
    <span class=n>s</span> <span class=o>=</span> <span class=n>bio_get_string16</span><span class=p>(</span><span class=n>msg</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>len</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>((</span><span class=n>len</span> <span class=o>!=</span> <span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=n>svcmgr_id</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>))</span> <span class=o>||</span>
        <span class=n>memcmp</span><span class=p>(</span><span class=n>svcmgr_id</span><span class=p>,</span> <span class=n>s</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>svcmgr_id</span><span class=p>)))</span> <span class=p>{</span>
        <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&quot;invalid id %s</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span> <span class=n>str8</span><span class=p>(</span><span class=n>s</span><span class=p>));</span>
        <span class=k>return</span> <span class=mi>-1</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>switch</span><span class=p>(</span><span class=n>txn</span><span class=o>-&gt;</span><span class=n>code</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>case</span> <span class=nl>SVC_MGR_GET_SERVICE</span><span class=p>:</span>
    <span class=k>case</span> <span class=nl>SVC_MGR_CHECK_SERVICE</span><span class=p>:</span>
        <span class=n>s</span> <span class=o>=</span> <span class=n>bio_get_string16</span><span class=p>(</span><span class=n>msg</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>len</span><span class=p>);</span>
        <span class=n>ptr</span> <span class=o>=</span> <span class=n>do_find_service</span><span class=p>(</span><span class=n>bs</span><span class=p>,</span> <span class=n>s</span><span class=p>,</span> <span class=n>len</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>ptr</span><span class=p>)</span>
            <span class=k>break</span><span class=p>;</span>
        <span class=n>bio_put_ref</span><span class=p>(</span><span class=n>reply</span><span class=p>,</span> <span class=n>ptr</span><span class=p>);</span>
        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>

    <span class=p>......</span>
    <span class=p>}</span>
    <span class=k>default</span><span class=o>:</span>
        <span class=n>LOGE</span><span class=p>(</span><span class=s>&quot;unknown code %d</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span> <span class=n>txn</span><span class=o>-&gt;</span><span class=n>code</span><span class=p>);</span>
        <span class=k>return</span> <span class=mi>-1</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=n>bio_put_uint32</span><span class=p>(</span><span class=n>reply</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>这里， Service Manager要处理的code是SVC_MGR_CHECK_SERVICE，这是在前面的<code>BpServiceManager::checkService</code>函数里面设置的。<br> 回忆一下，在<code>BpServiceManager::checkService</code>时，传给Binder驱动程序的参数为：</p> <div class=highlight><pre><span></span><code><span class=n>writeInt32</span><span class=p>(</span><span class=n>IPCThreadState</span><span class=o>::</span><span class=n>self</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>getStrictModePolicy</span><span class=p>()</span> <span class=o>|</span> <span class=n>STRICT_MODE_PENALTY_GATHER</span><span class=p>);</span>  
<span class=n>writeString16</span><span class=p>(</span><span class=s>&quot;android.os.IServiceManager&quot;</span><span class=p>);</span>  
<span class=n>writeString16</span><span class=p>(</span><span class=s>&quot;media.player&quot;</span><span class=p>);</span>  
</code></pre></div> <p>在下面的代码中，会验证一下传进来的第二个参数，即"android.os.IServiceManager"是否正确，这个是验证RPC头，注释已经说得很清楚了。</p> <div class=highlight><pre><span></span><code><span class=n>strict_policy</span> <span class=o>=</span> <span class=n>bio_get_uint32</span><span class=p>(</span><span class=n>msg</span><span class=p>);</span>  
<span class=n>s</span> <span class=o>=</span> <span class=n>bio_get_string16</span><span class=p>(</span><span class=n>msg</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>len</span><span class=p>);</span>  
<span class=n>s</span> <span class=o>=</span> <span class=n>bio_get_string16</span><span class=p>(</span><span class=n>msg</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>len</span><span class=p>);</span>
</code></pre></div> <p>最后，就是调用<code>do_find_service</code>函数查找是存在名称为"media.player"的服务了。回忆一下2.4节中，MediaPlayerService已经把一个名称为"media.player"的服务注册到Service Manager中，所以这里一定能找到。我们看看do_find_service这个函数：</p> <div class=highlight><pre><span></span><code><span class=kt>void</span> <span class=o>*</span><span class=nf>do_find_service</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_state</span> <span class=o>*</span><span class=n>bs</span><span class=p>,</span> <span class=kt>uint16_t</span> <span class=o>*</span><span class=n>s</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=n>len</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>struct</span> <span class=nc>svcinfo</span> <span class=o>*</span><span class=n>si</span><span class=p>;</span>
    <span class=n>si</span> <span class=o>=</span> <span class=n>find_svc</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>len</span><span class=p>);</span>

<span class=c1>//    LOGI(&quot;check_service(&#39;%s&#39;) ptr = %p\n&quot;, str8(s), si ? si-&gt;ptr : 0);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>si</span> <span class=o>&amp;&amp;</span> <span class=n>si</span><span class=o>-&gt;</span><span class=n>ptr</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=n>si</span><span class=o>-&gt;</span><span class=n>ptr</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div> <p>这里又调用了<code>find_svc</code>函数在svclist列表中查找对应名称的svcinfo：</p> <div class=highlight><pre><span></span><code><span class=k>struct</span> <span class=nc>svcinfo</span> <span class=o>*</span><span class=n>find_svc</span><span class=p>(</span><span class=kt>uint16_t</span> <span class=o>*</span><span class=n>s16</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=n>len</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>struct</span> <span class=nc>svcinfo</span> <span class=o>*</span><span class=n>si</span><span class=p>;</span>

    <span class=k>for</span> <span class=p>(</span><span class=n>si</span> <span class=o>=</span> <span class=n>svclist</span><span class=p>;</span> <span class=n>si</span><span class=p>;</span> <span class=n>si</span> <span class=o>=</span> <span class=n>si</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>((</span><span class=n>len</span> <span class=o>==</span> <span class=n>si</span><span class=o>-&gt;</span><span class=n>len</span><span class=p>)</span> <span class=o>&amp;&amp;</span>
            <span class=o>!</span><span class=n>memcmp</span><span class=p>(</span><span class=n>s16</span><span class=p>,</span> <span class=n>si</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>,</span> <span class=n>len</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint16_t</span><span class=p>)))</span> <span class=p>{</span>
            <span class=k>return</span> <span class=n>si</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>然后返回到<code>do_find_service</code>函数中。回忆一下2.4节的分析，这里的si-&gt;ptr就是指MediaPlayerService这个Binder实体在Service Manager进程中的句柄值了。 </p> <p>回到<code>svcmgr_handler</code>函数中，调用<code>bio_put_ref</code>函数将这个Binder引用写回到reply参数。我们看看<code>bio_put_ref</code>的实现：</p> <div class=highlight><pre><span></span><code><span class=kt>void</span> <span class=nf>bio_put_ref</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_io</span> <span class=o>*</span><span class=n>bio</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>ptr</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>struct</span> <span class=nc>binder_object</span> <span class=o>*</span><span class=n>obj</span><span class=p>;</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>ptr</span><span class=p>)</span>
        <span class=n>obj</span> <span class=o>=</span> <span class=n>bio_alloc_obj</span><span class=p>(</span><span class=n>bio</span><span class=p>);</span>
    <span class=k>else</span>
        <span class=n>obj</span> <span class=o>=</span> <span class=n>bio_alloc</span><span class=p>(</span><span class=n>bio</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=n>obj</span><span class=p>));</span>

    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>obj</span><span class=p>)</span>
        <span class=k>return</span><span class=p>;</span>

    <span class=n>obj</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>=</span> <span class=mh>0x7f</span> <span class=o>|</span> <span class=n>FLAT_BINDER_FLAG_ACCEPTS_FDS</span><span class=p>;</span>
    <span class=n>obj</span><span class=o>-&gt;</span><span class=n>type</span> <span class=o>=</span> <span class=n>BINDER_TYPE_HANDLE</span><span class=p>;</span>
    <span class=n>obj</span><span class=o>-&gt;</span><span class=n>pointer</span> <span class=o>=</span> <span class=n>ptr</span><span class=p>;</span>
    <span class=n>obj</span><span class=o>-&gt;</span><span class=n>cookie</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>这里很简单，就是把一个类型为<code>BINDER_TYPE_HANDLE</code>的<code>binder_object</code>写入到reply缓冲区中去。这里的<code>binder_object</code>就是相当于是<code>flat_binder_obj</code>了，具体可以参考2.4节。</p> <p>再回到<code>svcmgr_handler</code>函数中，最后，还写入一个0值到reply缓冲区中，表示操作结果码：<code>bio_put_uint32(reply, 0)</code>。<br> 回到<code>binder_parse</code>函数，调用<code>binder_send_reply</code>函数将操作结果反馈给Binder驱动程序：</p> <div class=highlight><pre><span></span><code><span class=kt>void</span> <span class=nf>binder_send_reply</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_state</span> <span class=o>*</span><span class=n>bs</span><span class=p>,</span>
                       <span class=k>struct</span> <span class=nc>binder_io</span> <span class=o>*</span><span class=n>reply</span><span class=p>,</span>
                       <span class=kt>void</span> <span class=o>*</span><span class=n>buffer_to_free</span><span class=p>,</span>
                       <span class=kt>int</span> <span class=n>status</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>struct</span> <span class=p>{</span>
        <span class=kt>uint32_t</span> <span class=n>cmd_free</span><span class=p>;</span>
        <span class=kt>void</span> <span class=o>*</span><span class=n>buffer</span><span class=p>;</span>
        <span class=kt>uint32_t</span> <span class=n>cmd_reply</span><span class=p>;</span>
        <span class=k>struct</span> <span class=nc>binder_txn</span> <span class=n>txn</span><span class=p>;</span>
    <span class=p>}</span> <span class=n>__attribute__</span><span class=p>((</span><span class=n>packed</span><span class=p>))</span> <span class=n>data</span><span class=p>;</span>

    <span class=n>data</span><span class=p>.</span><span class=n>cmd_free</span> <span class=o>=</span> <span class=n>BC_FREE_BUFFER</span><span class=p>;</span>
    <span class=n>data</span><span class=p>.</span><span class=n>buffer</span> <span class=o>=</span> <span class=n>buffer_to_free</span><span class=p>;</span>
    <span class=n>data</span><span class=p>.</span><span class=n>cmd_reply</span> <span class=o>=</span> <span class=n>BC_REPLY</span><span class=p>;</span>
    <span class=n>data</span><span class=p>.</span><span class=n>txn</span><span class=p>.</span><span class=n>target</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>data</span><span class=p>.</span><span class=n>txn</span><span class=p>.</span><span class=n>cookie</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>data</span><span class=p>.</span><span class=n>txn</span><span class=p>.</span><span class=n>code</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>status</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>data</span><span class=p>.</span><span class=n>txn</span><span class=p>.</span><span class=n>flags</span> <span class=o>=</span> <span class=n>TF_STATUS_CODE</span><span class=p>;</span>
        <span class=n>data</span><span class=p>.</span><span class=n>txn</span><span class=p>.</span><span class=n>data_size</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
        <span class=n>data</span><span class=p>.</span><span class=n>txn</span><span class=p>.</span><span class=n>offs_size</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
        <span class=n>data</span><span class=p>.</span><span class=n>txn</span><span class=p>.</span><span class=n>data</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>status</span><span class=p>;</span>
        <span class=n>data</span><span class=p>.</span><span class=n>txn</span><span class=p>.</span><span class=n>offs</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=n>data</span><span class=p>.</span><span class=n>txn</span><span class=p>.</span><span class=n>flags</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
        <span class=n>data</span><span class=p>.</span><span class=n>txn</span><span class=p>.</span><span class=n>data_size</span> <span class=o>=</span> <span class=n>reply</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>-</span> <span class=n>reply</span><span class=o>-&gt;</span><span class=n>data0</span><span class=p>;</span>
        <span class=n>data</span><span class=p>.</span><span class=n>txn</span><span class=p>.</span><span class=n>offs_size</span> <span class=o>=</span> <span class=p>((</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span> <span class=n>reply</span><span class=o>-&gt;</span><span class=n>offs</span><span class=p>)</span> <span class=o>-</span> <span class=p>((</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span> <span class=n>reply</span><span class=o>-&gt;</span><span class=n>offs0</span><span class=p>);</span>
        <span class=n>data</span><span class=p>.</span><span class=n>txn</span><span class=p>.</span><span class=n>data</span> <span class=o>=</span> <span class=n>reply</span><span class=o>-&gt;</span><span class=n>data0</span><span class=p>;</span>
        <span class=n>data</span><span class=p>.</span><span class=n>txn</span><span class=p>.</span><span class=n>offs</span> <span class=o>=</span> <span class=n>reply</span><span class=o>-&gt;</span><span class=n>offs0</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>binder_write</span><span class=p>(</span><span class=n>bs</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>data</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>data</span><span class=p>));</span>
<span class=p>}</span>
</code></pre></div> <p>注意，这里的status参数是<code>svcmgr_handler</code>的返回值为0。从这里可以看出，<code>binder_send_reply</code>告诉Binder驱动程序执行<code>BC_FREE_BUFFER</code>和<code>BC_REPLY</code>命令，前者释放之前在<code>binder_transaction</code>分配的空间，地址为<code>buffer_to_free</code>，<code>buffer_to_free</code>这个地址是Binder驱动程序把自己在内核空间用的地址转换成用户空间地址再传给Service Manager的，所以Binder驱动程序拿到这个地址后，知道怎么样释放这个空间；后者告诉Binder驱动程序，它的SVC_MGR_CHECK_SERVICE操作已经完成了,要查询的服务的句柄值也是保存在data.txn.data，操作结果码是0，也是保存在data.txn.data中。<br> 函数的最后执行了<code>binder_write</code>操作：</p> <div class=highlight><pre><span></span><code><span class=kt>int</span> <span class=nf>binder_write</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_state</span> <span class=o>*</span><span class=n>bs</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>data</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=n>len</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>struct</span> <span class=nc>binder_write_read</span> <span class=n>bwr</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>res</span><span class=p>;</span>
    <span class=n>bwr</span><span class=p>.</span><span class=n>write_size</span> <span class=o>=</span> <span class=n>len</span><span class=p>;</span>
    <span class=n>bwr</span><span class=p>.</span><span class=n>write_consumed</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>bwr</span><span class=p>.</span><span class=n>write_buffer</span> <span class=o>=</span> <span class=p>(</span><span class=kt>unsigned</span><span class=p>)</span> <span class=n>data</span><span class=p>;</span>
    <span class=n>bwr</span><span class=p>.</span><span class=n>read_size</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>bwr</span><span class=p>.</span><span class=n>read_consumed</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>bwr</span><span class=p>.</span><span class=n>read_buffer</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>res</span> <span class=o>=</span> <span class=n>ioctl</span><span class=p>(</span><span class=n>bs</span><span class=o>-&gt;</span><span class=n>fd</span><span class=p>,</span> <span class=n>BINDER_WRITE_READ</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>bwr</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>res</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span><span class=s>&quot;binder_write: ioctl failed (%s)</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span>
                <span class=n>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=n>res</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>这里可以看出，只有写操作，没有读操作，即read_size为0。<br> 这里又是一个ioctl的BINDER_WRITE_READ操作。直入到驱动程序的binder_ioctl函数后，执行BINDER_WRITE_READ命令，这里就不累述了。<br> 最后，从<code>binder_ioctl</code>执行到<code>binder_thread_write</code>函数，首先是执行BC_FREE_BUFFER命令，这个命令的执行在2.4节中说过了，这里就不再累述了。 </p> <p>我们重点关注BC_REPLY命令的执行：</p> <div class=highlight><pre><span></span><code><span class=kt>int</span>  
<span class=nf>binder_thread_write</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_proc</span> <span class=o>*</span><span class=n>proc</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>binder_thread</span> <span class=o>*</span><span class=kr>thread</span><span class=p>,</span>  
                    <span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=n>buffer</span><span class=p>,</span> <span class=kt>int</span> <span class=n>size</span><span class=p>,</span> <span class=kt>signed</span> <span class=kt>long</span> <span class=o>*</span><span class=n>consumed</span><span class=p>)</span>  
<span class=p>{</span>  
    <span class=kt>uint32_t</span> <span class=n>cmd</span><span class=p>;</span>  
    <span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=n>ptr</span> <span class=o>=</span> <span class=n>buffer</span> <span class=o>+</span> <span class=o>*</span><span class=n>consumed</span><span class=p>;</span>  
    <span class=kt>void</span> <span class=n>__user</span> <span class=o>*</span><span class=n>end</span> <span class=o>=</span> <span class=n>buffer</span> <span class=o>+</span> <span class=n>size</span><span class=p>;</span>  

    <span class=k>while</span> <span class=p>(</span><span class=n>ptr</span> <span class=o>&lt;</span> <span class=n>end</span> <span class=o>&amp;&amp;</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>return_error</span> <span class=o>==</span> <span class=n>BR_OK</span><span class=p>)</span> <span class=p>{</span>  
        <span class=k>if</span> <span class=p>(</span><span class=n>get_user</span><span class=p>(</span><span class=n>cmd</span><span class=p>,</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>__user</span> <span class=o>*</span><span class=p>)</span><span class=n>ptr</span><span class=p>))</span>  
            <span class=k>return</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>  
        <span class=n>ptr</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>);</span>  
        <span class=k>if</span> <span class=p>(</span><span class=n>_IOC_NR</span><span class=p>(</span><span class=n>cmd</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>ARRAY_SIZE</span><span class=p>(</span><span class=n>binder_stats</span><span class=p>.</span><span class=n>bc</span><span class=p>))</span> <span class=p>{</span>  
            <span class=n>binder_stats</span><span class=p>.</span><span class=n>bc</span><span class=p>[</span><span class=n>_IOC_NR</span><span class=p>(</span><span class=n>cmd</span><span class=p>)]</span><span class=o>++</span><span class=p>;</span>  
            <span class=n>proc</span><span class=o>-&gt;</span><span class=n>stats</span><span class=p>.</span><span class=n>bc</span><span class=p>[</span><span class=n>_IOC_NR</span><span class=p>(</span><span class=n>cmd</span><span class=p>)]</span><span class=o>++</span><span class=p>;</span>  
            <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>stats</span><span class=p>.</span><span class=n>bc</span><span class=p>[</span><span class=n>_IOC_NR</span><span class=p>(</span><span class=n>cmd</span><span class=p>)]</span><span class=o>++</span><span class=p>;</span>  
        <span class=p>}</span>  
        <span class=k>switch</span> <span class=p>(</span><span class=n>cmd</span><span class=p>)</span> <span class=p>{</span>  
        <span class=p>......</span>  
        <span class=k>case</span> <span class=nl>BC_TRANSACTION</span><span class=p>:</span>  
        <span class=k>case</span> <span class=nl>BC_REPLY</span><span class=p>:</span> <span class=p>{</span>  
            <span class=k>struct</span> <span class=nc>binder_transaction_data</span> <span class=n>tr</span><span class=p>;</span>  

            <span class=k>if</span> <span class=p>(</span><span class=n>copy_from_user</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tr</span><span class=p>,</span> <span class=n>ptr</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>tr</span><span class=p>)))</span>  
                <span class=k>return</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>  
            <span class=n>ptr</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>tr</span><span class=p>);</span>  
            <span class=n>binder_transaction</span><span class=p>(</span><span class=n>proc</span><span class=p>,</span> <span class=kr>thread</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>tr</span><span class=p>,</span> <span class=n>cmd</span> <span class=o>==</span> <span class=n>BC_REPLY</span><span class=p>);</span>  
            <span class=k>break</span><span class=p>;</span>  
                       <span class=p>}</span>  

        <span class=p>......</span>  
        <span class=o>*</span><span class=n>consumed</span> <span class=o>=</span> <span class=n>ptr</span> <span class=o>-</span> <span class=n>buffer</span><span class=p>;</span>  
    <span class=p>}</span>  
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>  
<span class=p>}</span> 
</code></pre></div> <p>又再次进入到<code>binder_transaction</code>函数：</p> <div class=highlight><pre><span></span><code><span class=k>static</span> <span class=kt>void</span>
<span class=n>binder_transaction</span><span class=p>(</span><span class=k>struct</span> <span class=nc>binder_proc</span> <span class=o>*</span><span class=n>proc</span><span class=p>,</span> <span class=k>struct</span> <span class=nc>binder_thread</span> <span class=o>*</span><span class=kr>thread</span><span class=p>,</span>
<span class=k>struct</span> <span class=nc>binder_transaction_data</span> <span class=o>*</span><span class=n>tr</span><span class=p>,</span> <span class=kt>int</span> <span class=n>reply</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>struct</span> <span class=nc>binder_transaction</span> <span class=o>*</span><span class=n>t</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>binder_work</span> <span class=o>*</span><span class=n>tcomplete</span><span class=p>;</span>
    <span class=kt>size_t</span> <span class=o>*</span><span class=n>offp</span><span class=p>,</span> <span class=o>*</span><span class=n>off_end</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>binder_proc</span> <span class=o>*</span><span class=n>target_proc</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>binder_thread</span> <span class=o>*</span><span class=n>target_thread</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>binder_node</span> <span class=o>*</span><span class=n>target_node</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>list_head</span> <span class=o>*</span><span class=n>target_list</span><span class=p>;</span>
    <span class=n>wait_queue_head_t</span> <span class=o>*</span><span class=n>target_wait</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>binder_transaction</span> <span class=o>*</span><span class=n>in_reply_to</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=k>struct</span> <span class=nc>binder_transaction_log_entry</span> <span class=o>*</span><span class=n>e</span><span class=p>;</span>
    <span class=kt>uint32_t</span> <span class=n>return_error</span><span class=p>;</span>

    <span class=p>......</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>reply</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>in_reply_to</span> <span class=o>=</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>transaction_stack</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>in_reply_to</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
            <span class=p>......</span>
            <span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_FAILED_REPLY</span><span class=p>;</span>
            <span class=k>goto</span> <span class=n>err_empty_call_stack</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=p>......</span>
        <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>transaction_stack</span> <span class=o>=</span> <span class=n>in_reply_to</span><span class=o>-&gt;</span><span class=n>to_parent</span><span class=p>;</span>
        <span class=n>target_thread</span> <span class=o>=</span> <span class=n>in_reply_to</span><span class=o>-&gt;</span><span class=n>from</span><span class=p>;</span>
        <span class=p>......</span>
        <span class=n>target_proc</span> <span class=o>=</span> <span class=n>target_thread</span><span class=o>-&gt;</span><span class=n>proc</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=p>......</span>
    <span class=p>}</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>target_thread</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>e</span><span class=o>-&gt;</span><span class=n>to_thread</span> <span class=o>=</span> <span class=n>target_thread</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>;</span>
        <span class=n>target_list</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>target_thread</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>;</span>
        <span class=n>target_wait</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>target_thread</span><span class=o>-&gt;</span><span class=n>wait</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=p>......</span>
    <span class=p>}</span>


    <span class=cm>/* TODO: reuse incoming transaction for reply */</span>
    <span class=n>t</span> <span class=o>=</span> <span class=n>kzalloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=n>t</span><span class=p>),</span> <span class=n>GFP_KERNEL</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>t</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_FAILED_REPLY</span><span class=p>;</span>
        <span class=k>goto</span> <span class=n>err_alloc_t_failed</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>binder_stats</span><span class=p>.</span><span class=n>obj_created</span><span class=p>[</span><span class=n>BINDER_STAT_TRANSACTION</span><span class=p>]</span><span class=o>++</span><span class=p>;</span>

    <span class=n>tcomplete</span> <span class=o>=</span> <span class=n>kzalloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=n>tcomplete</span><span class=p>),</span> <span class=n>GFP_KERNEL</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>tcomplete</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_FAILED_REPLY</span><span class=p>;</span>
        <span class=k>goto</span> <span class=n>err_alloc_tcomplete_failed</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=p>......</span>

    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>reply</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=p>(</span><span class=n>tr</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>TF_ONE_WAY</span><span class=p>))</span>
        <span class=n>t</span><span class=o>-&gt;</span><span class=n>from</span> <span class=o>=</span> <span class=kr>thread</span><span class=p>;</span>
    <span class=k>else</span>
        <span class=n>t</span><span class=o>-&gt;</span><span class=n>from</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>sender_euid</span> <span class=o>=</span> <span class=n>proc</span><span class=o>-&gt;</span><span class=n>tsk</span><span class=o>-&gt;</span><span class=n>cred</span><span class=o>-&gt;</span><span class=n>euid</span><span class=p>;</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>to_proc</span> <span class=o>=</span> <span class=n>target_proc</span><span class=p>;</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>to_thread</span> <span class=o>=</span> <span class=n>target_thread</span><span class=p>;</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>code</span> <span class=o>=</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>code</span><span class=p>;</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>=</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>flags</span><span class=p>;</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>priority</span> <span class=o>=</span> <span class=n>task_nice</span><span class=p>(</span><span class=n>current</span><span class=p>);</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span> <span class=o>=</span> <span class=n>binder_alloc_buf</span><span class=p>(</span><span class=n>target_proc</span><span class=p>,</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>data_size</span><span class=p>,</span>
        <span class=n>tr</span><span class=o>-&gt;</span><span class=n>offsets_size</span><span class=p>,</span> <span class=o>!</span><span class=n>reply</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>TF_ONE_WAY</span><span class=p>));</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_FAILED_REPLY</span><span class=p>;</span>
        <span class=k>goto</span> <span class=n>err_binder_alloc_buf_failed</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>allow_user_free</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>debug_id</span> <span class=o>=</span> <span class=n>t</span><span class=o>-&gt;</span><span class=n>debug_id</span><span class=p>;</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>transaction</span> <span class=o>=</span> <span class=n>t</span><span class=p>;</span>
    <span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>target_node</span> <span class=o>=</span> <span class=n>target_node</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>target_node</span><span class=p>)</span>
        <span class=n>binder_inc_node</span><span class=p>(</span><span class=n>target_node</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>

    <span class=n>offp</span> <span class=o>=</span> <span class=p>(</span><span class=kt>size_t</span> <span class=o>*</span><span class=p>)(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>+</span> <span class=n>ALIGN</span><span class=p>(</span><span class=n>tr</span><span class=o>-&gt;</span><span class=n>data_size</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)));</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>copy_from_user</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>,</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>buffer</span><span class=p>,</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>data_size</span><span class=p>))</span> <span class=p>{</span>
        <span class=n>binder_user_error</span><span class=p>(</span><span class=s>&quot;binder: %d:%d got transaction with invalid &quot;</span>
            <span class=s>&quot;data ptr</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span> <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>);</span>
        <span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_FAILED_REPLY</span><span class=p>;</span>
        <span class=k>goto</span> <span class=n>err_copy_data_failed</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>copy_from_user</span><span class=p>(</span><span class=n>offp</span><span class=p>,</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>offsets</span><span class=p>,</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>offsets_size</span><span class=p>))</span> <span class=p>{</span>
        <span class=n>binder_user_error</span><span class=p>(</span><span class=s>&quot;binder: %d:%d got transaction with invalid &quot;</span>
            <span class=s>&quot;offsets ptr</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span> <span class=n>proc</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>,</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>pid</span><span class=p>);</span>
        <span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_FAILED_REPLY</span><span class=p>;</span>
        <span class=k>goto</span> <span class=n>err_copy_data_failed</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=p>......</span>

    <span class=n>off_end</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>offp</span> <span class=o>+</span> <span class=n>tr</span><span class=o>-&gt;</span><span class=n>offsets_size</span><span class=p>;</span>
    <span class=k>for</span> <span class=p>(;</span> <span class=n>offp</span> <span class=o>&lt;</span> <span class=n>off_end</span><span class=p>;</span> <span class=n>offp</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>struct</span> <span class=nc>flat_binder_object</span> <span class=o>*</span><span class=n>fp</span><span class=p>;</span>
        <span class=p>......</span>
        <span class=n>fp</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=nc>flat_binder_object</span> <span class=o>*</span><span class=p>)(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>+</span> <span class=o>*</span><span class=n>offp</span><span class=p>);</span>
        <span class=k>switch</span> <span class=p>(</span><span class=n>fp</span><span class=o>-&gt;</span><span class=n>type</span><span class=p>)</span> <span class=p>{</span>
        <span class=p>......</span>
        <span class=k>case</span> <span class=nl>BINDER_TYPE_HANDLE</span><span class=p>:</span>
        <span class=k>case</span> <span class=nl>BINDER_TYPE_WEAK_HANDLE</span><span class=p>:</span> <span class=p>{</span>
            <span class=k>struct</span> <span class=nc>binder_ref</span> <span class=o>*</span><span class=n>ref</span> <span class=o>=</span> <span class=n>binder_get_ref</span><span class=p>(</span><span class=n>proc</span><span class=p>,</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>handle</span><span class=p>);</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>ref</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
                <span class=p>......</span>
                <span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_FAILED_REPLY</span><span class=p>;</span>
                <span class=k>goto</span> <span class=n>err_binder_get_ref_failed</span><span class=p>;</span>
            <span class=p>}</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>ref</span><span class=o>-&gt;</span><span class=n>node</span><span class=o>-&gt;</span><span class=n>proc</span> <span class=o>==</span> <span class=n>target_proc</span><span class=p>)</span> <span class=p>{</span>
                <span class=p>......</span>
            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
                <span class=k>struct</span> <span class=nc>binder_ref</span> <span class=o>*</span><span class=n>new_ref</span><span class=p>;</span>
                <span class=n>new_ref</span> <span class=o>=</span> <span class=n>binder_get_ref_for_node</span><span class=p>(</span><span class=n>target_proc</span><span class=p>,</span> <span class=n>ref</span><span class=o>-&gt;</span><span class=n>node</span><span class=p>);</span>
                <span class=k>if</span> <span class=p>(</span><span class=n>new_ref</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
                    <span class=n>return_error</span> <span class=o>=</span> <span class=n>BR_FAILED_REPLY</span><span class=p>;</span>
                    <span class=k>goto</span> <span class=n>err_binder_get_ref_for_node_failed</span><span class=p>;</span>
                <span class=p>}</span>
                <span class=n>fp</span><span class=o>-&gt;</span><span class=n>handle</span> <span class=o>=</span> <span class=n>new_ref</span><span class=o>-&gt;</span><span class=n>desc</span><span class=p>;</span>
                <span class=n>binder_inc_ref</span><span class=p>(</span><span class=n>new_ref</span><span class=p>,</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>type</span> <span class=o>==</span> <span class=n>BINDER_TYPE_HANDLE</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
                <span class=p>......</span>
            <span class=p>}</span>
        <span class=p>}</span> <span class=k>break</span><span class=p>;</span>

        <span class=p>......</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>reply</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>BUG_ON</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>async_transaction</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>);</span>
        <span class=n>binder_pop_transaction</span><span class=p>(</span><span class=n>target_thread</span><span class=p>,</span> <span class=n>in_reply_to</span><span class=p>);</span>
    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>TF_ONE_WAY</span><span class=p>))</span> <span class=p>{</span>
        <span class=p>......</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=p>......</span>
    <span class=p>}</span>

    <span class=n>t</span><span class=o>-&gt;</span><span class=n>work</span><span class=p>.</span><span class=n>type</span> <span class=o>=</span> <span class=n>BINDER_WORK_TRANSACTION</span><span class=p>;</span>
    <span class=n>list_add_tail</span><span class=p>(</span><span class=o>&amp;</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>work</span><span class=p>.</span><span class=n>entry</span><span class=p>,</span> <span class=n>target_list</span><span class=p>);</span>
    <span class=n>tcomplete</span><span class=o>-&gt;</span><span class=n>type</span> <span class=o>=</span> <span class=n>BINDER_WORK_TRANSACTION_COMPLETE</span><span class=p>;</span>
    <span class=n>list_add_tail</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tcomplete</span><span class=o>-&gt;</span><span class=n>entry</span><span class=p>,</span> <span class=o>&amp;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>target_wait</span><span class=p>)</span>
        <span class=n>wake_up_interruptible</span><span class=p>(</span><span class=n>target_wait</span><span class=p>);</span>
    <span class=k>return</span><span class=p>;</span>

    <span class=p>......</span>
<span class=p>}</span>
</code></pre></div> <p>这次进入<code>binder_transaction</code>函数的情形和上面介绍的binder_transaction函数的情形基本一致，只是这里的proc、thread和target_proc、target_thread调换了角色，这里的proc和thread指的是Service Manager进程，而target_proc和target_thread指的是刚才请求SVC_MGR_CHECK_SERVICE的进程。 </p> <p>那么，这次是如何找到target_proc和target_thread呢。首先，我们注意到，这里的reply等于1，其次，上面我们提到，Binder驱动程序在唤醒Service Manager，告诉它有一个事务t要处理时，事务t虽然从Service Manager的todo队列中删除了，但是仍然保留在transaction_stack中。因此，这里可以从thread-&gt;transaction_stack找回这个等待回复的事务t，然后通过它找回target_proc和target_thread</p> <div class=highlight><pre><span></span><code><span class=n>in_reply_to</span> <span class=o>=</span> <span class=kr>thread</span><span class=o>-&gt;</span><span class=n>transaction_stack</span><span class=p>;</span>
<span class=n>target_thread</span> <span class=o>=</span> <span class=n>in_reply_to</span><span class=o>-&gt;</span><span class=n>from</span><span class=p>;</span>
<span class=n>target_list</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>target_thread</span><span class=o>-&gt;</span><span class=n>todo</span><span class=p>;</span>
<span class=n>target_wait</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>target_thread</span><span class=o>-&gt;</span><span class=n>wait</span><span class=p>;</span>
</code></pre></div> <p>再接着往下看，由于Service Manager返回来了一个Binder引用，所以这里要处理一下，就是中间的for循环了。这是一个BINDER_TYPE_HANDLE类型的Binder引用，这是前面设置的。先把<code>t-&gt;buffer-&gt;data</code>的内容转换为一个<code>struct flat_binder_object</code>对象fp，这里的fp-&gt;handle值就是这个Service在Service Manager进程里面的引用值了。接通过调用binder_get_ref函数得到Binder引用对象<code>struct binder_ref</code>类型的对象ref：</p> <div class=highlight><pre><span></span><code><span class=k>struct</span> <span class=nc>binder_ref</span> <span class=o>*</span><span class=n>ref</span> <span class=o>=</span> <span class=n>binder_get_ref</span><span class=p>(</span><span class=n>proc</span><span class=p>,</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>handle</span><span class=p>);</span>
</code></pre></div> <p>这里一定能找到，因为前面MediaPlayerService执行<code>IServiceManager::addService</code>的时候把自己添加到Service Manager的时候，会在Service Manager进程中创建这个Binder引用，然后把这个Binder引用的句柄值返回给Service Manager用户空间。</p> <p>这里面的ref-&gt;node-&gt;proc不等于target_proc，因为这个Binder实体是属于创建MediaPlayerService的进程的，而不是请求这个服务的远程接口的进程的，因此，这里调用<code>binder_get_ref_for_node</code>函数为这个Binder实体在target_proc创建一个引用：</p> <div class=highlight><pre><span></span><code><span class=k>struct</span> <span class=nc>binder_ref</span> <span class=o>*</span><span class=n>new_ref</span><span class=p>;</span>
<span class=n>new_ref</span> <span class=o>=</span> <span class=n>binder_get_ref_for_node</span><span class=p>(</span><span class=n>target_proc</span><span class=p>,</span> <span class=n>ref</span><span class=o>-&gt;</span><span class=n>node</span><span class=p>);</span>
</code></pre></div> <p>然后增加引用计数：</p> <div class=highlight><pre><span></span><code><span class=n>binder_inc_ref</span><span class=p>(</span><span class=n>new_ref</span><span class=p>,</span> <span class=n>fp</span><span class=o>-&gt;</span><span class=n>type</span> <span class=o>==</span> <span class=n>BINDER_TYPE_HANDLE</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</code></pre></div> <p>这样，返回数据中的Binder对象就处理完成了。注意，这里会把fp-&gt;handle的值改为在target_proc中的引用值：</p> <div class=highlight><pre><span></span><code><span class=n>fp</span><span class=o>-&gt;</span><span class=n>handle</span> <span class=o>=</span> <span class=n>new_ref</span><span class=o>-&gt;</span><span class=n>desc</span><span class=p>;</span>
</code></pre></div> <p>这里就相当于是把t-&gt;buffer-&gt;data里面的Binder对象的句柄值改写了。因为这是在另外一个不同的进程里面的Binder引用，所以句柄值当然要用新的了。这个值最终是要拷贝回target_proc进程的用户空间去的。再往下看：</p> <div class=highlight><pre><span></span><code><span class=k>if</span> <span class=p>(</span><span class=n>reply</span><span class=p>)</span> <span class=p>{</span>
     <span class=n>BUG_ON</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>async_transaction</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>);</span>
     <span class=n>binder_pop_transaction</span><span class=p>(</span><span class=n>target_thread</span><span class=p>,</span> <span class=n>in_reply_to</span><span class=p>);</span>
<span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>t</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>TF_ONE_WAY</span><span class=p>))</span> <span class=p>{</span>
     <span class=p>......</span>
<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
     <span class=p>......</span>
<span class=p>}</span>
</code></pre></div> <p>这里reply等于1，执行<code>binder_pop_transaction</code>函数把当前事务in_reply_to从target_thread-&gt;transaction_stack队列中删掉，这是上次调用<code>binder_transaction</code>函数的时候设置的，现在不需要了，所以把它删掉。 </p> <p>再往后的逻辑就跟前面执行<code>binder_transaction</code>函数时候一样了，这里不再介绍。最后的结果就是唤醒请求SVC_MGR_CHECK_SERVICE操作的线程：</p> <div class=highlight><pre><span></span><code><span class=k>if</span> <span class=p>(</span><span class=n>target_wait</span><span class=p>)</span>
    <span class=n>wake_up_interruptible</span><span class=p>(</span><span class=n>target_wait</span><span class=p>);</span>
</code></pre></div> <p>这样，Service Manger回复调用SVC_MGR_CHECK_SERVICE请求就算完成了，重新回到frameworks/base/cmds/servicemanager/binder.c文件中的binder_loop函数等待下一个Client请求的到来。事实上，Service Manger回到binder_loop函数再次执行ioctl函数时候，又会再次进入到binder_thread_read函数。这时个会发现thread-&gt;todo不为空，这是因为刚才我们调用了<code>list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);</code>把一个工作项tcompelete放在了在thread-&gt;todo中，这个tcompelete的type为BINDER_WORK_TRANSACTION_COMPLETE，因此，Binder驱动程序会执行下面操作：</p> <div class=highlight><pre><span></span><code><span class=k>switch</span> <span class=p>(</span><span class=n>w</span><span class=o>-&gt;</span><span class=n>type</span><span class=p>)</span> <span class=p>{</span>  
<span class=k>case</span> <span class=nl>BINDER_WORK_TRANSACTION_COMPLETE</span><span class=p>:</span> <span class=p>{</span>  
    <span class=n>cmd</span> <span class=o>=</span> <span class=n>BR_TRANSACTION_COMPLETE</span><span class=p>;</span>  
    <span class=k>if</span> <span class=p>(</span><span class=n>put_user</span><span class=p>(</span><span class=n>cmd</span><span class=p>,</span> <span class=p>(</span><span class=kt>uint32_t</span> <span class=n>__user</span> <span class=o>*</span><span class=p>)</span><span class=n>ptr</span><span class=p>))</span>  
        <span class=k>return</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>  
    <span class=n>ptr</span> <span class=o>+=</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>uint32_t</span><span class=p>);</span>  

    <span class=n>list_del</span><span class=p>(</span><span class=o>&amp;</span><span class=n>w</span><span class=o>-&gt;</span><span class=n>entry</span><span class=p>);</span>  
    <span class=n>kfree</span><span class=p>(</span><span class=n>w</span><span class=p>);</span>  

    <span class=p>}</span> <span class=k>break</span><span class=p>;</span>  
    <span class=p>......</span>  
<span class=p>}</span>  
</code></pre></div> <p>binder_loop函数执行完这个ioctl调用后，才会在下一次调用ioctl进入到Binder驱动程序进入休眠状态，等待下一次Client的请求。 上面讲到调用请求SVC_MGR_CHECK_SERVICE操作的线程被唤醒了，于是，重新执行binder_thread_read函数，马上执行的就是while循环。在while循环中，从thread-&gt;todo得到w，w-&gt;type为BINDER_WORK_TRANSACTION，于是，得到t。从上面可以知道，Service Manager返回来了一个Binder引用和一个结果码0回来，写在t-&gt;buffer-&gt;data里面，现在把t-&gt;buffer-&gt;data加上proc-&gt;user_buffer_offset，得到用户空间地址，保存在tr.data.ptr.buffer里面，这样用户空间就可以访问这个数据了。由于cmd不等于BR_TRANSACTION，这时就可以把t删除掉了，因为以后都不需要用了。 </p> <p>执行完这个函数后，就返回到binder_ioctl函数，执行下面语句，把数据返回给用户空间：</p> <div class=highlight><pre><span></span><code><span class=k>if</span> <span class=p>(</span><span class=n>copy_to_user</span><span class=p>(</span><span class=n>ubuf</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>bwr</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>bwr</span><span class=p>)))</span> <span class=p>{</span>  
    <span class=n>ret</span> <span class=o>=</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>  
    <span class=k>goto</span> <span class=n>err</span><span class=p>;</span>  
<span class=p>}</span>
</code></pre></div> <p>接着返回到用户空间<code>IPCThreadState::talkWithDriver</code>函数，最后返回到<code>IPCThreadState::waitForResponse</code>函数，最终执行到下面语句：</p> <div class=highlight><pre><span></span><code><span class=n>status_t</span> <span class=n>IPCThreadState</span><span class=o>::</span><span class=n>waitForResponse</span><span class=p>(</span><span class=n>Parcel</span> <span class=o>*</span><span class=n>reply</span><span class=p>,</span> <span class=n>status_t</span> <span class=o>*</span><span class=n>acquireResult</span><span class=p>)</span>  
<span class=p>{</span>  
    <span class=kt>int32_t</span> <span class=n>cmd</span><span class=p>;</span>  
    <span class=kt>int32_t</span> <span class=n>err</span><span class=p>;</span>  

    <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>  
        <span class=k>if</span> <span class=p>((</span><span class=n>err</span><span class=o>=</span><span class=n>talkWithDriver</span><span class=p>())</span> <span class=o>&lt;</span> <span class=n>NO_ERROR</span><span class=p>)</span> <span class=k>break</span><span class=p>;</span>  

        <span class=p>......</span>  

        <span class=n>cmd</span> <span class=o>=</span> <span class=n>mIn</span><span class=p>.</span><span class=n>readInt32</span><span class=p>();</span>  

        <span class=p>......</span>  

        <span class=k>switch</span> <span class=p>(</span><span class=n>cmd</span><span class=p>)</span> <span class=p>{</span>  
        <span class=p>......</span>  
        <span class=k>case</span> <span class=nl>BR_REPLY</span><span class=p>:</span>  
            <span class=p>{</span>  
                <span class=n>binder_transaction_data</span> <span class=n>tr</span><span class=p>;</span>  
                <span class=n>err</span> <span class=o>=</span> <span class=n>mIn</span><span class=p>.</span><span class=n>read</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tr</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>tr</span><span class=p>));</span>  
                <span class=n>LOG_ASSERT</span><span class=p>(</span><span class=n>err</span> <span class=o>==</span> <span class=n>NO_ERROR</span><span class=p>,</span> <span class=s>&quot;Not enough command data for brREPLY&quot;</span><span class=p>);</span>  
                <span class=k>if</span> <span class=p>(</span><span class=n>err</span> <span class=o>!=</span> <span class=n>NO_ERROR</span><span class=p>)</span> <span class=k>goto</span> <span class=n>finish</span><span class=p>;</span>  

                <span class=k>if</span> <span class=p>(</span><span class=n>reply</span><span class=p>)</span> <span class=p>{</span>  
                    <span class=c1>// tr.flags为0</span>
                    <span class=k>if</span> <span class=p>((</span><span class=n>tr</span><span class=p>.</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>TF_STATUS_CODE</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>  
                        <span class=n>reply</span><span class=o>-&gt;</span><span class=n>ipcSetDataReference</span><span class=p>(</span>  
                            <span class=n>reinterpret_cast</span><span class=o>&lt;</span><span class=k>const</span> <span class=kt>uint8_t</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>buffer</span><span class=p>),</span>  
                            <span class=n>tr</span><span class=p>.</span><span class=n>data_size</span><span class=p>,</span>  
                            <span class=n>reinterpret_cast</span><span class=o>&lt;</span><span class=k>const</span> <span class=kt>size_t</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>offsets</span><span class=p>),</span>  
                            <span class=n>tr</span><span class=p>.</span><span class=n>offsets_size</span><span class=o>/</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>size_t</span><span class=p>),</span>  
                            <span class=n>freeBuffer</span><span class=p>,</span> <span class=n>this</span><span class=p>);</span>  
                    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>  
                        <span class=p>......</span>
                    <span class=p>}</span>  
                <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>  
                    <span class=p>......</span> 
                <span class=p>}</span>  
            <span class=p>}</span>  
            <span class=k>goto</span> <span class=n>finish</span><span class=p>;</span>  

        <span class=p>......</span>  
        <span class=p>}</span>  
    <span class=p>}</span>  

<span class=nl>finish</span><span class=p>:</span>  
    <span class=p>......</span>  
    <span class=k>return</span> <span class=n>err</span><span class=p>;</span>  
<span class=p>}</span>  
</code></pre></div> <p>这里的tr.flags等于0，这个是在上面的binder_send_reply函数里设置的。接着就把结果保存在reply了：</p> <div class=highlight><pre><span></span><code><span class=n>reply</span><span class=o>-&gt;</span><span class=n>ipcSetDataReference</span><span class=p>(</span>  
       <span class=n>reinterpret_cast</span><span class=o>&lt;</span><span class=k>const</span> <span class=kt>uint8_t</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>buffer</span><span class=p>),</span>  
       <span class=n>tr</span><span class=p>.</span><span class=n>data_size</span><span class=p>,</span>  
       <span class=n>reinterpret_cast</span><span class=o>&lt;</span><span class=k>const</span> <span class=kt>size_t</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>tr</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>ptr</span><span class=p>.</span><span class=n>offsets</span><span class=p>),</span>  
       <span class=n>tr</span><span class=p>.</span><span class=n>offsets_size</span><span class=o>/</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>size_t</span><span class=p>),</span>  
       <span class=n>freeBuffer</span><span class=p>,</span> <span class=n>this</span><span class=p>);</span>  
</code></pre></div> <p>我们简单看一下<code>Parcel::ipcSetDataReference</code>函数的实现：</p> <div class=highlight><pre><span></span><code><span class=kt>void</span> <span class=n>Parcel</span><span class=o>::</span><span class=n>ipcSetDataReference</span><span class=p>(</span><span class=k>const</span> <span class=kt>uint8_t</span><span class=o>*</span> <span class=n>data</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>dataSize</span><span class=p>,</span>
    <span class=k>const</span> <span class=kt>size_t</span><span class=o>*</span> <span class=n>objects</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>objectsCount</span><span class=p>,</span> <span class=n>release_func</span> <span class=n>relFunc</span><span class=p>,</span> <span class=kt>void</span><span class=o>*</span> <span class=n>relCookie</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>freeDataNoInit</span><span class=p>();</span>
    <span class=n>mError</span> <span class=o>=</span> <span class=n>NO_ERROR</span><span class=p>;</span>
    <span class=n>mData</span> <span class=o>=</span> <span class=n>const_cast</span><span class=o>&lt;</span><span class=kt>uint8_t</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>data</span><span class=p>);</span>
    <span class=n>mDataSize</span> <span class=o>=</span> <span class=n>mDataCapacity</span> <span class=o>=</span> <span class=n>dataSize</span><span class=p>;</span>
    <span class=c1>//LOGI(&quot;setDataReference Setting data size of %p to %lu (pid=%d)\n&quot;, this, mDataSize, getpid());</span>
    <span class=n>mDataPos</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>LOGV</span><span class=p>(</span><span class=s>&quot;setDataReference Setting data pos of %p to %d</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span> <span class=n>this</span><span class=p>,</span> <span class=n>mDataPos</span><span class=p>);</span>
    <span class=n>mObjects</span> <span class=o>=</span> <span class=n>const_cast</span><span class=o>&lt;</span><span class=kt>size_t</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>objects</span><span class=p>);</span>
    <span class=n>mObjectsSize</span> <span class=o>=</span> <span class=n>mObjectsCapacity</span> <span class=o>=</span> <span class=n>objectsCount</span><span class=p>;</span>
    <span class=n>mNextObjectHint</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=n>mOwner</span> <span class=o>=</span> <span class=n>relFunc</span><span class=p>;</span>
    <span class=n>mOwnerCookie</span> <span class=o>=</span> <span class=n>relCookie</span><span class=p>;</span>
    <span class=n>scanForFds</span><span class=p>();</span>
<span class=p>}</span>
</code></pre></div> <p>上面提到，返回来的数据中有一个Binder引用，因此，这里的mObjectSize等于1，这个Binder引用对应的位置记录在mObjects成员变量中。</p> <p>从这里层层返回，最后回到<code>BpServiceManager::checkService</code>函数的<code>remote()-&gt;transact(CHECK_SERVICE_TRANSACTION, data, &amp;reply)</code>后，下面一行代码是</p> <div class=highlight><pre><span></span><code><span class=k>return</span> <span class=n>reply</span><span class=p>.</span><span class=n>readStrongBinder</span><span class=p>();</span>
</code></pre></div> <p>我们看一下其实现：</p> <div class=highlight><pre><span></span><code><span class=n>sp</span><span class=o>&lt;</span><span class=n>IBinder</span><span class=o>&gt;</span> <span class=n>Parcel</span><span class=o>::</span><span class=n>readStrongBinder</span><span class=p>()</span> <span class=k>const</span>
<span class=p>{</span>
    <span class=n>sp</span><span class=o>&lt;</span><span class=n>IBinder</span><span class=o>&gt;</span> <span class=n>val</span><span class=p>;</span>
    <span class=n>unflatten_binder</span><span class=p>(</span><span class=n>ProcessState</span><span class=o>::</span><span class=n>self</span><span class=p>(),</span> <span class=o>*</span><span class=n>this</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>val</span><span class=p>);</span>
    <span class=k>return</span> <span class=n>val</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>这里调用了<code>unflatten_binder</code>函数来构造一个Binder对象：</p> <div class=highlight><pre><span></span><code><span class=n>status_t</span> <span class=nf>unflatten_binder</span><span class=p>(</span><span class=k>const</span> <span class=n>sp</span><span class=o>&lt;</span><span class=n>ProcessState</span><span class=o>&gt;&amp;</span> <span class=n>proc</span><span class=p>,</span>
    <span class=k>const</span> <span class=n>Parcel</span><span class=o>&amp;</span> <span class=n>in</span><span class=p>,</span> <span class=n>sp</span><span class=o>&lt;</span><span class=n>IBinder</span><span class=o>&gt;*</span> <span class=n>out</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>const</span> <span class=n>flat_binder_object</span><span class=o>*</span> <span class=n>flat</span> <span class=o>=</span> <span class=n>in</span><span class=p>.</span><span class=n>readObject</span><span class=p>(</span><span class=nb>false</span><span class=p>);</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>flat</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>switch</span> <span class=p>(</span><span class=n>flat</span><span class=o>-&gt;</span><span class=n>type</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>case</span> <span class=nl>BINDER_TYPE_BINDER</span><span class=p>:</span>
                <span class=o>*</span><span class=n>out</span> <span class=o>=</span> <span class=n>static_cast</span><span class=o>&lt;</span><span class=n>IBinder</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>flat</span><span class=o>-&gt;</span><span class=n>cookie</span><span class=p>);</span>
                <span class=k>return</span> <span class=n>finish_unflatten_binder</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=o>*</span><span class=n>flat</span><span class=p>,</span> <span class=n>in</span><span class=p>);</span>
            <span class=k>case</span> <span class=nl>BINDER_TYPE_HANDLE</span><span class=p>:</span>
                <span class=o>*</span><span class=n>out</span> <span class=o>=</span> <span class=n>proc</span><span class=o>-&gt;</span><span class=n>getStrongProxyForHandle</span><span class=p>(</span><span class=n>flat</span><span class=o>-&gt;</span><span class=n>handle</span><span class=p>);</span>
                <span class=k>return</span> <span class=n>finish_unflatten_binder</span><span class=p>(</span>
                    <span class=n>static_cast</span><span class=o>&lt;</span><span class=n>BpBinder</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>out</span><span class=o>-&gt;</span><span class=n>get</span><span class=p>()),</span> <span class=o>*</span><span class=n>flat</span><span class=p>,</span> <span class=n>in</span><span class=p>);</span>
        <span class=p>}</span>        
    <span class=p>}</span>
    <span class=k>return</span> <span class=n>BAD_TYPE</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>这里的flat-&gt;type是BINDER_TYPE_HANDLE，因此调用<code>ProcessState::getStrongProxyForHandle</code>函数：</p> <div class=highlight><pre><span></span><code><span class=n>sp</span><span class=o>&lt;</span><span class=n>IBinder</span><span class=o>&gt;</span> <span class=n>ProcessState</span><span class=o>::</span><span class=n>getStrongProxyForHandle</span><span class=p>(</span><span class=kt>int32_t</span> <span class=n>handle</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>sp</span><span class=o>&lt;</span><span class=n>IBinder</span><span class=o>&gt;</span> <span class=n>result</span><span class=p>;</span>

    <span class=n>AutoMutex</span> <span class=nf>_l</span><span class=p>(</span><span class=n>mLock</span><span class=p>);</span>

    <span class=n>handle_entry</span><span class=o>*</span> <span class=n>e</span> <span class=o>=</span> <span class=n>lookupHandleLocked</span><span class=p>(</span><span class=n>handle</span><span class=p>);</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>e</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>// We need to create a new BpBinder if there isn&#39;t currently one, OR we</span>
        <span class=c1>// are unable to acquire a weak reference on this current one.  See comment</span>
        <span class=c1>// in getWeakProxyForHandle() for more info about this.</span>
        <span class=n>IBinder</span><span class=o>*</span> <span class=n>b</span> <span class=o>=</span> <span class=n>e</span><span class=o>-&gt;</span><span class=n>binder</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>b</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=o>||</span> <span class=o>!</span><span class=n>e</span><span class=o>-&gt;</span><span class=n>refs</span><span class=o>-&gt;</span><span class=n>attemptIncWeak</span><span class=p>(</span><span class=n>this</span><span class=p>))</span> <span class=p>{</span>
            <span class=n>b</span> <span class=o>=</span> <span class=n>new</span> <span class=n>BpBinder</span><span class=p>(</span><span class=n>handle</span><span class=p>);</span> 
            <span class=n>e</span><span class=o>-&gt;</span><span class=n>binder</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>b</span><span class=p>)</span> <span class=n>e</span><span class=o>-&gt;</span><span class=n>refs</span> <span class=o>=</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>getWeakRefs</span><span class=p>();</span>
            <span class=n>result</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=c1>// This little bit of nastyness is to allow us to add a primary</span>
            <span class=c1>// reference to the remote proxy when this team doesn&#39;t have one</span>
            <span class=c1>// but another team is sending the handle to us.</span>
            <span class=n>result</span><span class=p>.</span><span class=n>force_set</span><span class=p>(</span><span class=n>b</span><span class=p>);</span>
            <span class=n>e</span><span class=o>-&gt;</span><span class=n>refs</span><span class=o>-&gt;</span><span class=n>decWeak</span><span class=p>(</span><span class=n>this</span><span class=p>);</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>result</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <p>这里我们可以看到，ProcessState会把使用过的Binder远程接口（BpBinder）缓存起来，这样下次从Service Manager那里请求得到相同的句柄（Handle）时就可以直接返回这个Binder远程接口了，不用再创建一个出来。这里是第一次使用，因此，e-&gt;binder为空，于是创建了一个BpBinder对象。</p> <p>最后，函数返回到<code>IMediaDeathNotifier::getMediaPlayerService</code>这里，从这个语句返回：<code>binder = sm-&gt;getService(String16("media.player"));</code>。这就相当于<code>binder = new BpBinder(handle)</code>。 </p> <p>最后函数调用<code>sMediaPlayerService = interface_cast&lt;IMediaPlayerService&gt;(binder);</code>，这就等价于<code>sMediaPlayerService = new BpMediaPlayerService(new BpBinder(handle))</code>。最终，我们得到了一个<code>BpMediaPlayerService</code>对象，达到了我们的目标。 </p> <p>有了这个BpMediaPlayerService这个远程接口之后，MediaPlayer就可以调用MediaPlayerService的服务了。</p> <p>Framework里面的Binder总算把自个完全整懵了。Java层的Binder可以参考<a href=/android/framework/IPC机制/#33-binder>IPC机制——Binder</a>。</p> <hr> <div class=md-source-date> <small> 最后更新: <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date">2020年1月14日</span> </small> </div> <h2 id=__comments>评论</h2> <div id=disqus_thread></div> <script>var disqus_config=function(){this.page.url="https://blog.yorek.xyz/about-me/android/framework/binder2/",this.page.identifier="/android/framework/binder2/"};window.addEventListener("load",function(){var e=document,i=e.createElement("script");i.src="//yorekliu.disqus.com/embed.js",i.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(i)})</script> </article> </div> </div> </main> <footer class=md-footer> <div class=md-footer-nav> <nav class="md-footer-nav__inner md-grid" aria-label=Footer> <a href=../binder1-mediaservice/ class="md-footer-nav__link md-footer-nav__link--prev" rel=prev> <div class="md-footer-nav__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg> </div> <div class=md-footer-nav__title> <div class=md-ellipsis> <span class=md-footer-nav__direction> 上一页 </span> Binder深入理解——以MediaService为例 </div> </div> </a> <a href=../../paid/zsxq/zsxq_index/ class="md-footer-nav__link md-footer-nav__link--next" rel=next> <div class=md-footer-nav__title> <div class=md-ellipsis> <span class=md-footer-nav__direction> 下一页 </span> 某圈问题索引 </div> </div> <div class="md-footer-nav__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg> </div> </a> </nav> </div> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-footer-copyright> <div class=md-footer-copyright__highlight> &copy; 2021 Yorek </div> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> <div class=md-footer-social> <a href=https://github.com/YorekLiu target=_blank rel=noopener title=github.com class=md-footer-social__link> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 2A10 10 0 002 12c0 4.42 2.87 8.17 6.84 9.5.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34-.46-1.16-1.11-1.47-1.11-1.47-.91-.62.07-.6.07-.6 1 .07 1.53 1.03 1.53 1.03.87 1.52 2.34 1.07 2.91.83.09-.65.35-1.09.63-1.34-2.22-.25-4.55-1.11-4.55-4.92 0-1.11.38-2 1.03-2.71-.1-.25-.45-1.29.1-2.64 0 0 .84-.27 2.75 1.02.79-.22 1.65-.33 2.5-.33.85 0 1.71.11 2.5.33 1.91-1.29 2.75-1.02 2.75-1.02.55 1.35.2 2.39.1 2.64.65.71 1.03 1.6 1.03 2.71 0 3.82-2.34 4.66-4.57 4.91.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0012 2z"/></svg> </a> <a href=lyytogether@gmail.com target=_blank rel=noopener title class=md-footer-social__link> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 8l-8 5-8-5V6l8 5 8-5m0-2H4c-1.11 0-2 .89-2 2v12a2 2 0 002 2h16a2 2 0 002-2V6a2 2 0 00-2-2z"/></svg> </a> </div> </div> </div> </footer> </div> <script src=../../../assets/javascripts/vendor.93c04032.min.js></script> <script src=../../../assets/javascripts/bundle.83e5331e.min.js></script><script id=__lang type=application/json>{"clipboard.copy": "\u590d\u5236", "clipboard.copied": "\u5df2\u590d\u5236", "search.config.lang": "ja", "search.config.pipeline": "trimmer, stemmer", "search.config.separator": "[\\uff0c\\u3002]+", "search.placeholder": "\u641c\u7d22", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}</script> <script>
        app = initialize({
          base: "../../..",
          features: ['navigation.tabs', 'navigation.instant'],
          search: Object.assign({
            worker: "../../../assets/javascripts/worker/search.8c7e0a7e.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script> <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script> </body> </html>